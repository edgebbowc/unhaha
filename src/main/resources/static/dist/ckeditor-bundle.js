function Ag(s, e) {
    for (var t = 0; t < e.length; t++) {
        const i = e[t];
        if (typeof i != "string" && !Array.isArray(i)) {
            for (const n in i) if (n !== "default" && !(n in s)) {
                const o = Object.getOwnPropertyDescriptor(i, n);
                o && Object.defineProperty(s, n, o.get ? o : {enumerable: !0, get: () => i[n]})
            }
        }
    }
    return Object.freeze(Object.defineProperty(s, Symbol.toStringTag, {value: "Module"}))
}

function Ti(s) {
    return s
}

function As() {
}

function Hr(s) {
    return s == null || typeof s != "object" && typeof s != "function"
}

function Ur(s) {
    return ArrayBuffer.isView(s) && !(s instanceof DataView)
}

function $r(s) {
    if (Hr(s)) return s;
    if (Array.isArray(s) || Ur(s) || s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
    const e = Object.getPrototypeOf(s), t = e.constructor;
    if (s instanceof Date || s instanceof Map || s instanceof Set) return new t(s);
    if (s instanceof RegExp) {
        const i = new t(s);
        return i.lastIndex = s.lastIndex, i
    }
    if (s instanceof DataView) return new t(s.buffer.slice(0));
    if (s instanceof Error) {
        const i = new t(s.message);
        return i.stack = s.stack, i.name = s.name, i.cause = s.cause, i
    }
    if (typeof File < "u" && s instanceof File) return new t([s], s.name, {type: s.type, lastModified: s.lastModified});
    if (typeof s == "object") {
        const i = Object.create(e);
        return Object.assign(i, s)
    }
    return s
}

function La(s) {
    if (!s || typeof s != "object") return !1;
    const e = Object.getPrototypeOf(s);
    return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(s) === "[object Object]" : !1
}

function nr(s) {
    return typeof s == "object" && s !== null
}

function xs(s) {
    return Object.getOwnPropertySymbols(s).filter(e => Object.prototype.propertyIsEnumerable.call(s, e))
}

function Is(s) {
    return s == null ? s === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s)
}

const bd = "[object RegExp]", Wr = "[object String]", qr = "[object Number]", jr = "[object Boolean]",
    Ss = "[object Arguments]", _d = "[object Symbol]", vd = "[object Date]", yd = "[object Map]", kd = "[object Set]",
    Cd = "[object Array]", xg = "[object Function]", Ed = "[object ArrayBuffer]", ws = "[object Object]",
    Ig = "[object Error]", Td = "[object DataView]", Ad = "[object Uint8Array]", xd = "[object Uint8ClampedArray]",
    Id = "[object Uint16Array]", Sd = "[object Uint32Array]", Sg = "[object BigUint64Array]", Pd = "[object Int8Array]",
    Rd = "[object Int16Array]", Vd = "[object Int32Array]", Pg = "[object BigInt64Array]", Od = "[object Float32Array]",
    Md = "[object Float64Array]";

function Rg(s, e) {
    return Ri(s, void 0, s, new Map, e)
}

function Ri(s, e, t, i = new Map, n = void 0) {
    const o = n?.(s, e, t, i);
    if (o != null) return o;
    if (Hr(s)) return s;
    if (i.has(s)) return i.get(s);
    if (Array.isArray(s)) {
        const r = new Array(s.length);
        i.set(s, r);
        for (let a = 0; a < s.length; a++) r[a] = Ri(s[a], a, t, i, n);
        return Object.hasOwn(s, "index") && (r.index = s.index), Object.hasOwn(s, "input") && (r.input = s.input), r
    }
    if (s instanceof Date) return new Date(s.getTime());
    if (s instanceof RegExp) {
        const r = new RegExp(s.source, s.flags);
        return r.lastIndex = s.lastIndex, r
    }
    if (s instanceof Map) {
        const r = new Map;
        i.set(s, r);
        for (const [a, l] of s) r.set(a, Ri(l, a, t, i, n));
        return r
    }
    if (s instanceof Set) {
        const r = new Set;
        i.set(s, r);
        for (const a of s) r.add(Ri(a, void 0, t, i, n));
        return r
    }
    if (typeof Buffer < "u" && Buffer.isBuffer(s)) return s.subarray();
    if (Ur(s)) {
        const r = new (Object.getPrototypeOf(s)).constructor(s.length);
        i.set(s, r);
        for (let a = 0; a < s.length; a++) r[a] = Ri(s[a], a, t, i, n);
        return r
    }
    if (s instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s instanceof SharedArrayBuffer) return s.slice(0);
    if (s instanceof DataView) {
        const r = new DataView(s.buffer.slice(0), s.byteOffset, s.byteLength);
        return i.set(s, r), Qt(r, s, t, i, n), r
    }
    if (typeof File < "u" && s instanceof File) {
        const r = new File([s], s.name, {type: s.type});
        return i.set(s, r), Qt(r, s, t, i, n), r
    }
    if (s instanceof Blob) {
        const r = new Blob([s], {type: s.type});
        return i.set(s, r), Qt(r, s, t, i, n), r
    }
    if (s instanceof Error) {
        const r = new s.constructor;
        return i.set(s, r), r.message = s.message, r.name = s.name, r.stack = s.stack, r.cause = s.cause, Qt(r, s, t, i, n), r
    }
    if (typeof s == "object" && Vg(s)) {
        const r = Object.create(Object.getPrototypeOf(s));
        return i.set(s, r), Qt(r, s, t, i, n), r
    }
    return s
}

function Qt(s, e, t = s, i, n) {
    const o = [...Object.keys(e), ...xs(e)];
    for (let r = 0; r < o.length; r++) {
        const a = o[r], l = Object.getOwnPropertyDescriptor(s, a);
        (l == null || l.writable) && (s[a] = Ri(e[a], a, t, i, n))
    }
}

function Vg(s) {
    switch (Is(s)) {
        case Ss:
        case Cd:
        case Ed:
        case Td:
        case jr:
        case vd:
        case Od:
        case Md:
        case Pd:
        case Rd:
        case Vd:
        case yd:
        case qr:
        case ws:
        case bd:
        case kd:
        case Wr:
        case _d:
        case Ad:
        case xd:
        case Id:
        case Sd:
            return !0;
        default:
            return !1
    }
}

function Bd(s, e) {
    return s === e || Number.isNaN(s) && Number.isNaN(e)
}

function Fd(s, e, t) {
    return fn(s, e, void 0, void 0, void 0, void 0, t)
}

function fn(s, e, t, i, n, o, r) {
    const a = r(s, e, t, i, n, o);
    if (a !== void 0) return a;
    if (typeof s == typeof e) switch (typeof s) {
        case"bigint":
        case"string":
        case"boolean":
        case"symbol":
        case"undefined":
            return s === e;
        case"number":
            return s === e || Object.is(s, e);
        case"function":
            return s === e;
        case"object":
            return wn(s, e, o, r)
    }
    return wn(s, e, o, r)
}

function wn(s, e, t, i) {
    if (Object.is(s, e)) return !0;
    let n = Is(s), o = Is(e);
    if (n === Ss && (n = ws), o === Ss && (o = ws), n !== o) return !1;
    switch (n) {
        case Wr:
            return s.toString() === e.toString();
        case qr: {
            const l = s.valueOf(), c = e.valueOf();
            return Bd(l, c)
        }
        case jr:
        case vd:
        case _d:
            return Object.is(s.valueOf(), e.valueOf());
        case bd:
            return s.source === e.source && s.flags === e.flags;
        case xg:
            return s === e
    }
    t = t ?? new Map;
    const r = t.get(s), a = t.get(e);
    if (r != null && a != null) return r === e;
    t.set(s, e), t.set(e, s);
    try {
        switch (n) {
            case yd: {
                if (s.size !== e.size) return !1;
                for (const [l, c] of s.entries()) if (!e.has(l) || !fn(c, e.get(l), l, s, e, t, i)) return !1;
                return !0
            }
            case kd: {
                if (s.size !== e.size) return !1;
                const l = Array.from(s.values()), c = Array.from(e.values());
                for (let u = 0; u < l.length; u++) {
                    const d = l[u], h = c.findIndex(f => fn(d, f, void 0, s, e, t, i));
                    if (h === -1) return !1;
                    c.splice(h, 1)
                }
                return !0
            }
            case Cd:
            case Ad:
            case xd:
            case Id:
            case Sd:
            case Sg:
            case Pd:
            case Rd:
            case Vd:
            case Pg:
            case Od:
            case Md: {
                if (typeof Buffer < "u" && Buffer.isBuffer(s) !== Buffer.isBuffer(e) || s.length !== e.length) return !1;
                for (let l = 0; l < s.length; l++) if (!fn(s[l], e[l], l, s, e, t, i)) return !1;
                return !0
            }
            case Ed:
                return s.byteLength !== e.byteLength ? !1 : wn(new Uint8Array(s), new Uint8Array(e), t, i);
            case Td:
                return s.byteLength !== e.byteLength || s.byteOffset !== e.byteOffset ? !1 : wn(new Uint8Array(s), new Uint8Array(e), t, i);
            case Ig:
                return s.name === e.name && s.message === e.message;
            case ws: {
                if (!(wn(s.constructor, e.constructor, t, i) || La(s) && La(e))) return !1;
                const c = [...Object.keys(s), ...xs(s)], u = [...Object.keys(e), ...xs(e)];
                if (c.length !== u.length) return !1;
                for (let d = 0; d < c.length; d++) {
                    const h = c[d], f = s[h];
                    if (!Object.hasOwn(e, h)) return !1;
                    const m = e[h];
                    if (!fn(f, m, h, s, e, t, i)) return !1
                }
                return !0
            }
            default:
                return !1
        }
    } finally {
        t.delete(s), t.delete(e)
    }
}

function Ps(s, e) {
    return Fd(s, e, As)
}

function Rs(s) {
    return typeof s == "function"
}

function Og(s) {
    return Number.isSafeInteger(s) && s >= 0
}

const Mg = new RegExp("\\p{Lu}?\\p{Ll}+|[0-9]+|\\p{Lu}+(?!\\p{Ll})|\\p{Emoji_Presentation}|\\p{Extended_Pictographic}|\\p{L}+", "gu");

function Bg(s) {
    return Array.from(s.match(Mg) ?? [])
}

function Fg(s) {
    return s != null && typeof s != "function" && Og(s.length)
}

function Ld(s) {
    switch (typeof s) {
        case"number":
        case"symbol":
            return !1;
        case"string":
            return s.includes(".") || s.includes("[") || s.includes("]")
    }
}

function Dd(s) {
    return Object.is(s, -0) ? "-0" : s.toString()
}

function Gr(s) {
    const e = [], t = s.length;
    if (t === 0) return e;
    let i = 0, n = "", o = "", r = !1;
    for (s.charCodeAt(0) === 46 && (e.push(""), i++); i < t;) {
        const a = s[i];
        o ? a === "\\" && i + 1 < t ? (i++, n += s[i]) : a === o ? o = "" : n += a : r ? a === '"' || a === "'" ? o = a : a === "]" ? (r = !1, e.push(n), n = "") : n += a : a === "[" ? (r = !0, n && (e.push(n), n = "")) : a === "." ? n && (e.push(n), n = "") : n += a, i++
    }
    return n && e.push(n), e
}

function Nt(s, e, t) {
    if (s == null) return t;
    switch (typeof e) {
        case"string": {
            const i = s[e];
            return i === void 0 ? Ld(e) ? Nt(s, Gr(e), t) : t : i
        }
        case"number":
        case"symbol": {
            typeof e == "number" && (e = Dd(e));
            const i = s[e];
            return i === void 0 ? t : i
        }
        default: {
            if (Array.isArray(e)) return Lg(s, e, t);
            Object.is(e?.valueOf(), -0) ? e = "-0" : e = String(e);
            const i = s[e];
            return i === void 0 ? t : i
        }
    }
}

function Lg(s, e, t) {
    if (e.length === 0) return t;
    let i = s;
    for (let n = 0; n < e.length; n++) {
        if (i == null) return t;
        i = i[e[n]]
    }
    return i === void 0 ? t : i
}

function Dg(s) {
    return function (e) {
        return Nt(e, s)
    }
}

function tt(s) {
    return s !== null && (typeof s == "object" || typeof s == "function")
}

function Ks(s, e) {
    return Rg(s, (t, i, n, o) => {
        const r = e?.(t, i, n, o);
        if (r != null) return r;
        if (typeof s == "object") switch (Object.prototype.toString.call(s)) {
            case qr:
            case Wr:
            case jr: {
                const a = new s.constructor(s?.valueOf());
                return Qt(a, s), a
            }
            case Ss: {
                const a = {};
                return Qt(a, s), a.length = s.length, a[Symbol.iterator] = s[Symbol.iterator], a
            }
            default:
                return
        }
    })
}

function Ve(s) {
    return Ks(s)
}

const Ng = /^(?:0|[1-9]\d*)$/;

function zg(s, e = Number.MAX_SAFE_INTEGER) {
    switch (typeof s) {
        case"number":
            return Number.isInteger(s) && s >= 0 && s < e;
        case"symbol":
            return !1;
        case"string":
            return Ng.test(s)
    }
}

function Da(s) {
    return s !== null && typeof s == "object" && Is(s) === "[object Arguments]"
}

function Hg(s) {
    return typeof s == "symbol" || s instanceof Symbol
}

function Ug(s) {
    return Hg(s) ? NaN : Number(s)
}

function $g(s) {
    return s ? (s = Ug(s), s === 1 / 0 || s === -1 / 0 ? (s < 0 ? -1 : 1) * Number.MAX_VALUE : s === s ? s : 0) : s === 0 ? s : 0
}

function Wg(s) {
    const e = $g(s), t = e % 1;
    return t ? e - t : e
}

function Na(s) {
    return typeof s == "string" || s instanceof String
}

function Nd(s, e, t) {
    const i = Array.isArray(e) ? e : typeof e == "string" ? Gr(e) : [e];
    let n = s;
    for (let r = 0; r < i.length - 1; r++) {
        const a = i[r], l = i[r + 1];
        n[a] == null && (n[a] = zg(l) ? [] : {}), n = n[a]
    }
    const o = i[i.length - 1];
    return n[o] = t, s
}

function qg(s, e, {signal: t, edges: i} = {}) {
    let n, o = null;
    const r = i != null && i.includes("leading"), a = i == null || i.includes("trailing"), l = () => {
        o !== null && (s.apply(n, o), n = void 0, o = null)
    }, c = () => {
        a && l(), f()
    };
    let u = null;
    const d = () => {
        u != null && clearTimeout(u), u = setTimeout(() => {
            u = null, c()
        }, e)
    }, h = () => {
        u !== null && (clearTimeout(u), u = null)
    }, f = () => {
        h(), n = void 0, o = null
    }, m = () => {
        h(), l()
    }, g = function (..._) {
        if (t?.aborted) return;
        n = this, o = _;
        const v = u == null;
        d(), r && v && l()
    };
    return g.schedule = d, g.cancel = f, g.flush = m, t?.addEventListener("abort", f, {once: !0}), g
}

function it(s, e = 0, t = {}) {
    typeof t != "object" && (t = {});
    const {signal: i, leading: n = !1, trailing: o = !0, maxWait: r} = t, a = Array(2);
    n && (a[0] = "leading"), o && (a[1] = "trailing");
    let l, c = null;
    const u = qg(function (...f) {
        l = s.apply(this, f), c = null
    }, e, {signal: i, edges: a}), d = function (...f) {
        if (r != null) {
            if (c === null) c = Date.now(); else if (Date.now() - c >= r) return l = s.apply(this, f), c = Date.now(), u.cancel(), u.schedule(), l
        }
        return u.apply(this, f), l
    }, h = () => (u.flush(), l);
    return d.cancel = u.cancel, d.flush = h, d
}

function Ni(s, e = 0, t = {}) {
    typeof t != "object" && (t = {});
    const {leading: i = !0, trailing: n = !0, signal: o} = t;
    return it(s, e, {leading: i, trailing: n, signal: o, maxWait: e})
}

function Zs(s) {
    if (s == null) return "";
    if (Array.isArray(s)) return s.map(Zs).join(",");
    const e = String(s);
    return e === "0" && Object.is(Number(s), -0) ? "-0" : e
}

function jg(s) {
    return typeof Buffer < "u" && Buffer.isBuffer(s)
}

function Gg(s) {
    const e = s?.constructor, t = typeof e == "function" ? e.prototype : Object.prototype;
    return s === t
}

function zd(s) {
    return Ur(s)
}

function Kg(s, e) {
    if (s = Wg(s), s < 1 || !Number.isSafeInteger(s)) return [];
    const t = new Array(s);
    for (let i = 0; i < s; i++) t[i] = typeof e == "function" ? e(i) : i;
    return t
}

function Zg(s) {
    if (s == null) return [];
    switch (typeof s) {
        case"object":
        case"function":
            return Fg(s) ? Qg(s) : Gg(s) ? Jg(s) : Vs(s);
        default:
            return Vs(Object(s))
    }
}

function Vs(s) {
    const e = [];
    for (const t in s) e.push(t);
    return e
}

function Jg(s) {
    return Vs(s).filter(t => t !== "constructor")
}

function Qg(s) {
    const e = Kg(s.length, i => `${i}`), t = new Set(e);
    return jg(s) && (t.add("offset"), t.add("parent")), zd(s) && (t.add("buffer"), t.add("byteLength"), t.add("byteOffset")), [...e, ...Vs(s).filter(i => !t.has(i))]
}

function Hd(s, ...e) {
    for (let t = 0; t < e.length; t++) Yg(s, e[t]);
    return s
}

function Yg(s, e) {
    const t = Zg(e);
    for (let i = 0; i < t.length; i++) {
        const n = t[i];
        Bd(s[n], e[n]) || (s[n] = e[n])
    }
}

function za(s, e) {
    const t = {}, i = Object.keys(s);
    for (let n = 0; n < i.length; n++) {
        const o = i[n], r = s[o];
        t[o] = e(r, o, s)
    }
    return t
}

function Xg(s, e) {
    switch (e = e ?? Ti, typeof e) {
        case"string":
        case"symbol":
        case"number":
        case"object":
            return za(s, Dg(e));
        case"function":
            return za(s, e)
    }
}

function Xe(s) {
    if (typeof s != "object" || s == null) return !1;
    if (Object.getPrototypeOf(s) === null) return !0;
    if (Object.prototype.toString.call(s) !== "[object Object]") {
        const t = s[Symbol.toStringTag];
        return t == null || !Object.getOwnPropertyDescriptor(s, Symbol.toStringTag)?.writable ? !1 : s.toString() === `[object ${t}]`
    }
    let e = s;
    for (; Object.getPrototypeOf(e) !== null;) e = Object.getPrototypeOf(e);
    return Object.getPrototypeOf(s) === e
}

function Ud(s, ...e) {
    const t = e.slice(0, -1), i = e[e.length - 1];
    let n = s;
    for (let o = 0; o < t.length; o++) {
        const r = t[o];
        n = bs(n, r, i, new Map)
    }
    return n
}

function bs(s, e, t, i) {
    if (Hr(s) && (s = Object(s)), e == null || typeof e != "object") return s;
    if (i.has(e)) return $r(i.get(e));
    if (i.set(e, s), Array.isArray(e)) {
        e = e.slice();
        for (let o = 0; o < e.length; o++) e[o] = e[o] ?? void 0
    }
    const n = [...Object.keys(e), ...xs(e)];
    for (let o = 0; o < n.length; o++) {
        const r = n[o];
        let a = e[r], l = s[r];
        if (Da(a) && (a = {...a}), Da(l) && (l = {...l}), typeof Buffer < "u" && Buffer.isBuffer(a) && (a = Ve(a)), Array.isArray(a)) if (typeof l == "object" && l != null) {
            const u = [], d = Reflect.ownKeys(l);
            for (let h = 0; h < d.length; h++) {
                const f = d[h];
                u[f] = l[f]
            }
            l = u
        } else l = [];
        const c = t(l, a, r, s, e, i);
        c != null ? s[r] = c : Array.isArray(a) || nr(l) && nr(a) ? s[r] = bs(l, a, t, i) : l == null && Xe(a) ? s[r] = bs({}, a, t, i) : l == null && zd(a) ? s[r] = Ve(a) : (l === void 0 || a !== void 0) && (s[r] = a)
    }
    return s
}

function Kr(s, ...e) {
    return Ud(s, ...e, As)
}

function ep(s, e) {
    if (s == null) return !0;
    switch (typeof e) {
        case"symbol":
        case"number":
        case"object": {
            if (Array.isArray(e)) return Ha(s, e);
            if (typeof e == "number" ? e = Dd(e) : typeof e == "object" && (Object.is(e?.valueOf(), -0) ? e = "-0" : e = String(e)), s?.[e] === void 0) return !0;
            try {
                return delete s[e], !0
            } catch {
                return !1
            }
        }
        case"string": {
            if (s?.[e] === void 0 && Ld(e)) return Ha(s, Gr(e));
            try {
                return delete s[e], !0
            } catch {
                return !1
            }
        }
    }
}

function Ha(s, e) {
    const t = Nt(s, e.slice(0, -1), s), i = e[e.length - 1];
    if (t?.[i] === void 0) return !0;
    try {
        return delete t[i], !0
    } catch {
        return !1
    }
}

function At(s) {
    return nr(s) && s.nodeType === 1 && !Xe(s)
}

function Ua(s, e) {
    if (!Number.isInteger(s) || s < 0) throw new Error("n must be a non-negative integer.");
    let t = 0;
    return (...i) => {
        if (++t >= s) return e(...i)
    }
}

function sr(s, e, t = As) {
    return typeof t != "function" && (t = As), Fd(s, e, (...i) => {
        const n = t(...i);
        if (n !== void 0) return !!n;
        if (s instanceof Map && e instanceof Map || s instanceof Set && e instanceof Set) return sr(Array.from(s), Array.from(e), Ua(2, t))
    })
}

function tp(s) {
    return typeof s != "string" && (s = Zs(s)), s.replace(/['\u2019]/g, "")
}

function ip(s) {
    return s.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
}

function $d(s) {
    return ip(Zs(s))
}

function np(s) {
    const e = Bg(tp(s).trim());
    let t = "";
    for (let i = 0; i < e.length; i++) {
        const n = e[i];
        t && (t += " "), n === n.toUpperCase() ? t += n : t += n[0].toUpperCase() + n.slice(1).toLowerCase()
    }
    return t
}

function sp(s) {
    return s.substring(0, 1).toUpperCase() + s.substring(1)
}

function op(s) {
    return sp(Zs(s))
}/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */let or;
try {
    or = {window, document}
} catch {/* istanbul ignore next -- @preserve */
    or = {window: {}, document: {}}
}
var C = or;

function rp() {
    try {
        return navigator.userAgent.toLowerCase()
    } catch {
        return ""
    }
}

const jt = rp(), x = {
    isMac: Wd(jt),
    isWindows: ap(jt),
    isGecko: lp(jt),
    isSafari: cp(jt),
    isiOS: up(jt),
    isAndroid: dp(jt),
    isBlink: hp(jt),
    get isMediaForcedColors() {
        return mp()
    },
    features: {isRegExpUnicodePropertySupported: fp()}
};

function Wd(s) {
    return s.indexOf("macintosh") > -1
}

function ap(s) {
    return s.indexOf("windows") > -1
}

function lp(s) {
    return !!s.match(/gecko\/\d+/)
}

function cp(s) {
    return s.indexOf(" applewebkit/") > -1 && s.indexOf("chrome") === -1
}

function up(s) {
    return !!s.match(/iphone|ipad/i) || Wd(s) && navigator.maxTouchPoints > 0
}

function dp(s) {
    return s.indexOf("android") > -1
}

function hp(s) {
    return s.indexOf("chrome/") > -1 && s.indexOf("edge/") < 0
}

function fp() {
    let s = !1;
    try {
        s = "ć".search(new RegExp("[\\p{L}]", "u")) === 0
    } catch {
    }
    return s
}

function mp() {
    return C.window.matchMedia ? C.window.matchMedia("(forced-colors: active)").matches : !1
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function qd(s, e, t, i) {
    t = t || function (l, c) {
        return l === c
    };
    const n = Array.isArray(s) ? s : Array.prototype.slice.call(s),
        o = Array.isArray(e) ? e : Array.prototype.slice.call(e), r = gp(n, o, t);
    return i ? wp(r, o.length) : pp(o, r)
}

function gp(s, e, t) {
    const i = $a(s, e, t);
    if (i === -1) return {firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1};
    const n = Wa(s, i), o = Wa(e, i), r = $a(n, o, t), a = s.length - r, l = e.length - r;
    return {firstIndex: i, lastIndexOld: a, lastIndexNew: l}
}

function $a(s, e, t) {
    for (let i = 0; i < Math.max(s.length, e.length); i++) if (s[i] === void 0 || e[i] === void 0 || !t(s[i], e[i])) return i;
    return -1
}

function Wa(s, e) {
    return s.slice(e).reverse()
}

function pp(s, e) {
    const t = [], {firstIndex: i, lastIndexOld: n, lastIndexNew: o} = e;
    return o - i > 0 && t.push({
        index: i,
        type: "insert",
        values: s.slice(i, o)
    }), n - i > 0 && t.push({index: i + (o - i), type: "delete", howMany: n - i}), t
}

function wp(s, e) {
    const {firstIndex: t, lastIndexOld: i, lastIndexNew: n} = s;
    if (t === -1) return Array(e).fill("equal");
    let o = [];
    return t > 0 && (o = o.concat(Array(t).fill("equal"))), n - t > 0 && (o = o.concat(Array(n - t).fill("insert"))), i - t > 0 && (o = o.concat(Array(i - t).fill("delete"))), n < e && (o = o.concat(Array(e - n).fill("equal"))), o
}

function Bi(s, e, t) {
    t = t || function (g, _) {
        return g === _
    };
    const i = s.length, n = e.length;
    if (i > 200 || n > 200 || i + n > 300) return Bi.fastDiff(s, e, t, !0);
    let o, r;
    if (n < i) {
        const g = s;
        s = e, e = g, o = "delete", r = "insert"
    } else o = "insert", r = "delete";
    const a = s.length, l = e.length, c = l - a, u = {}, d = {};

    function h(g) {
        const _ = (d[g - 1] !== void 0 ? d[g - 1] : -1) + 1, v = d[g + 1] !== void 0 ? d[g + 1] : -1,
            E = _ > v ? -1 : 1;
        u[g + E] && (u[g] = u[g + E].slice(0)), u[g] || (u[g] = []), u[g].push(_ > v ? o : r);
        let V = Math.max(_, v), N = V - g;
        for (; N < a && V < l && t(s[N], e[V]);) N++, V++, u[g].push("equal");
        return V
    }

    let f = 0, m;
    do {
        for (m = -f; m < c; m++) d[m] = h(m);
        for (m = c + f; m > c; m--) d[m] = h(m);
        d[c] = h(c), f++
    } while (d[c] !== l);
    return u[c].slice(1)
}

Bi.fastDiff = qd;

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function qa() {
    return function s() {
        s.called = !0
    }
}

class xt {
    source;
    name;
    path;
    stop;
    off;
    return;

    constructor(e, t) {
        this.source = e, this.name = t, this.path = [], this.stop = qa(), this.off = qa()
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const be = new Array(256).fill("").map((s, e) => ("0" + e.toString(16)).slice(-2));

function pe() {
    const [s, e, t, i] = crypto.getRandomValues(new Uint32Array(4));
    return "e" + be[s >> 0 & 255] + be[s >> 8 & 255] + be[s >> 16 & 255] + be[s >> 24 & 255] + be[e >> 0 & 255] + be[e >> 8 & 255] + be[e >> 16 & 255] + be[e >> 24 & 255] + be[t >> 0 & 255] + be[t >> 8 & 255] + be[t >> 16 & 255] + be[t >> 24 & 255] + be[i >> 0 & 255] + be[i >> 8 & 255] + be[i >> 16 & 255] + be[i >> 24 & 255]
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const Le = {
    get(s = "normal") {
        return typeof s != "number" ? this[s] || this.normal : s
    }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5
};

function jd(s, e) {
    const t = Le.get(e.priority);
    let i = 0, n = s.length;
    for (; i < n;) {
        const o = i + n >> 1;
        Le.get(s[o].priority) < t ? n = o : i = o + 1
    }
    s.splice(i, 0, e)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const bp = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";

class p extends Error {
    context;
    data;

    constructor(e, t, i) {
        super(vp(e, i)), this.name = "CKEditorError", this.context = t, this.data = i
    }

    is(e) {
        return e === "CKEditorError"
    }

    static rethrowUnexpectedError(e, t) {
        if (e.is && e.is("CKEditorError")) throw e;
        const i = new p(e.message, t);
        throw i.stack = e.stack, i
    }
}

function L(s, e) {
    console.warn(...Kd(s, e))
}

function _p(s, e) {
    console.error(...Kd(s, e))
}

function Gd(s) {
    return `
Read more: ${bp}#error-${s}`
}

function vp(s, e) {
    const t = new WeakSet, n = e ? ` ${JSON.stringify(e, (r, a) => {
        if (typeof a == "object" && a !== null) {
            if (t.has(a)) return `[object ${a.constructor.name}]`;
            t.add(a)
        }
        return a
    })}` : "", o = Gd(s);
    return s + n + o
}

function Kd(s, e) {
    const t = Gd(s);
    return e ? [s, e, t] : [s, t]
}

const yp = "45.2.1", kp = new Date(2025, 5, 24);/* istanbul ignore next -- @preserve */
if (globalThis.CKEDITOR_VERSION) throw new p("ckeditor-duplicated-modules", null);
globalThis.CKEDITOR_VERSION = yp;
const Ai = Symbol("listeningTo"), rr = Symbol("emitterId"), wt = Symbol("delegations"), Zd = W(Object);

function W(s) {
    if (!s) return Zd;

    class e extends s {
        on(i, n, o) {
            this.listenTo(this, i, n, o)
        }

        once(i, n, o) {
            let r = !1;
            const a = (l, ...c) => {
                r || (r = !0, l.off(), n.call(this, l, ...c))
            };
            this.listenTo(this, i, a, o)
        }

        off(i, n) {
            this.stopListening(this, i, n)
        }

        listenTo(i, n, o, r = {}) {
            let a, l;
            this[Ai] || (this[Ai] = {});
            const c = this[Ai];
            mo(i) || Jd(i);
            const u = mo(i);
            (a = c[u]) || (a = c[u] = {
                emitter: i,
                callbacks: {}
            }), (l = a.callbacks[n]) || (l = a.callbacks[n] = []), l.push(o), xp(this, i, n, o, r)
        }

        stopListening(i, n, o) {
            const r = this[Ai];
            let a = i && mo(i);
            const l = r && a ? r[a] : void 0, c = l && n ? l.callbacks[n] : void 0;
            if (!(!r || i && !l || n && !c)) if (o) go(this, i, n, o), c.indexOf(o) !== -1 && (c.length === 1 ? delete l.callbacks[n] : go(this, i, n, o)); else if (c) {
                for (; o = c.pop();) go(this, i, n, o);
                delete l.callbacks[n]
            } else if (l) {
                for (n in l.callbacks) this.stopListening(i, n);
                delete r[a]
            } else {
                for (a in r) this.stopListening(r[a].emitter);
                delete this[Ai]
            }
        }

        fire(i, ...n) {
            try {
                const o = i instanceof xt ? i : new xt(this, i), r = o.name;
                let a = Ap(this, r);
                if (o.path.push(this), a) {
                    a = a.slice();
                    for (let c = 0; c < a.length; c++) {
                        const u = a[c].callback;
                        if (u.call(this, o, ...n), o.off.called && (delete o.off.called, this._removeEventListener(r, u)), o.stop.called) break
                    }
                }
                const l = this[wt];
                if (l) {
                    const c = l.get(r), u = l.get("*");
                    c && ja(c, o, n), u && ja(u, o, n)
                }
                return o.return
            } catch (o) {/* istanbul ignore next -- @preserve */
                p.rethrowUnexpectedError(o, this)
            }
        }

        delegate(...i) {
            return {
                to: (n, o) => {
                    this[wt] || (this[wt] = new Map), i.forEach(r => {
                        const a = this[wt].get(r);
                        a ? a.set(n, o) : this[wt].set(r, new Map([[n, o]]))
                    })
                }
            }
        }

        stopDelegating(i, n) {
            if (this[wt]) if (!i) this[wt].clear(); else if (!n) this[wt].delete(i); else {
                const o = this[wt].get(i);
                o && o.delete(n)
            }
        }

        _addEventListener(i, n, o) {
            Tp(this, i);
            const r = ar(this, i), a = Le.get(o.priority), l = {callback: n, priority: a};
            for (const c of r) jd(c, l)
        }

        _removeEventListener(i, n) {
            const o = ar(this, i);
            for (const r of o) for (let a = 0; a < r.length; a++) r[a].callback == n && (r.splice(a, 1), a--)
        }
    }

    return e
}

["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach(s => {
    W[s] = Zd.prototype[s]
});

function Cp(s, e) {
    const t = s[Ai];
    return t && t[e] ? t[e].emitter : null
}

function Jd(s, e) {
    s[rr] || (s[rr] = e || pe())
}

function mo(s) {
    return s[rr]
}

function Qd(s) {
    return s._events || Object.defineProperty(s, "_events", {value: {}}), s._events
}

function Ep() {
    return {callbacks: [], childEvents: []}
}

function Tp(s, e) {
    const t = Qd(s);
    if (t[e]) return;
    let i = e, n = null;
    const o = [];
    for (; i !== "" && !t[i];) t[i] = Ep(), o.push(t[i]), n && t[i].childEvents.push(n), n = i, i = i.substr(0, i.lastIndexOf(":"));
    if (i !== "") {
        for (const r of o) r.callbacks = t[i].callbacks.slice();
        t[i].childEvents.push(n)
    }
}

function ar(s, e) {
    const t = Qd(s)[e];
    if (!t) return [];
    let i = [t.callbacks];
    for (let n = 0; n < t.childEvents.length; n++) {
        const o = ar(s, t.childEvents[n]);
        i = i.concat(o)
    }
    return i
}

function Ap(s, e) {
    if (!s._events) return null;
    let t = e;
    do {
        const i = s._events[t];
        if (i && i.callbacks && i.callbacks.length) return i.callbacks;
        const n = t.lastIndexOf(":");
        t = n > -1 ? t.substring(0, n) : ""
    } while (t);
    return null
}

function ja(s, e, t) {
    for (let [i, n] of s) {
        n ? typeof n == "function" && (n = n(e.name)) : n = e.name;
        const o = new xt(e.source, n);
        o.path = [...e.path], i.fire(o, ...t)
    }
}

function xp(s, e, t, i, n) {
    e._addEventListener ? e._addEventListener(t, i, n) : s._addEventListener.call(e, t, i, n)
}

function go(s, e, t, i) {
    e._removeEventListener ? e._removeEventListener(t, i) : s._removeEventListener.call(e, t, i)
}

const bn = Symbol("observableProperties"), Tn = Symbol("boundObservables"), _n = Symbol("boundProperties"),
    Gt = Symbol("decoratedMethods"), Ga = Symbol("decoratedOriginal"), Yd = H(W());

function H(s) {
    if (!s) return Yd;

    class e extends s {
        set(i, n) {
            if (tt(i)) {
                Object.keys(i).forEach(r => {
                    this.set(r, i[r])
                }, this);
                return
            }
            po(this);
            const o = this[bn];
            if (i in this && !o.has(i)) throw new p("observable-set-cannot-override", this);
            Object.defineProperty(this, i, {
                enumerable: !0, configurable: !0, get() {
                    return o.get(i)
                }, set(r) {
                    const a = o.get(i);
                    let l = this.fire(`set:${i}`, i, r, a);
                    l === void 0 && (l = r), (a !== l || !o.has(i)) && (o.set(i, l), this.fire(`change:${i}`, i, l, a))
                }
            }), this[i] = n
        }

        bind(...i) {
            if (!i.length || !Ka(i)) throw new p("observable-bind-wrong-properties", this);
            if (new Set(i).size !== i.length) throw new p("observable-bind-duplicate-properties", this);
            po(this);
            const n = this[_n];
            i.forEach(r => {
                if (n.has(r)) throw new p("observable-bind-rebind", this)
            });
            const o = new Map;
            return i.forEach(r => {
                const a = {property: r, to: []};
                n.set(r, a), o.set(r, a)
            }), {to: Ip, toMany: Sp, _observable: this, _bindProperties: i, _to: [], _bindings: o}
        }

        unbind(...i) {
            if (!this[bn]) return;
            const n = this[_n], o = this[Tn];
            if (i.length) {
                if (!Ka(i)) throw new p("observable-unbind-wrong-properties", this);
                i.forEach(r => {
                    const a = n.get(r);
                    a && (a.to.forEach(([l, c]) => {
                        const u = o.get(l), d = u[c];
                        d.delete(a), d.size || delete u[c], Object.keys(u).length || (o.delete(l), this.stopListening(l, "change"))
                    }), n.delete(r))
                })
            } else o.forEach((r, a) => {
                this.stopListening(a, "change")
            }), o.clear(), n.clear()
        }

        decorate(i) {
            po(this);
            const n = this[i];
            if (!n) throw new p("observablemixin-cannot-decorate-undefined", this, {object: this, methodName: i});
            this.on(i, (o, r) => {
                o.return = n.apply(this, r)
            }), this[i] = function (...o) {
                return this.fire(i, o)
            }, this[i][Ga] = n, this[Gt] || (this[Gt] = []), this[Gt].push(i)
        }

        stopListening(i, n, o) {
            if (!i && this[Gt]) {
                for (const r of this[Gt]) this[r] = this[r][Ga];
                delete this[Gt]
            }
            super.stopListening(i, n, o)
        }

        [bn];
        [Gt];
        [_n];
        [Tn]
    }

    return e
}

["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach(s => {
    H[s] = Yd.prototype[s]
});

function po(s) {
    s[bn] || (Object.defineProperty(s, bn, {value: new Map}), Object.defineProperty(s, Tn, {value: new Map}), Object.defineProperty(s, _n, {value: new Map}))
}

function Ip(...s) {
    const e = Rp(...s), t = Array.from(this._bindings.keys()), i = t.length;
    if (!e.callback && e.to.length > 1) throw new p("observable-bind-to-no-callback", this);
    if (i > 1 && e.callback) throw new p("observable-bind-to-extra-callback", this);
    e.to.forEach(n => {
        if (n.properties.length && n.properties.length !== i) throw new p("observable-bind-to-properties-length", this);
        n.properties.length || (n.properties = this._bindProperties)
    }), this._to = e.to, e.callback && (this._bindings.get(t[0]).callback = e.callback), Mp(this._observable, this._to), Op(this), this._bindProperties.forEach(n => {
        Xd(this._observable, n)
    })
}

function Sp(s, e, t) {
    if (this._bindings.size > 1) throw new p("observable-bind-to-many-not-one-binding", this);
    this.to(...Pp(s, e), t)
}

function Pp(s, e) {
    const t = s.map(i => [i, e]);
    return Array.prototype.concat.apply([], t)
}

function Ka(s) {
    return s.every(e => typeof e == "string")
}

function Rp(...s) {
    if (!s.length) throw new p("observable-bind-to-parse-error", null);
    const e = {to: []};
    let t;
    return typeof s[s.length - 1] == "function" && (e.callback = s.pop()), s.forEach(i => {
        if (typeof i == "string") t.properties.push(i); else if (typeof i == "object") t = {
            observable: i,
            properties: []
        }, e.to.push(t); else throw new p("observable-bind-to-parse-error", null)
    }), e
}

function Vp(s, e, t, i) {
    const n = s[Tn], o = n.get(t), r = o || {};
    r[i] || (r[i] = new Set), r[i].add(e), o || n.set(t, r)
}

function Op(s) {
    let e;
    s._bindings.forEach((t, i) => {
        s._to.forEach(n => {
            e = n.properties[t.callback ? 0 : s._bindProperties.indexOf(i)], t.to.push([n.observable, e]), Vp(s._observable, t, n.observable, e)
        })
    })
}

function Xd(s, e) {
    const i = s[_n].get(e);
    let n;
    i.callback ? n = i.callback.apply(s, i.to.map(o => o[0][o[1]])) : (n = i.to[0], n = n[0][n[1]]), Object.prototype.hasOwnProperty.call(s, e) ? s[e] = n : s.set(e, n)
}

function Mp(s, e) {
    e.forEach(t => {
        const i = s[Tn];
        let n;
        i.get(t.observable) || s.listenTo(t.observable, "change", (o, r) => {
            n = i.get(t.observable)[r], n && n.forEach(a => {
                Xd(s, a.property)
            })
        })
    })
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class eh {
    _replacedElements;

    constructor() {
        this._replacedElements = []
    }

    replace(e, t) {
        this._replacedElements.push({
            element: e,
            newElement: t
        }), e.style.display = "none", t && e.parentNode.insertBefore(t, e.nextSibling)
    }

    restore() {
        this._replacedElements.forEach(({element: e, newElement: t}) => {
            e.style.display = "", t && t.remove()
        }), this._replacedElements = []
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function lr(s) {
    let e = 0;
    for (const t of s) e++;
    return e
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function _e(s, e) {
    const t = Math.min(s.length, e.length);
    for (let i = 0; i < t; i++) if (s[i] != e[i]) return i;
    return s.length == e.length ? "same" : s.length < e.length ? "prefix" : "extension"
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function ze(s) {
    return !!(s && s[Symbol.iterator])
}

function Oe(s, e, t = {}, i = []) {
    const n = t && t.xmlns, o = n ? s.createElementNS(n, e) : s.createElement(e);
    for (const r in t) o.setAttribute(r, t[r]);
    (Na(i) || !ze(i)) && (i = [i]);
    for (let r of i) Na(r) && (r = s.createTextNode(r)), o.appendChild(r);
    return o
}

class th {
    _config;

    constructor(e, t) {
        this._config = Object.create(null), t && this.define(Za(t)), e && this._setObjectToTarget(this._config, e)
    }

    set(e, t) {
        this._setToTarget(this._config, e, t)
    }

    define(e, t) {
        this._setToTarget(this._config, e, t, !0)
    }

    get(e) {
        return this._getFromSource(this._config, e)
    }

    * names() {
        for (const e of Object.keys(this._config)) yield e
    }

    _setToTarget(e, t, i, n = !1) {
        if (Xe(t)) {
            this._setObjectToTarget(e, t, n);
            return
        }
        const o = t.split(".");
        t = o.pop();
        for (const r of o) Xe(e[r]) || (e[r] = Object.create(null)), e = e[r];
        if (Xe(i)) {
            Xe(e[t]) || (e[t] = Object.create(null)), e = e[t], this._setObjectToTarget(e, i, n);
            return
        }
        n && typeof e[t] < "u" || (e[t] = i)
    }

    _getFromSource(e, t) {
        const i = t.split(".");
        t = i.pop();
        for (const n of i) {
            if (!Xe(e[n])) {
                e = null;
                break
            }
            e = e[n]
        }
        return e ? Za(e[t]) : void 0
    }

    _setObjectToTarget(e, t, i) {
        Object.keys(t).forEach(n => {
            this._setToTarget(e, n, t[n], i)
        })
    }
}

function Za(s) {
    return Ks(s, Bp)
}

function Bp(s) {
    return At(s) || typeof s == "function" ? s : void 0
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function zt(s) {
    if (s) {
        if (s.defaultView) return s instanceof s.defaultView.Document;
        if (s.ownerDocument && s.ownerDocument.defaultView) return s instanceof s.ownerDocument.defaultView.Node
    }
    return !1
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Os(s) {
    const e = Object.prototype.toString.apply(s);
    return e == "[object Window]" || e == "[object global]"
}

const ih = xe(W());

function xe(s) {
    if (!s) return ih;

    class e extends s {
        listenTo(i, n, o, r = {}) {
            if (zt(i) || Os(i) || i instanceof C.window.EventTarget) {
                const a = {capture: !!r.useCapture, passive: !!r.usePassive},
                    l = this._getProxyEmitter(i, a) || new Fp(i, a);
                this.listenTo(l, n, o, r)
            } else super.listenTo(i, n, o, r)
        }

        stopListening(i, n, o) {
            if (zt(i) || Os(i) || i instanceof C.window.EventTarget) {
                const r = this._getAllProxyEmitters(i);
                for (const a of r) this.stopListening(a, n, o)
            } else super.stopListening(i, n, o)
        }

        _getProxyEmitter(i, n) {
            return Cp(this, nh(i, n))
        }

        _getAllProxyEmitters(i) {
            return [{capture: !1, passive: !1}, {capture: !1, passive: !0}, {capture: !0, passive: !1}, {
                capture: !0,
                passive: !0
            }].map(n => this._getProxyEmitter(i, n)).filter(n => !!n)
        }
    }

    return e
}

["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach(s => {
    xe[s] = ih.prototype[s]
});

class Fp extends W() {
    _domNode;
    _options;

    constructor(e, t) {
        super(), Jd(this, nh(e, t)), this._domNode = e, this._options = t
    }

    _domListeners;

    attach(e) {
        if (this._domListeners && this._domListeners[e]) return;
        const t = this._createDomListener(e);
        this._domNode.addEventListener(e, t, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[e] = t
    }

    detach(e) {
        let t;
        this._domListeners[e] && (!(t = this._events[e]) || !t.callbacks.length) && this._domListeners[e].removeListener()
    }

    _addEventListener(e, t, i) {
        this.attach(e), W().prototype._addEventListener.call(this, e, t, i)
    }

    _removeEventListener(e, t) {
        W().prototype._removeEventListener.call(this, e, t), this.detach(e)
    }

    _createDomListener(e) {
        const t = i => {
            this.fire(e, i)
        };
        return t.removeListener = () => {
            this._domNode.removeEventListener(e, t, this._options), delete this._domListeners[e]
        }, t
    }
}

function Lp(s) {
    return s["data-ck-expando"] || (s["data-ck-expando"] = pe())
}

function nh(s, e) {
    let t = Lp(s);
    for (const i of Object.keys(e).sort()) e[i] && (t += "-" + i);
    return t
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Dp(s) {
    const e = [];
    let t = s;
    for (; t && t.nodeType != Node.DOCUMENT_NODE;) e.unshift(t), t = t.parentNode;
    return e
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Np(s) {
    return s instanceof HTMLTextAreaElement ? s.value : s.innerHTML
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function sh(s) {
    const e = s.ownerDocument.defaultView.getComputedStyle(s);
    return {
        top: parseInt(e.borderTopWidth, 10),
        right: parseInt(e.borderRightWidth, 10),
        bottom: parseInt(e.borderBottomWidth, 10),
        left: parseInt(e.borderLeftWidth, 10)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function oh(s) {
    if (!s.target) return null;
    const e = s.target.ownerDocument, t = s.clientX, i = s.clientY;
    let n = null;
    return e.caretRangeFromPoint && e.caretRangeFromPoint(t, i) ? n = e.caretRangeFromPoint(t, i) : s.rangeParent && (n = e.createRange(), n.setStart(s.rangeParent, s.rangeOffset), n.collapse(!0)), n
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function X(s) {
    return Object.prototype.toString.call(s) == "[object Text]"
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Js(s) {
    return Object.prototype.toString.apply(s) == "[object Range]"
}

function rh(s) {
    return !s || !s.parentNode || s.offsetParent === C.document.body ? null : s.offsetParent
}

const ah = ["top", "right", "bottom", "left", "width", "height"];

class R {
    top;
    right;
    bottom;
    left;
    width;
    height;
    _source;

    constructor(e) {
        const t = Js(e);
        if (Object.defineProperty(this, "_source", {
            value: e._source || e,
            writable: !0,
            enumerable: !1
        }), cr(e) || t) if (t) {
            const i = R.getDomRangeRects(e);
            Qn(this, R.getBoundingRect(i))
        } else Qn(this, e.getBoundingClientRect()); else if (Os(e)) {
            const {innerWidth: i, innerHeight: n} = e;
            Qn(this, {top: 0, right: i, bottom: n, left: 0, width: i, height: n})
        } else Qn(this, e)
    }

    clone() {
        return new R(this)
    }

    moveTo(e, t) {
        return this.top = t, this.right = e + this.width, this.bottom = t + this.height, this.left = e, this
    }

    moveBy(e, t) {
        return this.top += t, this.right += e, this.left += e, this.bottom += t, this
    }

    getIntersection(e) {
        const t = {
            top: Math.max(this.top, e.top),
            right: Math.min(this.right, e.right),
            bottom: Math.min(this.bottom, e.bottom),
            left: Math.max(this.left, e.left),
            width: 0,
            height: 0
        };
        if (t.width = t.right - t.left, t.height = t.bottom - t.top, t.width < 0 || t.height < 0) return null;
        {
            const i = new R(t);
            return i._source = this._source, i
        }
    }

    getIntersectionArea(e) {
        const t = this.getIntersection(e);
        return t ? t.getArea() : 0
    }

    getArea() {
        return this.width * this.height
    }

    getVisible() {
        const e = this._source;
        let t = this.clone();
        if (Ja(e)) return t;
        let i = e, n = e.parentNode || e.commonAncestorContainer, o;
        for (; n && !Ja(n);) {
            const r = zp(n) === "visible";
            i instanceof HTMLElement && Qa(i) === "absolute" && (o = i);
            const a = Qa(n);
            if (r || o && (a === "relative" && r || a !== "relative")) {
                i = n, n = n.parentNode;
                continue
            }
            const l = new R(n), c = t.getIntersection(l);
            if (c) c.getArea() < t.getArea() && (t = c); else return null;
            i = n, n = n.parentNode
        }
        return t
    }

    isEqual(e) {
        for (const t of ah) if (this[t] !== e[t]) return !1;
        return !0
    }

    contains(e) {
        const t = this.getIntersection(e);
        return !!(t && t.isEqual(e))
    }

    toAbsoluteRect() {
        const {scrollX: e, scrollY: t} = C.window, i = this.clone().moveBy(e, t);
        if (cr(i._source)) {
            const n = rh(i._source);
            n && Hp(i, n)
        }
        return i
    }

    excludeScrollbarsAndBorders() {
        const e = this._source;
        let t, i, n;
        if (Os(e)) t = e.innerWidth - e.document.documentElement.clientWidth, i = e.innerHeight - e.document.documentElement.clientHeight, n = e.getComputedStyle(e.document.documentElement).direction; else {
            const o = sh(e);
            t = e.offsetWidth - e.clientWidth - o.left - o.right, i = e.offsetHeight - e.clientHeight - o.top - o.bottom, n = e.ownerDocument.defaultView.getComputedStyle(e).direction, this.left += o.left, this.top += o.top, this.right -= o.right, this.bottom -= o.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top
        }
        return this.width -= t, n === "ltr" ? this.right -= t : this.left += t, this.height -= i, this.bottom -= i, this
    }

    static getDomRangeRects(e) {
        const t = [], i = Array.from(e.getClientRects());
        if (i.length) for (const n of i) t.push(new R(n)); else {
            let n = e.startContainer;
            X(n) && (n = n.parentNode);
            const o = new R(n.getBoundingClientRect());
            o.right = o.left, o.width = 0, t.push(o)
        }
        return t
    }

    static getBoundingRect(e) {
        const t = {
            left: Number.POSITIVE_INFINITY,
            top: Number.POSITIVE_INFINITY,
            right: Number.NEGATIVE_INFINITY,
            bottom: Number.NEGATIVE_INFINITY,
            width: 0,
            height: 0
        };
        let i = 0;
        for (const n of e) i++, t.left = Math.min(t.left, n.left), t.top = Math.min(t.top, n.top), t.right = Math.max(t.right, n.right), t.bottom = Math.max(t.bottom, n.bottom);
        return i == 0 ? null : (t.width = t.right - t.left, t.height = t.bottom - t.top, new R(t))
    }
}

function Qn(s, e) {
    for (const t of ah) s[t] = e[t]
}

function Ja(s) {
    return cr(s) ? s === s.ownerDocument.body : !1
}

function cr(s) {
    return s !== null && typeof s == "object" && s.nodeType === 1 && typeof s.getBoundingClientRect == "function"
}

function Qa(s) {
    return s instanceof HTMLElement ? s.ownerDocument.defaultView.getComputedStyle(s).position : "static"
}

function zp(s) {
    return s instanceof HTMLElement ? s.ownerDocument.defaultView.getComputedStyle(s).overflow : "visible"
}

function Hp(s, e) {
    const t = new R(e), i = sh(e);
    let n = 0, o = 0;
    n -= t.left, o -= t.top, n += e.scrollLeft, o += e.scrollTop, n -= i.left, o -= i.top, s.moveBy(n, o)
}

class Q {
    _element;
    _callback;
    static _observerInstance = null;
    static _elementCallbacks = null;

    constructor(e, t) {
        Q._observerInstance || Q._createObserver(), this._element = e, this._callback = t, Q._addElementCallback(e, t), Q._observerInstance.observe(e)
    }

    get element() {
        return this._element
    }

    destroy() {
        Q._deleteElementCallback(this._element, this._callback)
    }

    static _addElementCallback(e, t) {
        Q._elementCallbacks || (Q._elementCallbacks = new Map);
        let i = Q._elementCallbacks.get(e);
        i || (i = new Set, Q._elementCallbacks.set(e, i)), i.add(t)
    }

    static _deleteElementCallback(e, t) {
        const i = Q._getElementCallbacks(e);
        i && (i.delete(t), i.size || (Q._elementCallbacks.delete(e), Q._observerInstance.unobserve(e))), Q._elementCallbacks && !Q._elementCallbacks.size && (Q._observerInstance = null, Q._elementCallbacks = null)
    }

    static _getElementCallbacks(e) {
        return Q._elementCallbacks ? Q._elementCallbacks.get(e) : null
    }

    static _createObserver() {
        Q._observerInstance = new C.window.ResizeObserver(e => {
            for (const t of e) {
                const i = Q._getElementCallbacks(t.target);
                if (i) for (const n of i) n(t)
            }
        })
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Ya(s, e) {
    s instanceof HTMLTextAreaElement && (s.value = e), s.innerHTML = e
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Hn(s) {
    return e => e + s
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Vi(s) {
    let e = 0;
    for (; s.previousSibling;) s = s.previousSibling, e++;
    return e
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function lh(s, e, t) {
    s.insertBefore(t, s.childNodes[e] || null)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function vn(s) {
    return s && s.nodeType === Node.COMMENT_NODE
}

function ch(s) {
    try {
        C.document.createAttribute(s)
    } catch {
        return !1
    }
    return !0
}

function ft(s) {
    return s ? X(s) ? ft(s.parentElement) : s.getClientRects ? !!s.getClientRects().length : !1 : !1
}

function Zr({element: s, target: e, positions: t, limiter: i, fitInViewport: n, viewportOffsetConfig: o}) {
    Rs(e) && (e = e()), Rs(i) && (i = i());
    const r = rh(s), a = Up(o), l = new R(s), c = Xa(e, a);
    let u;
    if (!c || !a.getIntersection(c)) return null;
    const d = {targetRect: c, elementRect: l, positionedElementAncestor: r, viewportRect: a};
    if (!i && !n) u = new uh(t[0], d); else {
        if (i) {
            const h = Xa(i, a);
            h && (d.limiterRect = h)
        }
        u = $p(t, d)
    }
    return u
}

function Xa(s, e) {
    const t = new R(s).getVisible();
    return t ? t.getIntersection(e) : null
}

function Up(s) {
    s = Object.assign({top: 0, bottom: 0, left: 0, right: 0}, s);
    const e = new R(C.window);
    return e.top += s.top, e.height -= s.top, e.bottom -= s.bottom, e.height -= s.bottom, e
}

function $p(s, e) {
    const {elementRect: t} = e, i = t.getArea(), n = s.map(a => new uh(a, e)).filter(a => !!a.name);
    let o = 0, r = null;
    for (const a of n) {
        const {limiterIntersectionArea: l, viewportIntersectionArea: c} = a;
        if (l === i) return a;
        const u = c ** 2 + l ** 2;
        u > o && (o = u, r = a)
    }
    return r
}

class uh {
    name;
    config;
    _positioningFunctionCoordinates;
    _options;
    _cachedRect;
    _cachedAbsoluteRect;

    constructor(e, t) {
        const i = e(t.targetRect, t.elementRect, t.viewportRect, t.limiterRect);
        if (!i) return;
        const {left: n, top: o, name: r, config: a} = i;
        this.name = r, this.config = a, this._positioningFunctionCoordinates = {left: n, top: o}, this._options = t
    }

    get left() {
        return this._absoluteRect.left
    }

    get top() {
        return this._absoluteRect.top
    }

    get limiterIntersectionArea() {
        const e = this._options.limiterRect;
        return e ? e.getIntersectionArea(this._rect) : 0
    }

    get viewportIntersectionArea() {
        return this._options.viewportRect.getIntersectionArea(this._rect)
    }

    get _rect() {
        return this._cachedRect ? this._cachedRect : (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top), this._cachedRect)
    }

    get _absoluteRect() {
        return this._cachedAbsoluteRect ? this._cachedAbsoluteRect : (this._cachedAbsoluteRect = this._rect.toAbsoluteRect(), this._cachedAbsoluteRect)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function el(s) {
    const e = s.parentNode;
    e && e.removeChild(s)
}

function _s() {
    const s = C.window.visualViewport;
    if (!s || !(x.isiOS || x.isSafari)) return {left: 0, top: 0};
    const e = Math.max(Math.round(s.offsetLeft), 0), t = Math.max(Math.round(s.offsetTop), 0);
    return {left: e, top: t}
}

function dh({target: s, viewportOffset: e = 0, ancestorOffset: t = 0, alignToTop: i, forceScroll: n}) {
    const o = Jr(s);
    let r = o, a = null;
    for (e = jp(e); r;) {
        let l;
        r == o ? l = tl(s) : l = tl(a), qp({
            parent: l,
            getRect: () => wo(s, r),
            alignToTop: i,
            ancestorOffset: t,
            forceScroll: n
        });
        let c = wo(s, r);
        const u = wo(l, r);
        if (c.height > u.height) {
            const d = c.getIntersection(u);
            d && (c = d)
        }
        if (Wp({window: r, rect: c, viewportOffset: e, alignToTop: i, forceScroll: n}), r.parent != r) {
            if (a = r.frameElement, r = r.parent, !a) return
        } else r = null
    }
}

function Wp({window: s, rect: e, alignToTop: t, forceScroll: i, viewportOffset: n}) {
    const o = e.clone().moveBy(0, n.bottom), r = e.clone().moveBy(0, -n.top),
        a = new R(s).excludeScrollbarsAndBorders(), l = [r, o], c = t && i, u = l.every(g => a.contains(g));
    let {scrollX: d, scrollY: h} = s;
    const f = d, m = h;
    c ? h -= a.top - e.top + n.top : u || (fh(r, a) ? h -= a.top - e.top + n.top : hh(o, a) && (t ? h += e.top - a.top - n.top : h += e.bottom - a.bottom + n.bottom)), u || (mh(e, a) ? d -= a.left - e.left + n.left : gh(e, a) && (d += e.right - a.right + n.right)), (d != f || h !== m) && s.scrollTo(d, h)
}

function qp({parent: s, getRect: e, alignToTop: t, forceScroll: i, ancestorOffset: n = 0, limiterElement: o}) {
    const r = Jr(s), a = t && i;
    let l, c, u;
    const d = o || r.document.body;
    for (; s != d;) c = e(), l = new R(s).excludeScrollbarsAndBorders(), u = l.contains(c), a ? s.scrollTop -= l.top - c.top + n : u || (fh(c, l) ? s.scrollTop -= l.top - c.top + n : hh(c, l) && (t ? s.scrollTop += c.top - l.top - n : s.scrollTop += c.bottom - l.bottom + n)), u || (mh(c, l) ? s.scrollLeft -= l.left - c.left + n : gh(c, l) && (s.scrollLeft += c.right - l.right + n)), s = s.parentNode
}

function hh(s, e) {
    return s.bottom > e.bottom
}

function fh(s, e) {
    return s.top < e.top
}

function mh(s, e) {
    return s.left < e.left
}

function gh(s, e) {
    return s.right > e.right
}

function Jr(s) {
    return Js(s) ? s.startContainer.ownerDocument.defaultView : s.ownerDocument.defaultView
}

function tl(s) {
    if (Js(s)) {
        let e = s.commonAncestorContainer;
        return X(e) && (e = e.parentNode), e
    } else return s.parentNode
}

function wo(s, e) {
    const t = Jr(s), i = new R(s);
    if (t === e) return i;
    {
        let n = t;
        for (; n != e;) {
            const o = n.frameElement, r = new R(o).excludeScrollbarsAndBorders();
            i.moveBy(r.left, r.top), n = n.parent
        }
    }
    return i
}

function jp(s) {
    return typeof s == "number" ? {top: s, bottom: s, left: s, right: s} : s
}

const Gp = {ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧"}, Kp = {ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+"},
    il = {37: "←", 38: "↑", 39: "→", 40: "↓", 9: "⇥", 33: "Page Up", 34: "Page Down"}, M = Xp(),
    Zp = Object.fromEntries(Object.entries(M).map(([s, e]) => {
        let t;
        return e in il ? t = il[e] : t = s.charAt(0).toUpperCase() + s.slice(1), [e, t]
    }));

function zi(s) {
    let e;
    if (typeof s == "string") {
        if (e = M[s.toLowerCase()], !e) throw new p("keyboard-unknown-key", null, {key: s})
    } else e = s.keyCode + (s.altKey ? M.alt : 0) + (s.ctrlKey ? M.ctrl : 0) + (s.shiftKey ? M.shift : 0) + (s.metaKey ? M.cmd : 0);
    return e
}

function Qr(s) {
    return typeof s == "string" && (s = ew(s)), s.map(e => typeof e == "string" ? Qp(e) : e).reduce((e, t) => t + e, 0)
}

function Ms(s, e) {
    let t = Qr(s);
    const i = x.isMac || x.isiOS;
    return Object.entries(i ? Gp : Kp).reduce((r, [a, l]) => ((t & M[a]) != 0 && (t &= ~M[a], r += l), r), "") + (t ? Zp[t] : "")
}

function Jp(s) {
    return s == M.arrowright || s == M.arrowleft || s == M.arrowup || s == M.arrowdown
}

function Yr(s, e) {
    const t = e === "ltr";
    switch (s) {
        case M.arrowleft:
            return t ? "left" : "right";
        case M.arrowright:
            return t ? "right" : "left";
        case M.arrowup:
            return "up";
        case M.arrowdown:
            return "down"
    }
}

function Qp(s) {
    if (s.endsWith("!")) return zi(s.slice(0, -1));
    const e = zi(s);
    return (x.isMac || x.isiOS) && e == M.ctrl ? M.cmd : e
}

function Yp(s, e) {
    const t = Yr(s, e);
    return t === "down" || t === "right"
}

function Xp() {
    const s = {
        pageup: 33,
        pagedown: 34,
        end: 35,
        home: 36,
        arrowleft: 37,
        arrowup: 38,
        arrowright: 39,
        arrowdown: 40,
        backspace: 8,
        delete: 46,
        enter: 13,
        space: 32,
        esc: 27,
        tab: 9,
        ctrl: 1114112,
        shift: 2228224,
        alt: 4456448,
        cmd: 8912896
    };
    for (let e = 65; e <= 90; e++) {
        const t = String.fromCharCode(e);
        s[t.toLowerCase()] = e
    }
    for (let e = 48; e <= 57; e++) s[e - 48] = e;
    for (let e = 112; e <= 123; e++) s["f" + (e - 111)] = e;
    return Object.assign(s, {
        "'": 222,
        ",": 108,
        "-": 109,
        ".": 110,
        "/": 111,
        ";": 186,
        "=": 187,
        "[": 219,
        "\\": 220,
        "]": 221,
        "`": 223
    }), s
}

function ew(s) {
    return s.split("+").map(e => e.trim())
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const tw = ["ar", "ara", "dv", "div", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig", "ur", "urd"];

function nl(s) {
    return tw.includes(s) ? "rtl" : "ltr"
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function U(s) {
    return Array.isArray(s) ? s : [s]
}/* istanbul ignore else -- @preserve */
C.window.CKEDITOR_TRANSLATIONS || (C.window.CKEDITOR_TRANSLATIONS = {});

function iw(s, e, t = 1, i) {
    if (typeof t != "number") throw new p("translation-service-quantity-not-a-number", null, {quantity: t});
    const n = i || C.window.CKEDITOR_TRANSLATIONS, o = ow(n);
    o === 1 && (s = Object.keys(n)[0]);
    const r = e.id || e.string;
    if (o === 0 || !sw(s, r, n)) return t !== 1 ? e.plural : e.string;
    const a = n[s].dictionary, l = n[s].getPluralForm || (d => d === 1 ? 0 : 1), c = a[r];
    if (typeof c == "string") return c;
    const u = Number(l(t));
    return c[u]
}

function nw(s) {
    return Array.isArray(s) ? s.reduce((e, t) => Kr(e, t)) : s
}

function sw(s, e, t) {
    return !!t[s] && !!t[s].dictionary[e]
}

function ow(s) {
    return Object.keys(s).length
}

class rw {
    uiLanguage;
    uiLanguageDirection;
    contentLanguage;
    contentLanguageDirection;
    t;
    translations;

    constructor({uiLanguage: e = "en", contentLanguage: t, translations: i} = {}) {
        this.uiLanguage = e, this.contentLanguage = t || this.uiLanguage, this.uiLanguageDirection = nl(this.uiLanguage), this.contentLanguageDirection = nl(this.contentLanguage), this.translations = nw(i), this.t = (n, o) => this._t(n, o)
    }

    get language() {
        return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage
    }

    _t(e, t = []) {
        t = U(t), typeof e == "string" && (e = {string: e});
        const n = !!e.plural ? t[0] : 1, o = iw(this.uiLanguage, e, n, this.translations);
        return aw(o, t)
    }
}

function aw(s, e) {
    return s.replace(/%(\d+)/g, (t, i) => i < e.length ? e[i] : t)
}

class ce extends W() {
    _items;
    _itemMap;
    _idProperty;
    _bindToCollection;
    _bindToExternalToInternalMap;
    _bindToInternalToExternalMap;
    _skippedIndexesFromExternal;

    constructor(e = {}, t = {}) {
        super();
        const i = ze(e);
        if (i || (t = e), this._items = [], this._itemMap = new Map, this._idProperty = t.idProperty || "id", this._bindToExternalToInternalMap = new WeakMap, this._bindToInternalToExternalMap = new WeakMap, this._skippedIndexesFromExternal = [], i) for (const n of e) this._items.push(n), this._itemMap.set(this._getItemIdBeforeAdding(n), n)
    }

    get length() {
        return this._items.length
    }

    get first() {
        return this._items[0] || null
    }

    get last() {
        return this._items[this.length - 1] || null
    }

    add(e, t) {
        return this.addMany([e], t)
    }

    addMany(e, t) {
        if (t === void 0) t = this._items.length; else if (t > this._items.length || t < 0) throw new p("collection-add-item-invalid-index", this);
        let i = 0;
        for (const n of e) {
            const o = this._getItemIdBeforeAdding(n), r = t + i;
            this._items.splice(r, 0, n), this._itemMap.set(o, n), this.fire("add", n, r), i++
        }
        return this.fire("change", {added: e, removed: [], index: t}), this
    }

    get(e) {
        let t;
        if (typeof e == "string") t = this._itemMap.get(e); else if (typeof e == "number") t = this._items[e]; else throw new p("collection-get-invalid-arg", this);
        return t || null
    }

    has(e) {
        if (typeof e == "string") return this._itemMap.has(e);
        {
            const t = this._idProperty, i = e[t];
            return i && this._itemMap.has(i)
        }
    }

    getIndex(e) {
        let t;
        return typeof e == "string" ? t = this._itemMap.get(e) : t = e, t ? this._items.indexOf(t) : -1
    }

    remove(e) {
        const [t, i] = this._remove(e);
        return this.fire("change", {added: [], removed: [t], index: i}), t
    }

    map(e, t) {
        return this._items.map(e, t)
    }

    forEach(e, t) {
        this._items.forEach(e, t)
    }

    find(e, t) {
        return this._items.find(e, t)
    }

    filter(e, t) {
        return this._items.filter(e, t)
    }

    clear() {
        this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
        const e = Array.from(this._items);
        for (; this.length;) this._remove(0);
        this.fire("change", {added: [], removed: e, index: 0})
    }

    bindTo(e) {
        if (this._bindToCollection) throw new p("collection-bind-to-rebind", this);
        return this._bindToCollection = e, {
            as: t => {
                this._setUpBindToBinding(i => new t(i))
            }, using: t => {
                typeof t == "function" ? this._setUpBindToBinding(t) : this._setUpBindToBinding(i => i[t])
            }
        }
    }

    _setUpBindToBinding(e) {
        const t = this._bindToCollection, i = (n, o, r) => {
            const a = t._bindToCollection == this, l = t._bindToInternalToExternalMap.get(o);
            if (a && l) this._bindToExternalToInternalMap.set(o, l), this._bindToInternalToExternalMap.set(l, o); else {
                const c = e(o);
                if (!c) {
                    this._skippedIndexesFromExternal.push(r);
                    return
                }
                let u = r;
                for (const d of this._skippedIndexesFromExternal) r > d && u--;
                for (const d of t._skippedIndexesFromExternal) u >= d && u++;
                this._bindToExternalToInternalMap.set(o, c), this._bindToInternalToExternalMap.set(c, o), this.add(c, u);
                for (let d = 0; d < t._skippedIndexesFromExternal.length; d++) u <= t._skippedIndexesFromExternal[d] && t._skippedIndexesFromExternal[d]++
            }
        };
        for (const n of t) i(null, n, t.getIndex(n));
        this.listenTo(t, "add", i), this.listenTo(t, "remove", (n, o, r) => {
            const a = this._bindToExternalToInternalMap.get(o);
            a && this.remove(a), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((l, c) => (r < c && l.push(c - 1), r > c && l.push(c), l), [])
        })
    }

    _getItemIdBeforeAdding(e) {
        const t = this._idProperty;
        let i;
        if (t in e) {
            if (i = e[t], typeof i != "string") throw new p("collection-add-invalid-id", this);
            if (this.get(i)) throw new p("collection-add-item-already-exists", this)
        } else e[t] = i = pe();
        return i
    }

    _remove(e) {
        let t, i, n, o = !1;
        const r = this._idProperty;
        if (typeof e == "string" ? (i = e, n = this._itemMap.get(i), o = !n, n && (t = this._items.indexOf(n))) : typeof e == "number" ? (t = e, n = this._items[t], o = !n, n && (i = n[r])) : (n = e, i = n[r], t = this._items.indexOf(n), o = t == -1 || !this._itemMap.get(i)), o) throw new p("collection-remove-404", this);
        this._items.splice(t, 1), this._itemMap.delete(i);
        const a = this._bindToInternalToExternalMap.get(n);
        return this._bindToInternalToExternalMap.delete(n), this._bindToExternalToInternalMap.delete(a), this.fire("remove", n, t), [n, t]
    }

    [Symbol.iterator]() {
        return this._items[Symbol.iterator]()
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function re(s) {
    const e = s.next();
    return e.done ? null : e.value
}

class se extends xe(H()) {
    _elements = new Set;
    _externalViews = new Set;
    _blurTimeout = null;

    constructor() {
        super(), this.set("isFocused", !1), this.set("focusedElement", null)
    }

    get elements() {
        return Array.from(this._elements.values())
    }

    get externalViews() {
        return Array.from(this._externalViews.values())
    }

    add(e) {
        if (ol(e)) this._addElement(e); else if (sl(e)) this._addView(e); else {
            if (!e.element) throw new p("focustracker-add-view-missing-element", {focusTracker: this, view: e});
            this._addElement(e.element)
        }
    }

    remove(e) {
        ol(e) ? this._removeElement(e) : sl(e) ? this._removeView(e) : this._removeElement(e.element)
    }

    _addElement(e) {
        if (this._elements.has(e)) throw new p("focustracker-add-element-already-exist", this);
        this.listenTo(e, "focus", () => {
            const t = this.externalViews.find(i => lw(e, i));
            t ? this._focus(t.element) : this._focus(e)
        }, {useCapture: !0}), this.listenTo(e, "blur", () => {
            this._blur()
        }, {useCapture: !0}), this._elements.add(e)
    }

    _removeElement(e) {
        this._elements.has(e) && (this.stopListening(e), this._elements.delete(e)), e === this.focusedElement && this._blur()
    }

    _addView(e) {
        e.element && this._addElement(e.element), this.listenTo(e.focusTracker, "change:focusedElement", () => {
            e.focusTracker.focusedElement ? e.element && this._focus(e.element) : this._blur()
        }), this._externalViews.add(e)
    }

    _removeView(e) {
        e.element && this._removeElement(e.element), this.stopListening(e.focusTracker), this._externalViews.delete(e)
    }

    destroy() {
        this.stopListening(), this._elements.clear(), this._externalViews.clear(), this.isFocused = !1, this.focusedElement = null
    }

    _focus(e) {
        this._clearBlurTimeout(), this.focusedElement = e, this.isFocused = !0
    }

    _blur() {
        this.elements.find(i => i.contains(document.activeElement)) || this.externalViews.find(i => i.focusTracker.isFocused && !i.focusTracker._blurTimeout) || (this._clearBlurTimeout(), this._blurTimeout = setTimeout(() => {
            this.focusedElement = null, this.isFocused = !1
        }, 0))
    }

    _clearBlurTimeout() {
        clearTimeout(this._blurTimeout), this._blurTimeout = null
    }
}

function sl(s) {
    return "focusTracker" in s && s.focusTracker instanceof se
}

function ol(s) {
    return At(s)
}

function lw(s, e) {
    return rl(s, e) ? !0 : !!e.focusTracker.externalViews.find(t => rl(s, t))
}

function rl(s, e) {
    return !!e.element && e.element.contains(document.activeElement) && s.contains(e.element)
}

class ue {
    _listener;

    constructor() {
        this._listener = new (xe())
    }

    listenTo(e) {
        this._listener.listenTo(e, "keydown", (t, i) => {
            this._listener.fire("_keydown:" + zi(i), i)
        })
    }

    set(e, t, i = {}) {
        const n = Qr(e), o = i.priority;
        this._listener.listenTo(this._listener, "_keydown:" + n, (r, a) => {
            i.filter && !i.filter(a) || (t(a, () => {
                a.preventDefault(), a.stopPropagation(), r.stop()
            }), r.return = !0)
        }, {priority: o})
    }

    press(e) {
        return !!this._listener.fire("_keydown:" + zi(e), e)
    }

    stopListening(e) {
        this._listener.stopListening(e)
    }

    destroy() {
        this.stopListening()
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function cw(s) {
    const e = new Map;
    for (const t in s) e.set(t, s[t]);
    return e
}

function nt(s) {
    return ze(s) ? new Map(s) : cw(s)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function al(s, e, t) {
    const i = s.length, n = e.length;
    for (let o = i - 1; o >= t; o--) s[o + n] = s[o];
    for (let o = 0; o < n; o++) s[t + o] = e[o]
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Xr(s, e) {
    let t;

    function i(...n) {
        i.cancel(), t = setTimeout(() => s(...n), e)
    }

    return i.cancel = () => {
        clearTimeout(t)
    }, i
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function ea(s) {
    try {
        if (!s.startsWith("ey")) return null;
        const e = atob(s.replace(/-/g, "+").replace(/_/g, "/"));
        return JSON.parse(e)
    } catch {
        return null
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function uw() {
    const s = [];
    for (let e = 0; e < 256; e++) {
        let t = e;
        for (let i = 0; i < 8; i++) t & 1 ? t = 3988292384 ^ t >>> 1 : t = t >>> 1;
        s[e] = t
    }
    return s
}

function dw(s) {
    const e = Array.isArray(s) ? s : [s], t = uw();
    let i = -1;
    const n = e.map(o => Array.isArray(o) ? o.join("") : String(o)).join("");
    for (let o = 0; o < n.length; o++) {
        const r = n.charCodeAt(o);
        i = i >>> 8 ^ t[(i ^ r) & 255]
    }
    return i = (i ^ -1) >>> 0, i.toString(16).padStart(8, "0")
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function hw(s) {
    const e = [{name: "address", isVoid: !1}, {name: "article", isVoid: !1}, {
            name: "aside",
            isVoid: !1
        }, {name: "blockquote", isVoid: !1}, {name: "details", isVoid: !1}, {name: "dialog", isVoid: !1}, {
            name: "dd",
            isVoid: !1
        }, {name: "div", isVoid: !1}, {name: "dl", isVoid: !1}, {name: "dt", isVoid: !1}, {
            name: "fieldset",
            isVoid: !1
        }, {name: "figcaption", isVoid: !1}, {name: "figure", isVoid: !1}, {name: "footer", isVoid: !1}, {
            name: "form",
            isVoid: !1
        }, {name: "h1", isVoid: !1}, {name: "h2", isVoid: !1}, {name: "h3", isVoid: !1}, {
            name: "h4",
            isVoid: !1
        }, {name: "h5", isVoid: !1}, {name: "h6", isVoid: !1}, {name: "header", isVoid: !1}, {
            name: "hgroup",
            isVoid: !1
        }, {name: "hr", isVoid: !0}, {name: "li", isVoid: !1}, {name: "main", isVoid: !1}, {
            name: "nav",
            isVoid: !1
        }, {name: "ol", isVoid: !1}, {name: "p", isVoid: !1}, {name: "section", isVoid: !1}, {
            name: "table",
            isVoid: !1
        }, {name: "tbody", isVoid: !1}, {name: "td", isVoid: !1}, {name: "th", isVoid: !1}, {
            name: "thead",
            isVoid: !1
        }, {name: "tr", isVoid: !1}, {name: "ul", isVoid: !1}], t = e.map(r => r.name).join("|"),
        i = s.replace(new RegExp(`</?(${t})( .*?)?>`, "g"), `
$&
`).replace(/<br[^>]*>/g, `$&
`).split(`
`);
    let n = 0, o = !1;
    return i.map(r => (o = gw(r, o), !r.length && !o ? "" : fw(r, e) ? Yn(r, n++) : mw(r, e) ? Yn(r, --n) : o === "middle" || o === "last" ? Yn(r, 0) : Yn(r, n))).join("").trimEnd()
}

function fw(s, e) {
    return e.some(t => !(t.isVoid || !new RegExp(`<${t.name}( .*?)?>`).test(s)))
}

function mw(s, e) {
    return e.some(t => new RegExp(`</${t.name}>`).test(s))
}

function Yn(s, e, t = "    ") {
    return `${t.repeat(Math.max(0, e))}${s}
`
}

function gw(s, e) {
    const t = /<pre( .*?)?>/.test(s), i = /<\/pre>/.test(s);
    return t && i ? !1 : t ? "first" : i ? "last" : e === "first" || e === "middle" ? "middle" : !1
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function pw(s) {
    return !!s && s.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(s)
}

function ww(s) {
    return !!s && s.length == 1 && /[\ud800-\udbff]/.test(s)
}

function bw(s) {
    return !!s && s.length == 1 && /[\udc00-\udfff]/.test(s)
}

function ta(s, e) {
    return ww(s.charAt(e - 1)) && bw(s.charAt(e))
}

function ia(s, e) {
    return pw(s.charAt(e))
}

const _w = vw();

function ph(s, e) {
    const t = String(s).matchAll(_w);
    return Array.from(t).some(i => i.index < e && e < i.index + i[0].length)
}

function vw() {
    const s = [new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}", "u"), new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")],
        e = new RegExp("\\p{Regional_Indicator}{2}", "u").source, t = "(?:" + s.map(n => n.source).join("|") + ")",
        i = `${e}|${t}(?:‍${t})*`;
    return new RegExp(i, "ug")
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const en = new WeakMap;
let ll = !1;

function wh({view: s, element: e, text: t, isDirectHost: i = !0, keepOnFocus: n = !1}) {
    const o = s.document;
    en.has(o) || (en.set(o, new Map), o.registerPostFixer(a => bo(en.get(o), a)), o.on("change:isComposing", () => {
        s.change(a => bo(en.get(o), a))
    }, {priority: "high"})), e.is("editableElement") && e.on("change:placeholder", (a, l, c) => r(c)), e.placeholder ? r(e.placeholder) : t && r(t), t && Aw();

    function r(a) {
        const l = {text: a, isDirectHost: i, keepOnFocus: n, hostElement: i ? e : null};
        en.get(o).set(e, l), s.change(c => bo([[e, l]], c))
    }
}

function yw(s, e) {
    return e.hasClass("ck-placeholder") ? !1 : (s.addClass("ck-placeholder", e), !0)
}

function kw(s, e) {
    return e.hasClass("ck-placeholder") ? (s.removeClass("ck-placeholder", e), !0) : !1
}

function Cw(s, e) {
    if (!s.isAttached() || Ew(s)) return !1;
    const t = s.document, n = t.selection.anchor;
    return t.isComposing && n && n.parent === s ? !1 : e || !t.isFocused ? !0 : !!n && n.parent !== s
}

function Ew(s) {
    for (const e of s.getChildren()) if (!e.is("uiElement")) return !0;
    return !1
}

function bo(s, e) {
    const t = [];
    let i = !1;
    for (const [n, o] of s) o.isDirectHost && (t.push(n), cl(e, n, o) && (i = !0));
    for (const [n, o] of s) {
        if (o.isDirectHost) continue;
        const r = Tw(n);
        r && (t.includes(r) || (o.hostElement = r, cl(e, n, o) && (i = !0)))
    }
    return i
}

function cl(s, e, t) {
    const {text: i, isDirectHost: n, hostElement: o} = t;
    let r = !1;
    return o.getAttribute("data-placeholder") !== i && (s.setAttribute("data-placeholder", i, o), r = !0), (n || e.childCount == 1) && Cw(o, t.keepOnFocus) ? yw(s, o) && (r = !0) : kw(s, o) && (r = !0), r
}

function Tw(s) {
    if (s.childCount) {
        const e = s.getChild(0);
        if (e.is("element") && !e.is("uiElement") && !e.is("attributeElement")) return e
    }
    return null
}

function Aw() {
    ll || L("enableplaceholder-deprecated-text-option"), ll = !0
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */let si = class {
    is() {
        throw new Error("is() method is abstract")
    }
}, oi = class extends W(si) {
    document;
    parent;

    constructor(e) {
        super(), this.document = e, this.parent = null
    }

    get index() {
        let e;
        if (!this.parent) return null;
        if ((e = this.parent.getChildIndex(this)) == -1) throw new p("view-node-not-found-in-parent", this);
        return e
    }

    get nextSibling() {
        const e = this.index;
        return e !== null && this.parent.getChild(e + 1) || null
    }

    get previousSibling() {
        const e = this.index;
        return e !== null && this.parent.getChild(e - 1) || null
    }

    get root() {
        let e = this;
        for (; e.parent;) e = e.parent;
        return e
    }

    isAttached() {
        return this.root.is("rootElement")
    }

    getPath() {
        const e = [];
        let t = this;
        for (; t.parent;) e.unshift(t.index), t = t.parent;
        return e
    }

    getAncestors(e = {}) {
        const t = [];
        let i = e.includeSelf ? this : this.parent;
        for (; i;) t[e.parentFirst ? "push" : "unshift"](i), i = i.parent;
        return t
    }

    getCommonAncestor(e, t = {}) {
        const i = this.getAncestors(t), n = e.getAncestors(t);
        let o = 0;
        for (; i[o] == n[o] && i[o];) o++;
        return o === 0 ? null : i[o - 1]
    }

    isBefore(e) {
        if (this == e || this.root !== e.root) return !1;
        const t = this.getPath(), i = e.getPath(), n = _e(t, i);
        switch (n) {
            case"prefix":
                return !0;
            case"extension":
                return !1;
            default:
                return t[n] < i[n]
        }
    }

    isAfter(e) {
        return this == e || this.root !== e.root ? !1 : !this.isBefore(e)
    }

    _remove() {
        this.parent._removeChildren(this.index)
    }

    _fireChange(e, t, i) {
        this.fire(`change:${e}`, t, i), this.parent && this.parent._fireChange(e, t, i)
    }

    toJSON() {
        const e = $r(this);
        return delete e.parent, e
    }
};
oi.prototype.is = function (s) {
    return s === "node" || s === "view:node"
};
let ge = class ur extends oi {
    _textData;

    constructor(e, t) {
        super(e), this._textData = t
    }

    get data() {
        return this._textData
    }

    get _data() {
        return this.data
    }

    set _data(e) {
        this._fireChange("text", this), this._textData = e
    }

    isSimilar(e) {
        return e instanceof ur ? this === e || this.data === e.data : !1
    }

    _clone() {
        return new ur(this.document, this.data)
    }
};
ge.prototype.is = function (s) {
    return s === "$text" || s === "view:$text" || s === "text" || s === "view:text" || s === "node" || s === "view:node"
};
let yt = class extends si {
    textNode;
    data;
    offsetInText;

    constructor(e, t, i) {
        if (super(), this.textNode = e, t < 0 || t > e.data.length) throw new p("view-textproxy-wrong-offsetintext", this);
        if (i < 0 || t + i > e.data.length) throw new p("view-textproxy-wrong-length", this);
        this.data = e.data.substring(t, t + i), this.offsetInText = t
    }

    get offsetSize() {
        return this.data.length
    }

    get isPartial() {
        return this.data.length !== this.textNode.data.length
    }

    get parent() {
        return this.textNode.parent
    }

    get root() {
        return this.textNode.root
    }

    get document() {
        return this.textNode.document
    }

    getAncestors(e = {}) {
        const t = [];
        let i = e.includeSelf ? this.textNode : this.parent;
        for (; i !== null;) t[e.parentFirst ? "push" : "unshift"](i), i = i.parent;
        return t
    }
};
yt.prototype.is = function (s) {
    return s === "$textProxy" || s === "view:$textProxy" || s === "textProxy" || s === "view:textProxy"
};

class Bs {
    _consumables = new Map;

    add(e, t) {
        let i;
        if (e.is("$text") || e.is("documentFragment")) {
            this._consumables.set(e, !0);
            return
        }
        this._consumables.has(e) ? i = this._consumables.get(e) : (i = new xw(e), this._consumables.set(e, i)), i.add(t ? mn(t) : e._getConsumables())
    }

    test(e, t) {
        const i = this._consumables.get(e);
        return i === void 0 ? null : e.is("$text") || e.is("documentFragment") ? i : i.test(mn(t))
    }

    consume(e, t) {
        if (e.is("$text") || e.is("documentFragment")) return this.test(e, t) ? (this._consumables.set(e, !1), !0) : !1;
        const i = this._consumables.get(e);
        return i === void 0 ? !1 : i.consume(mn(t))
    }

    revert(e, t) {
        const i = this._consumables.get(e);
        i !== void 0 && (e.is("$text") || e.is("documentFragment") ? this._consumables.set(e, !0) : i.revert(mn(t)))
    }

    static createFrom(e, t) {
        if (t || (t = new Bs), e.is("$text")) t.add(e); else if (e.is("element") || e.is("documentFragment")) {
            t.add(e);
            for (const i of e.getChildren()) Bs.createFrom(i, t)
        }
        return t
    }
}

class xw {
    element;
    _canConsumeName = null;
    _attributes = new Map;

    constructor(e) {
        this.element = e
    }

    add(e) {
        e.name && (this._canConsumeName = !0);
        for (const [t, i] of e.attributes) if (i) {
            let n = this._attributes.get(t);
            (!n || typeof n == "boolean") && (n = new Map, this._attributes.set(t, n)), n.set(i, !0)
        } else {
            if (t == "style" || t == "class") throw new p("viewconsumable-invalid-attribute", this);
            this._attributes.set(t, !0)
        }
    }

    test(e) {
        if (e.name && !this._canConsumeName) return this._canConsumeName;
        for (const [t, i] of e.attributes) {
            const n = this._attributes.get(t);
            if (n === void 0) return null;
            if (n === !1) return !1;
            if (n !== !0) {
                if (i) {
                    const o = n.get(i);
                    if (o === void 0) return null;
                    if (!o) return !1
                } else for (const o of n.values()) if (!o) return !1
            }
        }
        return !0
    }

    consume(e) {
        if (!this.test(e)) return !1;
        e.name && (this._canConsumeName = !1);
        for (const [t, i] of e.attributes) {
            const n = this._attributes.get(t);
            if (typeof n == "boolean") for (const [o] of this.element._getConsumables(t, i).attributes) this._attributes.set(o, !1); else if (i) for (const [, o] of this.element._getConsumables(t, i).attributes) n.set(o, !1); else for (const o of n.keys()) n.set(o, !1)
        }
        return !0
    }

    revert(e) {
        e.name && (this._canConsumeName = !0);
        for (const [t, i] of e.attributes) {
            const n = this._attributes.get(t);
            if (n === !1) {
                this._attributes.set(t, !0);
                continue
            }
            if (!(n === void 0 || n === !0)) if (i) n.get(i) === !1 && n.set(i, !0); else for (const o of n.keys()) n.set(o, !0)
        }
    }
}

function mn(s) {
    const e = [];
    return "attributes" in s && s.attributes && _o(e, s.attributes), "classes" in s && s.classes && _o(e, s.classes, "class"), "styles" in s && s.styles && _o(e, s.styles, "style"), {
        name: s.name || !1,
        attributes: e
    }
}

function _o(s, e, t) {
    if (typeof e == "string") {
        s.push(t ? [t, e] : [e]);
        return
    }
    for (const i of e) Array.isArray(i) ? s.push(i) : s.push(t ? [t, i] : [i])
}

class He {
    _patterns = [];

    constructor(...e) {
        this.add(...e)
    }

    add(...e) {
        for (let t of e) (typeof t == "string" || t instanceof RegExp) && (t = {name: t}), this._patterns.push(t)
    }

    match(...e) {
        for (const t of e) for (const i of this._patterns) {
            const n = this._isElementMatching(t, i);
            if (n) return {element: t, pattern: i, match: n}
        }
        return null
    }

    matchAll(...e) {
        const t = [];
        for (const i of e) for (const n of this._patterns) {
            const o = this._isElementMatching(i, n);
            o && t.push({element: i, pattern: n, match: o})
        }
        return t.length > 0 ? t : null
    }

    getElementName() {
        if (this._patterns.length !== 1) return null;
        const e = this._patterns[0], t = e.name;
        return typeof e != "function" && t && !(t instanceof RegExp) ? t : null
    }

    _isElementMatching(e, t) {
        if (typeof t == "function") {
            const o = t(e);
            return !o || typeof o != "object" ? o : mn(o)
        }
        const i = {};
        if (t.name && (i.name = Iw(t.name, e.name), !i.name)) return null;
        const n = [];
        return t.attributes && !Sw(t.attributes, e, n) || t.classes && !Pw(t.classes, e, n) || t.styles && !Rw(t.styles, e, n) ? null : (n.length && (i.attributes = n), i)
    }
}

function Fs(s, e) {
    return s === !0 || s === e || s instanceof RegExp && !!String(e).match(s)
}

function Iw(s, e) {
    return s instanceof RegExp ? !!e.match(s) : s === e
}

function na(s, e) {
    if (Array.isArray(s)) return s.map(i => typeof i != "object" || i instanceof RegExp ? e ? [e, i, !0] : [i, !0] : ((i.key === void 0 || i.value === void 0) && L("matcher-pattern-missing-key-or-value", i), e ? [e, i.key, i.value] : [i.key, i.value]));
    if (typeof s != "object" || s instanceof RegExp) return [e ? [e, s, !0] : [s, !0]];
    const t = [];
    for (const i in s) Object.prototype.hasOwnProperty.call(s, i) && t.push(e ? [e, i, s[i]] : [i, s[i]]);
    return t
}

function Sw(s, e, t) {
    let i;
    return typeof s == "object" && !(s instanceof RegExp) && !Array.isArray(s) ? (s.style !== void 0 && L("matcher-pattern-deprecated-attributes-style-key", s), s.class !== void 0 && L("matcher-pattern-deprecated-attributes-class-key", s)) : i = ["class", "style"], e._collectAttributesMatch(na(s), t, i)
}

function Pw(s, e, t) {
    return e._collectAttributesMatch(na(s, "class"), t)
}

function Rw(s, e, t) {
    return e._collectAttributesMatch(na(s, "style"), t)
}

class Fi {
    _styles;
    _cachedStyleNames = null;
    _cachedExpandedStyleNames = null;
    _styleProcessor;

    constructor(e) {
        this._styles = {}, this._styleProcessor = e
    }

    get isEmpty() {
        return !Object.entries(this._styles).length
    }

    get size() {
        return this.isEmpty ? 0 : this.getStyleNames().length
    }

    setTo(e) {
        this.clear();
        const t = Ow(e);
        for (const [i, n] of t) this._styleProcessor.toNormalizedForm(i, n, this._styles);
        return this
    }

    has(e) {
        if (this.isEmpty) return !1;
        const i = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
        return Array.isArray(i)
    }

    set(e, t) {
        if (this._cachedStyleNames = null, this._cachedExpandedStyleNames = null, tt(e)) for (const [i, n] of Object.entries(e)) this._styleProcessor.toNormalizedForm(i, n, this._styles); else this._styleProcessor.toNormalizedForm(e, t, this._styles)
    }

    remove(e) {
        for (const t of U(e)) {
            this._cachedStyleNames = null, this._cachedExpandedStyleNames = null;
            const i = dr(t);
            ep(this._styles, i), delete this._styles[t], this._cleanEmptyObjectsOnPath(i)
        }
    }

    getNormalized(e) {
        return this._styleProcessor.getNormalized(e, this._styles)
    }

    toString() {
        return this.isEmpty ? "" : this.getStylesEntries().map(e => e.join(":")).sort().join(";") + ";"
    }

    getAsString(e) {
        if (this.isEmpty) return;
        if (this._styles[e] && !tt(this._styles[e])) return this._styles[e];
        const i = this._styleProcessor.getReducedForm(e, this._styles).find(([n]) => n === e);
        if (Array.isArray(i)) return i[1]
    }

    getStyleNames(e = !1) {
        return this.isEmpty ? [] : e ? (this._cachedExpandedStyleNames ||= this._styleProcessor.getStyleNames(this._styles), this._cachedExpandedStyleNames) : (this._cachedStyleNames ||= this.getStylesEntries().map(([t]) => t), this._cachedStyleNames)
    }

    keys() {
        return this.getStyleNames()
    }

    clear() {
        this._styles = {}, this._cachedStyleNames = null, this._cachedExpandedStyleNames = null
    }

    isSimilar(e) {
        if (this.size !== e.size) return !1;
        for (const t of this.getStyleNames()) if (!e.has(t) || e.getAsString(t) !== this.getAsString(t)) return !1;
        return !0
    }

    getStylesEntries() {
        const e = [], t = Object.keys(this._styles);
        for (const i of t) e.push(...this._styleProcessor.getReducedForm(i, this._styles));
        return e
    }

    _clone() {
        const e = new this.constructor(this._styleProcessor);
        return e.set(this.getNormalized()), e
    }

    _getTokensMatch(e, t) {
        const i = [];
        for (const n of this.getStyleNames(!0)) if (Fs(e, n)) {
            if (t === !0) {
                i.push(n);
                continue
            }
            const o = this.getAsString(n);
            Fs(t, o) && i.push(n)
        }
        return i.length ? i : void 0
    }

    _getConsumables(e) {
        const t = [];
        if (e) {
            t.push(e);
            for (const i of this._styleProcessor.getRelatedStyles(e)) t.push(i)
        } else for (const i of this.getStyleNames()) {
            for (const n of this._styleProcessor.getRelatedStyles(i)) t.push(n);
            t.push(i)
        }
        return t
    }

    _canMergeFrom(e) {
        for (const t of e.getStyleNames()) if (this.has(t) && this.getAsString(t) !== e.getAsString(t)) return !1;
        return !0
    }

    _mergeFrom(e) {
        for (const t of e.getStyleNames()) this.has(t) || this.set(t, e.getAsString(t))
    }

    _isMatching(e) {
        for (const t of e.getStyleNames()) if (!this.has(t) || this.getAsString(t) !== e.getAsString(t)) return !1;
        return !0
    }

    _cleanEmptyObjectsOnPath(e) {
        const t = e.split(".");
        if (!(t.length > 1)) return;
        const n = t.splice(0, t.length - 1).join("."), o = Nt(this._styles, n);
        if (!o) return;
        !Object.keys(o).length && this.remove(n)
    }
}

class Vw {
    _normalizers;
    _extractors;
    _reducers;
    _consumables;

    constructor() {
        this._normalizers = new Map, this._extractors = new Map, this._reducers = new Map, this._consumables = new Map
    }

    toNormalizedForm(e, t, i) {
        if (tt(t)) {
            vo(i, dr(e), t);
            return
        }
        if (this._normalizers.has(e)) {
            const n = this._normalizers.get(e), {path: o, value: r} = n(t);
            vo(i, o, r)
        } else vo(i, e, t)
    }

    getNormalized(e, t) {
        if (!e) return Kr({}, t);
        if (t[e] !== void 0) return t[e];
        if (this._extractors.has(e)) {
            const i = this._extractors.get(e);
            if (typeof i == "string") return Nt(t, i);
            const n = i(e, t);
            if (n) return n
        }
        return Nt(t, dr(e))
    }

    getReducedForm(e, t) {
        const i = this.getNormalized(e, t);
        return i === void 0 ? [] : this._reducers.has(e) ? this._reducers.get(e)(i) : [[e, i]]
    }

    getStyleNames(e) {
        const t = new Set;
        for (const i of this._consumables.keys()) {
            const n = this.getNormalized(i, e);
            n && (typeof n != "object" || Object.keys(n).length) && t.add(i)
        }
        for (const i of Object.keys(e)) t.add(i);
        return Array.from(t)
    }

    getRelatedStyles(e) {
        return this._consumables.get(e) || []
    }

    setNormalizer(e, t) {
        this._normalizers.set(e, t)
    }

    setExtractor(e, t) {
        this._extractors.set(e, t)
    }

    setReducer(e, t) {
        this._reducers.set(e, t)
    }

    setStyleRelation(e, t) {
        this._mapStyleNames(e, t);
        for (const i of t) this._mapStyleNames(i, [e])
    }

    _mapStyleNames(e, t) {
        this._consumables.has(e) || this._consumables.set(e, []), this._consumables.get(e).push(...t)
    }
}

function Ow(s) {
    let e = null, t = 0, i = 0, n = null;
    const o = new Map;
    if (s === "") return o;
    s.charAt(s.length - 1) != ";" && (s = s + ";");
    for (let r = 0; r < s.length; r++) {
        const a = s.charAt(r);
        if (e === null) switch (a) {
            case":":
                n || (n = s.substr(t, r - t), i = r + 1);
                break;
            case'"':
            case"'":
                e = a;
                break;
            case";": {
                const l = s.substr(i, r - i);
                n && o.set(n.trim(), l.trim()), n = null, t = r + 1;
                break
            }
        } else a === e && (e = null)
    }
    return o
}

function dr(s) {
    return s.replace("-", ".")
}

function vo(s, e, t) {
    let i = t;
    tt(t) && (i = Kr({}, Nt(s, e), t)), Nd(s, e, i)
}

class yo {
    _set = new Set;

    get isEmpty() {
        return this._set.size == 0
    }

    get size() {
        return this._set.size
    }

    has(e) {
        return this._set.has(e)
    }

    keys() {
        return Array.from(this._set.keys())
    }

    setTo(e) {
        this.clear();
        for (const t of e.split(/\s+/)) t && this._set.add(t);
        return this
    }

    set(e) {
        for (const t of U(e)) t && this._set.add(t)
    }

    remove(e) {
        for (const t of U(e)) this._set.delete(t)
    }

    clear() {
        this._set.clear()
    }

    toString() {
        return Array.from(this._set).join(" ")
    }

    isSimilar(e) {
        if (this.size !== e.size) return !1;
        for (const t of this.keys()) if (!e.has(t)) return !1;
        return !0
    }

    _clone() {
        const e = new this.constructor;
        return e._set = new Set(this._set), e
    }

    _getTokensMatch(e) {
        const t = [];
        if (e === !0) {
            for (const i of this._set.keys()) t.push(i);
            return t
        }
        if (typeof e == "string") {
            for (const i of e.split(/\s+/)) if (this._set.has(i)) t.push(i); else return;
            return t
        }
        for (const i of this._set.keys()) i.match(e) && t.push(i);
        return t.length ? t : void 0
    }

    _getConsumables(e) {
        return e ? [e] : this.keys()
    }

    _canMergeFrom() {
        return !0
    }

    _mergeFrom(e) {
        for (const t of e._set.keys()) this._set.has(t) || this._set.add(t)
    }

    _isMatching(e) {
        for (const t of e._set.keys()) if (!this._set.has(t)) return !1;
        return !0
    }
}

let It = class bh extends oi {
    name;
    _unsafeAttributesToRender = [];
    _attrs;
    _children;
    _customProperties = new Map;

    get _classes() {
        return this._attrs.get("class")
    }

    get _styles() {
        return this._attrs.get("style")
    }

    constructor(e, t, i, n) {
        super(e), this.name = t, this._attrs = this._parseAttributes(i), this._children = [], n && this._insertChild(0, n)
    }

    get childCount() {
        return this._children.length
    }

    get isEmpty() {
        return this._children.length === 0
    }

    getChild(e) {
        return this._children[e]
    }

    getChildIndex(e) {
        return this._children.indexOf(e)
    }

    getChildren() {
        return this._children[Symbol.iterator]()
    }

    * getAttributeKeys() {
        this._classes && (yield"class"), this._styles && (yield"style");
        for (const e of this._attrs.keys()) e != "class" && e != "style" && (yield e)
    }

    * getAttributes() {
        for (const [e, t] of this._attrs.entries()) yield[e, String(t)]
    }

    getAttribute(e) {
        return this._attrs.has(e) ? String(this._attrs.get(e)) : void 0
    }

    hasAttribute(e, t) {
        return this._attrs.has(e) ? t !== void 0 ? mi(this.name, e) || tn(this.name, e) ? this._attrs.get(e).has(t) : this._attrs.get(e) === t : !0 : !1
    }

    isSimilar(e) {
        if (!(e instanceof bh)) return !1;
        if (this === e) return !0;
        if (this.name != e.name || this._attrs.size !== e._attrs.size) return !1;
        for (const [t, i] of this._attrs) {
            const n = e._attrs.get(t);
            if (n === void 0) return !1;
            if (typeof i == "string" || typeof n == "string") {
                if (n !== i) return !1
            } else if (!i.isSimilar(n)) return !1
        }
        return !0
    }

    hasClass(...e) {
        for (const t of e) if (!this._classes || !this._classes.has(t)) return !1;
        return !0
    }

    getClassNames() {
        const e = this._classes ? this._classes.keys() : [], t = e[Symbol.iterator]();
        return Object.assign(e, {next: t.next.bind(t)})
    }

    getStyle(e) {
        return this._styles && this._styles.getAsString(e)
    }

    getNormalizedStyle(e) {
        return this._styles && this._styles.getNormalized(e)
    }

    getStyleNames(e) {
        return this._styles ? this._styles.getStyleNames(e) : []
    }

    hasStyle(...e) {
        for (const t of e) if (!this._styles || !this._styles.has(t)) return !1;
        return !0
    }

    findAncestor(...e) {
        const t = new He(...e);
        let i = this.parent;
        for (; i && !i.is("documentFragment");) {
            if (t.match(i)) return i;
            i = i.parent
        }
        return null
    }

    getCustomProperty(e) {
        return this._customProperties.get(e)
    }

    * getCustomProperties() {
        yield* this._customProperties.entries()
    }

    getIdentity() {
        const e = this._classes ? this._classes.keys().sort().join(",") : "", t = this._styles && String(this._styles),
            i = Array.from(this._attrs).filter(([n]) => n != "style" && n != "class").map(n => `${n[0]}="${n[1]}"`).sort().join(" ");
        return this.name + (e == "" ? "" : ` class="${e}"`) + (t ? ` style="${t}"` : "") + (i == "" ? "" : ` ${i}`)
    }

    shouldRenderUnsafeAttribute(e) {
        return this._unsafeAttributesToRender.includes(e)
    }

    _clone(e = !1) {
        const t = [];
        if (e) for (const n of this.getChildren()) t.push(n._clone(e));
        const i = new this.constructor(this.document, this.name, this._attrs, t);
        return i._customProperties = new Map(this._customProperties), i.getFillerOffset = this.getFillerOffset, i._unsafeAttributesToRender = this._unsafeAttributesToRender, i
    }

    _appendChild(e) {
        return this._insertChild(this.childCount, e)
    }

    _insertChild(e, t) {
        this._fireChange("children", this, {index: e});
        let i = 0;
        const n = Mw(this.document, t);
        for (const o of n) o.parent !== null && o._remove(), o.parent = this, o.document = this.document, this._children.splice(e, 0, o), e++, i++;
        return i
    }

    _removeChildren(e, t = 1) {
        this._fireChange("children", this, {index: e});
        for (let i = e; i < e + t; i++) this._children[i].parent = null;
        return this._children.splice(e, t)
    }

    _setAttribute(e, t, i = !0) {
        if (this._fireChange("attributes", this), mi(this.name, e) || tn(this.name, e)) {
            let n = this._attrs.get(e);
            n || (n = mi(this.name, e) ? new Fi(this.document.stylesProcessor) : new yo, this._attrs.set(e, n)), i ? n.setTo(String(t)) : mi(this.name, e) ? Array.isArray(t) ? n.set(t[0], t[1]) : n.set(t) : n.set(typeof t == "string" ? t.split(/\s+/) : t)
        } else this._attrs.set(e, String(t))
    }

    _removeAttribute(e, t) {
        if (this._fireChange("attributes", this), t !== void 0 && (mi(this.name, e) || tn(this.name, e))) {
            const i = this._attrs.get(e);
            return i ? (tn(this.name, e) && typeof t == "string" && (t = t.split(/\s+/)), i.remove(t), i.isEmpty ? this._attrs.delete(e) : !1) : !1
        }
        return this._attrs.delete(e)
    }

    _addClass(e) {
        this._setAttribute("class", e, !1)
    }

    _removeClass(e) {
        this._removeAttribute("class", e)
    }

    _setStyle(e, t) {
        typeof e != "string" ? this._setAttribute("style", e, !1) : this._setAttribute("style", [e, t], !1)
    }

    _removeStyle(e) {
        this._removeAttribute("style", e)
    }

    _collectAttributesMatch(e, t, i) {
        for (const [n, o, r] of e) {
            let a = !1, l = !1;
            for (const [c, u] of this._attrs) if (!(i && i.includes(c) || !Fs(n, c))) if (a = !0, typeof u == "string") {
                if (Fs(o, u)) t.push([c]), l = !0; else if (!(n instanceof RegExp)) return !1
            } else {
                const d = u._getTokensMatch(o, r || !0);
                if (d) {
                    l = !0;
                    for (const h of d) t.push([c, h])
                } else if (!(n instanceof RegExp)) return !1
            }
            if (!a || !l) return !1
        }
        return !0
    }

    _getConsumables(e, t) {
        const i = [];
        if (e) {
            const n = this._attrs.get(e);
            if (n !== void 0) if (typeof n == "string") i.push([e]); else for (const o of n._getConsumables(t)) i.push([e, o])
        } else for (const [n, o] of this._attrs) if (typeof o == "string") i.push([n]); else for (const r of o._getConsumables()) i.push([n, r]);
        return {name: !e, attributes: i}
    }

    _canMergeAttributesFrom(e) {
        if (this.name != e.name) return !1;
        for (const [t, i] of e._attrs) {
            const n = this._attrs.get(t);
            if (n !== void 0) {
                if (typeof n == "string" || typeof i == "string") {
                    if (n !== i) return !1
                } else if (!n._canMergeFrom(i)) return !1
            }
        }
        return !0
    }

    _mergeAttributesFrom(e) {
        this._fireChange("attributes", this);
        for (const [t, i] of e._attrs) {
            const n = this._attrs.get(t);
            n === void 0 || typeof n == "string" || typeof i == "string" ? this._setAttribute(t, i) : n._mergeFrom(i)
        }
    }

    _canSubtractAttributesOf(e) {
        if (this.name != e.name) return !1;
        for (const [t, i] of e._attrs) {
            const n = this._attrs.get(t);
            if (n === void 0) return !1;
            if (typeof n == "string" || typeof i == "string") {
                if (n !== i) return !1
            } else if (!n._isMatching(i)) return !1
        }
        return !0
    }

    _subtractAttributesOf(e) {
        this._fireChange("attributes", this);
        for (const [t, i] of e._attrs) {
            const n = this._attrs.get(t);
            typeof n == "string" || typeof i == "string" ? this._attrs.delete(t) : (n.remove(i.keys()), n.isEmpty && this._attrs.delete(t))
        }
    }

    _setCustomProperty(e, t) {
        this._customProperties.set(e, t)
    }

    _removeCustomProperty(e) {
        return this._customProperties.delete(e)
    }

    _parseAttributes(e) {
        const t = nt(e);
        for (const [i, n] of t) if (n === null) t.delete(i); else if (mi(this.name, i)) {
            const o = n instanceof Fi ? n._clone() : new Fi(this.document.stylesProcessor).setTo(String(n));
            t.set(i, o)
        } else if (tn(this.name, i)) {
            const o = n instanceof yo ? n._clone() : new yo().setTo(String(n));
            t.set(i, o)
        } else typeof n != "string" && t.set(i, String(n));
        return t
    }
};
It.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "element" || s === "view:element") : s === "element" || s === "view:element" || s === "node" || s === "view:node"
};

function Mw(s, e) {
    if (typeof e == "string") return [new ge(s, e)];
    ze(e) || (e = [e]);
    const t = [];
    for (const i of e) typeof i == "string" ? t.push(new ge(s, i)) : i instanceof yt ? t.push(new ge(s, i.data)) : t.push(i);
    return t
}

function tn(s, e) {
    return e == "class" || s == "a" && e == "rel"
}

function mi(s, e) {
    return e == "style"
}

class An extends It {
    constructor(e, t, i, n) {
        super(e, t, i, n), this.getFillerOffset = Bw
    }
}

An.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element") : s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
};

function Bw() {
    const s = [...this.getChildren()], e = s[this.childCount - 1];
    if (e && e.is("element", "br")) return this.childCount;
    for (const t of s) if (!t.is("uiElement")) return null;
    return this.childCount
}

class Qs extends H(An) {
    constructor(e, t, i, n) {
        super(e, t, i, n), this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("placeholder", void 0), this.bind("isReadOnly").to(e), this.bind("isFocused").to(e, "isFocused", o => o && e.selection.editableElement == this), this.listenTo(e.selection, "change", () => {
            this.isFocused = e.isFocused && e.selection.editableElement == this
        })
    }

    destroy() {
        this.stopListening()
    }
}

Qs.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "editableElement" || s === "view:editableElement" || s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element") : s === "editableElement" || s === "view:editableElement" || s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
};
const ul = Symbol("rootName");

class _h extends Qs {
    constructor(e, t) {
        super(e, t), this.rootName = "main"
    }

    get rootName() {
        return this.getCustomProperty(ul)
    }

    set rootName(e) {
        this._setCustomProperty(ul, e)
    }

    set _name(e) {
        this.name = e
    }
}

_h.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "rootElement" || s === "view:rootElement" || s === "editableElement" || s === "view:editableElement" || s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element") : s === "rootElement" || s === "view:rootElement" || s === "editableElement" || s === "view:editableElement" || s === "containerElement" || s === "view:containerElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
};
let Yt = class {
    direction;
    boundaries;
    singleCharacters;
    shallow;
    ignoreElementEnd;
    _position;
    _boundaryStartParent;
    _boundaryEndParent;

    constructor(e = {}) {
        if (!e.boundaries && !e.startPosition) throw new p("view-tree-walker-no-start-position", null);
        if (e.direction && e.direction != "forward" && e.direction != "backward") throw new p("view-tree-walker-unknown-direction", e.startPosition, {direction: e.direction});
        this.boundaries = e.boundaries || null, e.startPosition ? this._position = k._createAt(e.startPosition) : this._position = k._createAt(e.boundaries[e.direction == "backward" ? "end" : "start"]), this.direction = e.direction || "forward", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null
    }

    [Symbol.iterator]() {
        return this
    }

    get position() {
        return this._position
    }

    skip(e) {
        let t, i;
        do i = this.position, t = this.next(); while (!t.done && e(t.value));
        t.done || (this._position = i)
    }

    jumpTo(e) {
        this._boundaryStartParent && e.isBefore(this.boundaries.start) ? e = this.boundaries.start : this._boundaryEndParent && e.isAfter(this.boundaries.end) && (e = this.boundaries.end), this._position = e.clone()
    }

    next() {
        return this.direction == "forward" ? this._next() : this._previous()
    }

    _next() {
        let e = this.position.clone();
        const t = this.position, i = e.parent;
        if (i.parent === null && e.offset === i.childCount) return {done: !0, value: void 0};
        if (i === this._boundaryEndParent && e.offset == this.boundaries.end.offset) return {done: !0, value: void 0};
        let n;
        if (i && i.is("view:$text")) {
            if (e.isAtEnd) return this._position = k._createAfter(i), this._next();
            n = i.data[e.offset]
        } else n = i.getChild(e.offset);
        if (typeof n == "string") {
            let o;
            this.singleCharacters ? o = 1 : o = (i === this._boundaryEndParent ? this.boundaries.end.offset : i.data.length) - e.offset;
            const r = new yt(i, e.offset, o);
            return e.offset += o, this._position = e, this._formatReturnValue("text", r, t, e, o)
        }
        if (n && n.is("view:element")) {
            if (!this.shallow) e = new k(n, 0); else {
                if (this.boundaries && this.boundaries.end.isBefore(e)) return {done: !0, value: void 0};
                e.offset++
            }
            return this._position = e, this._formatReturnValue("elementStart", n, t, e, 1)
        }
        if (n && n.is("view:$text")) {
            if (this.singleCharacters) return e = new k(n, 0), this._position = e, this._next();
            let o = n.data.length, r;
            return n == this._boundaryEndParent ? (o = this.boundaries.end.offset, r = new yt(n, 0, o), e = k._createAfter(r)) : (r = new yt(n, 0, n.data.length), e.offset++), this._position = e, this._formatReturnValue("text", r, t, e, o)
        }
        return e = k._createAfter(i), this._position = e, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", i, t, e)
    }

    _previous() {
        let e = this.position.clone();
        const t = this.position, i = e.parent;
        if (i.parent === null && e.offset === 0) return {done: !0, value: void 0};
        if (i == this._boundaryStartParent && e.offset == this.boundaries.start.offset) return {
            done: !0,
            value: void 0
        };
        let n;
        if (i.is("view:$text")) {
            if (e.isAtStart) return this._position = k._createBefore(i), this._previous();
            n = i.data[e.offset - 1]
        } else n = i.getChild(e.offset - 1);
        if (typeof n == "string") {
            let o;
            if (this.singleCharacters) o = 1; else {
                const a = i === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                o = e.offset - a
            }
            e.offset -= o;
            const r = new yt(i, e.offset, o);
            return this._position = e, this._formatReturnValue("text", r, t, e, o)
        }
        if (n && n.is("view:element")) return this.shallow ? (e.offset--, this._position = e, this._formatReturnValue("elementStart", n, t, e, 1)) : (e = new k(n, n.childCount), this._position = e, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", n, t, e));
        if (n && n.is("view:$text")) {
            if (this.singleCharacters) return e = new k(n, n.data.length), this._position = e, this._previous();
            let o = n.data.length, r;
            if (n == this._boundaryStartParent) {
                const a = this.boundaries.start.offset;
                r = new yt(n, a, n.data.length - a), o = r.data.length, e = k._createBefore(r)
            } else r = new yt(n, 0, n.data.length), e.offset--;
            return this._position = e, this._formatReturnValue("text", r, t, e, o)
        }
        return e = k._createBefore(i), this._position = e, this._formatReturnValue("elementStart", i, t, e, 1)
    }

    _formatReturnValue(e, t, i, n, o) {
        return t.is("view:$textProxy") && (t.offsetInText + t.data.length == t.textNode.data.length && (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position)) ? (n = k._createAfter(t.textNode), this._position = n) : i = k._createAfter(t.textNode)), t.offsetInText === 0 && (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position)) ? (n = k._createBefore(t.textNode), this._position = n) : i = k._createBefore(t.textNode))), {
            done: !1,
            value: {type: e, item: t, previousPosition: i, nextPosition: n, length: o}
        }
    }
}, k = class _t extends si {
    parent;
    offset;

    constructor(e, t) {
        super(), this.parent = e, this.offset = t
    }

    get nodeAfter() {
        return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null
    }

    get nodeBefore() {
        return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null
    }

    get isAtStart() {
        return this.offset === 0
    }

    get isAtEnd() {
        const e = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
        return this.offset === e
    }

    get root() {
        return this.parent.root
    }

    get editableElement() {
        let e = this.parent;
        for (; !(e instanceof Qs);) if (e.parent) e = e.parent; else return null;
        return e
    }

    getShiftedBy(e) {
        const t = _t._createAt(this), i = t.offset + e;
        return t.offset = i < 0 ? 0 : i, t
    }

    getLastMatchingPosition(e, t = {}) {
        t.startPosition = this;
        const i = new Yt(t);
        return i.skip(e), i.position
    }

    getAncestors() {
        return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({includeSelf: !0})
    }

    getCommonAncestor(e) {
        const t = this.getAncestors(), i = e.getAncestors();
        let n = 0;
        for (; t[n] == i[n] && t[n];) n++;
        return n === 0 ? null : t[n - 1]
    }

    isEqual(e) {
        return this.parent == e.parent && this.offset == e.offset
    }

    isBefore(e) {
        return this.compareWith(e) == "before"
    }

    isAfter(e) {
        return this.compareWith(e) == "after"
    }

    compareWith(e) {
        if (this.root !== e.root) return "different";
        if (this.isEqual(e)) return "same";
        const t = this.parent.is("node") ? this.parent.getPath() : [],
            i = e.parent.is("node") ? e.parent.getPath() : [];
        t.push(this.offset), i.push(e.offset);
        const n = _e(t, i);
        switch (n) {
            case"prefix":
                return "before";
            case"extension":
                return "after";
            default:
                return t[n] < i[n] ? "before" : "after"
        }
    }

    getWalker(e = {}) {
        return e.startPosition = this, new Yt(e)
    }

    clone() {
        return new _t(this.parent, this.offset)
    }

    static _createAt(e, t) {
        if (e instanceof _t) return new this(e.parent, e.offset);
        {
            const i = e;
            if (t == "end") t = i.is("$text") ? i.data.length : i.childCount; else {
                if (t == "before") return this._createBefore(i);
                if (t == "after") return this._createAfter(i);
                if (t !== 0 && !t) throw new p("view-createpositionat-offset-required", i)
            }
            return new _t(i, t)
        }
    }

    static _createAfter(e) {
        if (e.is("$textProxy")) return new _t(e.textNode, e.offsetInText + e.data.length);
        if (!e.parent) throw new p("view-position-after-root", e, {root: e});
        return new _t(e.parent, e.index + 1)
    }

    static _createBefore(e) {
        if (e.is("$textProxy")) return new _t(e.textNode, e.offsetInText);
        if (!e.parent) throw new p("view-position-before-root", e, {root: e});
        return new _t(e.parent, e.index)
    }
};
k.prototype.is = function (s) {
    return s === "position" || s === "view:position"
};
let B = class Ot extends si {
    start;
    end;

    constructor(e, t = null) {
        super(), this.start = e.clone(), this.end = t ? t.clone() : e.clone()
    }

    * [Symbol.iterator]() {
        yield* new Yt({boundaries: this, ignoreElementEnd: !0})
    }

    get isCollapsed() {
        return this.start.isEqual(this.end)
    }

    get isFlat() {
        return this.start.parent === this.end.parent
    }

    get root() {
        return this.start.root
    }

    getEnlarged() {
        let e = this.start.getLastMatchingPosition(Xn, {direction: "backward"}),
            t = this.end.getLastMatchingPosition(Xn);
        return e.parent.is("$text") && e.isAtStart && (e = k._createBefore(e.parent)), t.parent.is("$text") && t.isAtEnd && (t = k._createAfter(t.parent)), new Ot(e, t)
    }

    getTrimmed() {
        let e = this.start.getLastMatchingPosition(Xn);
        if (e.isAfter(this.end) || e.isEqual(this.end)) return new Ot(e, e);
        let t = this.end.getLastMatchingPosition(Xn, {direction: "backward"});
        const i = e.nodeAfter, n = t.nodeBefore;
        return i && i.is("$text") && (e = new k(i, 0)), n && n.is("$text") && (t = new k(n, n.data.length)), new Ot(e, t)
    }

    isEqual(e) {
        return this == e || this.start.isEqual(e.start) && this.end.isEqual(e.end)
    }

    containsPosition(e) {
        return e.isAfter(this.start) && e.isBefore(this.end)
    }

    containsRange(e, t = !1) {
        e.isCollapsed && (t = !1);
        const i = this.containsPosition(e.start) || t && this.start.isEqual(e.start),
            n = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
        return i && n
    }

    getDifference(e) {
        const t = [];
        return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new Ot(this.start, e.start)), this.containsPosition(e.end) && t.push(new Ot(e.end, this.end))) : t.push(this.clone()), t
    }

    getIntersection(e) {
        if (this.isIntersecting(e)) {
            let t = this.start, i = this.end;
            return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (i = e.end), new Ot(t, i)
        }
        return null
    }

    getWalker(e = {}) {
        return e.boundaries = this, new Yt(e)
    }

    getCommonAncestor() {
        return this.start.getCommonAncestor(this.end)
    }

    getContainedElement() {
        if (this.isCollapsed) return null;
        let e = this.start.nodeAfter, t = this.end.nodeBefore;
        return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (e = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (t = this.end.parent.previousSibling), e && e.is("element") && e === t ? e : null
    }

    clone() {
        return new Ot(this.start, this.end)
    }

    * getItems(e = {}) {
        e.boundaries = this, e.ignoreElementEnd = !0;
        const t = new Yt(e);
        for (const i of t) yield i.item
    }

    * getPositions(e = {}) {
        e.boundaries = this;
        const t = new Yt(e);
        yield t.position;
        for (const i of t) yield i.nextPosition
    }

    isIntersecting(e) {
        return this.start.isBefore(e.end) && this.end.isAfter(e.start)
    }

    static _createFromParentsAndOffsets(e, t, i, n) {
        return new this(new k(e, t), new k(i, n))
    }

    static _createFromPositionAndShift(e, t) {
        const i = e, n = e.getShiftedBy(t);
        return t > 0 ? new this(i, n) : new this(n, i)
    }

    static _createIn(e) {
        return this._createFromParentsAndOffsets(e, 0, e, e.childCount)
    }

    static _createOn(e) {
        const t = e.is("$textProxy") ? e.offsetSize : 1;
        return this._createFromPositionAndShift(k._createBefore(e), t)
    }
};
B.prototype.is = function (s) {
    return s === "range" || s === "view:range"
};

function Xn(s) {
    return !!(s.item.is("attributeElement") || s.item.is("uiElement"))
}

let Et = class vh extends W(si) {
    _ranges;
    _lastRangeBackward;
    _isFake;
    _fakeSelectionLabel;

    constructor(...e) {
        super(), this._ranges = [], this._lastRangeBackward = !1, this._isFake = !1, this._fakeSelectionLabel = "", e.length && this.setTo(...e)
    }

    get isFake() {
        return this._isFake
    }

    get fakeSelectionLabel() {
        return this._fakeSelectionLabel
    }

    get anchor() {
        if (!this._ranges.length) return null;
        const e = this._ranges[this._ranges.length - 1];
        return (this._lastRangeBackward ? e.end : e.start).clone()
    }

    get focus() {
        if (!this._ranges.length) return null;
        const e = this._ranges[this._ranges.length - 1];
        return (this._lastRangeBackward ? e.start : e.end).clone()
    }

    get isCollapsed() {
        return this.rangeCount === 1 && this._ranges[0].isCollapsed
    }

    get rangeCount() {
        return this._ranges.length
    }

    get isBackward() {
        return !this.isCollapsed && this._lastRangeBackward
    }

    get editableElement() {
        return this.anchor ? this.anchor.editableElement : null
    }

    * getRanges() {
        for (const e of this._ranges) yield e.clone()
    }

    getFirstRange() {
        let e = null;
        for (const t of this._ranges) (!e || t.start.isBefore(e.start)) && (e = t);
        return e ? e.clone() : null
    }

    getLastRange() {
        let e = null;
        for (const t of this._ranges) (!e || t.end.isAfter(e.end)) && (e = t);
        return e ? e.clone() : null
    }

    getFirstPosition() {
        const e = this.getFirstRange();
        return e ? e.start.clone() : null
    }

    getLastPosition() {
        const e = this.getLastRange();
        return e ? e.end.clone() : null
    }

    isEqual(e) {
        if (this.isFake != e.isFake || this.isFake && this.fakeSelectionLabel != e.fakeSelectionLabel || this.rangeCount != e.rangeCount) return !1;
        if (this.rangeCount === 0) return !0;
        if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus)) return !1;
        for (const t of this._ranges) {
            let i = !1;
            for (const n of e._ranges) if (t.isEqual(n)) {
                i = !0;
                break
            }
            if (!i) return !1
        }
        return !0
    }

    isSimilar(e) {
        if (this.isBackward != e.isBackward) return !1;
        const t = lr(this.getRanges()), i = lr(e.getRanges());
        if (t != i) return !1;
        if (t == 0) return !0;
        for (let n of this.getRanges()) {
            n = n.getTrimmed();
            let o = !1;
            for (let r of e.getRanges()) if (r = r.getTrimmed(), n.start.isEqual(r.start) && n.end.isEqual(r.end)) {
                o = !0;
                break
            }
            if (!o) return !1
        }
        return !0
    }

    getSelectedElement() {
        return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement()
    }

    setTo(...e) {
        let [t, i, n] = e;
        if (typeof i == "object" && (n = i, i = void 0), t === null) this._setRanges([]), this._setFakeOptions(n); else if (t instanceof vh || t instanceof sa) this._setRanges(t.getRanges(), t.isBackward), this._setFakeOptions({
            fake: t.isFake,
            label: t.fakeSelectionLabel
        }); else if (t instanceof B) this._setRanges([t], n && n.backward), this._setFakeOptions(n); else if (t instanceof k) this._setRanges([new B(t)]), this._setFakeOptions(n); else if (t instanceof oi) {
            const o = !!n && !!n.backward;
            let r;
            if (i === void 0) throw new p("view-selection-setto-required-second-parameter", this);
            i == "in" ? r = B._createIn(t) : i == "on" ? r = B._createOn(t) : r = new B(k._createAt(t, i)), this._setRanges([r], o), this._setFakeOptions(n)
        } else if (ze(t)) this._setRanges(t, n && n.backward), this._setFakeOptions(n); else throw new p("view-selection-setto-not-selectable", this);
        this.fire("change")
    }

    setFocus(e, t) {
        if (this.anchor === null) throw new p("view-selection-setfocus-no-ranges", this);
        const i = k._createAt(e, t);
        if (i.compareWith(this.focus) == "same") return;
        const n = this.anchor;
        this._ranges.pop(), i.compareWith(n) == "before" ? this._addRange(new B(i, n), !0) : this._addRange(new B(n, i)), this.fire("change")
    }

    _setRanges(e, t = !1) {
        e = Array.from(e), this._ranges = [];
        for (const i of e) this._addRange(i);
        this._lastRangeBackward = !!t
    }

    _setFakeOptions(e = {}) {
        this._isFake = !!e.fake, this._fakeSelectionLabel = e.fake && e.label || ""
    }

    _addRange(e, t = !1) {
        if (!(e instanceof B)) throw new p("view-selection-add-range-not-range", this);
        this._pushRange(e), this._lastRangeBackward = !!t
    }

    _pushRange(e) {
        for (const t of this._ranges) if (e.isIntersecting(t)) throw new p("view-selection-range-intersects", this, {
            addedRange: e,
            intersectingRange: t
        });
        this._ranges.push(new B(e.start, e.end))
    }
};
Et.prototype.is = function (s) {
    return s === "selection" || s === "view:selection"
};
let sa = class extends W(si) {
    _selection;

    constructor(...e) {
        super(), this._selection = new Et, this._selection.delegate("change").to(this), e.length && this._selection.setTo(...e)
    }

    get isFake() {
        return this._selection.isFake
    }

    get fakeSelectionLabel() {
        return this._selection.fakeSelectionLabel
    }

    get anchor() {
        return this._selection.anchor
    }

    get focus() {
        return this._selection.focus
    }

    get isCollapsed() {
        return this._selection.isCollapsed
    }

    get rangeCount() {
        return this._selection.rangeCount
    }

    get isBackward() {
        return this._selection.isBackward
    }

    get editableElement() {
        return this._selection.editableElement
    }

    get _ranges() {
        return this._selection._ranges
    }

    * getRanges() {
        yield* this._selection.getRanges()
    }

    getFirstRange() {
        return this._selection.getFirstRange()
    }

    getLastRange() {
        return this._selection.getLastRange()
    }

    getFirstPosition() {
        return this._selection.getFirstPosition()
    }

    getLastPosition() {
        return this._selection.getLastPosition()
    }

    getSelectedElement() {
        return this._selection.getSelectedElement()
    }

    isEqual(e) {
        return this._selection.isEqual(e)
    }

    isSimilar(e) {
        return this._selection.isSimilar(e)
    }

    _setTo(...e) {
        this._selection.setTo(...e)
    }

    _setFocus(e, t) {
        this._selection.setFocus(e, t)
    }
};
sa.prototype.is = function (s) {
    return s === "selection" || s == "documentSelection" || s == "view:selection" || s == "view:documentSelection"
};

class ri extends xt {
    startRange;
    _eventPhase;
    _currentTarget;

    constructor(e, t, i) {
        super(e, t), this.startRange = i, this._eventPhase = "none", this._currentTarget = null
    }

    get eventPhase() {
        return this._eventPhase
    }

    get currentTarget() {
        return this._currentTarget
    }
}

const ko = Symbol("bubbling contexts");

function hr(s) {
    class e extends s {
        fire(i, ...n) {
            try {
                const o = i instanceof xt ? i : new xt(this, i), r = Co(this);
                if (!r.size) return;
                if (nn(o, "capturing", this), gi(r, "$capture", o, ...n)) return o.return;
                const a = o.startRange || this.selection.getFirstRange(), l = a ? a.getContainedElement() : null,
                    c = l ? !!yh(r, l) : !1;
                let u = l || Fw(a);
                if (nn(o, "atTarget", u), !c) {
                    if (gi(r, "$text", o, ...n)) return o.return;
                    nn(o, "bubbling", u)
                }
                for (; u;) {
                    if (u.is("rootElement")) {
                        if (gi(r, "$root", o, ...n)) return o.return
                    } else if (u.is("element") && gi(r, u.name, o, ...n)) return o.return;
                    if (gi(r, u, o, ...n)) return o.return;
                    u = u.parent, nn(o, "bubbling", u)
                }
                return nn(o, "bubbling", this), gi(r, "$document", o, ...n), o.return
            } catch (o) {/* istanbul ignore next -- @preserve */
                p.rethrowUnexpectedError(o, this)
            }
        }

        _addEventListener(i, n, o) {
            const r = U(o.context || "$document"), a = Co(this);
            for (const l of r) {
                let c = a.get(l);
                c || (c = new (W()), a.set(l, c)), this.listenTo(c, i, n, o)
            }
        }

        _removeEventListener(i, n) {
            const o = Co(this);
            for (const r of o.values()) this.stopListening(r, i, n)
        }
    }

    return e
}

{
    const s = hr(Object);
    ["fire", "_addEventListener", "_removeEventListener"].forEach(e => {
        hr[e] = s.prototype[e]
    })
}

function nn(s, e, t) {
    s instanceof ri && (s._eventPhase = e, s._currentTarget = t)
}

function gi(s, e, t, ...i) {
    const n = typeof e == "string" ? s.get(e) : yh(s, e);
    return n ? (n.fire(t, ...i), t.stop.called) : !1
}

function yh(s, e) {
    for (const [t, i] of s) if (typeof t == "function" && t(e)) return i;
    return null
}

function Co(s) {
    return s[ko] || (s[ko] = new Map), s[ko]
}

function Fw(s) {
    if (!s) return null;
    const e = s.start.parent, t = s.end.parent, i = e.getPath(), n = t.getPath();
    return i.length > n.length ? e : t
}

let Ys = class extends hr(H()) {
    selection;
    roots;
    stylesProcessor;
    _postFixers = new Set;

    constructor(e) {
        super(), this.selection = new sa, this.roots = new ce({idProperty: "rootName"}), this.stylesProcessor = e, this.set("isReadOnly", !1), this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1)
    }

    getRoot(e = "main") {
        return this.roots.get(e)
    }

    registerPostFixer(e) {
        this._postFixers.add(e)
    }

    destroy() {
        this.roots.forEach(e => e.destroy()), this.stopListening()
    }

    _callPostFixers(e) {
        let t = !1;
        do for (const i of this._postFixers) if (t = i(e), t) break; while (t)
    }
};
const dl = 10;

class Li extends It {
    static DEFAULT_PRIORITY = dl;
    _priority = dl;
    _id = null;
    _clonesGroup = null;

    constructor(e, t, i, n) {
        super(e, t, i, n), this.getFillerOffset = Lw
    }

    get priority() {
        return this._priority
    }

    get id() {
        return this._id
    }

    getElementsWithSameId() {
        if (this.id === null) throw new p("attribute-element-get-elements-with-same-id-no-id", this);
        return new Set(this._clonesGroup)
    }

    isSimilar(e) {
        return this.id !== null || e.id !== null ? this.id === e.id : super.isSimilar(e) && this.priority == e.priority
    }

    _clone(e = !1) {
        const t = super._clone(e);
        return t._priority = this._priority, t._id = this._id, t
    }

    _canMergeAttributesFrom(e) {
        return this.id !== null || e.id !== null || this.priority !== e.priority ? !1 : super._canMergeAttributesFrom(e)
    }

    _canSubtractAttributesOf(e) {
        return this.id !== null || e.id !== null || this.priority !== e.priority ? !1 : super._canSubtractAttributesOf(e)
    }
}

Li.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "attributeElement" || s === "view:attributeElement" || s === "element" || s === "view:element") : s === "attributeElement" || s === "view:attributeElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
};

function Lw() {
    if (Eo(this)) return null;
    let s = this.parent;
    for (; s && s.is("attributeElement");) {
        if (Eo(s) > 1) return null;
        s = s.parent
    }
    return !s || Eo(s) > 1 ? null : this.childCount
}

function Eo(s) {
    return Array.from(s.getChildren()).filter(e => !e.is("uiElement")).length
}

class oa extends It {
    constructor(e, t, i, n) {
        super(e, t, i, n), this.getFillerOffset = Dw
    }

    _insertChild(e, t) {
        if (t && (t instanceof oi || Array.from(t).length > 0)) throw new p("view-emptyelement-cannot-add", [this, t]);
        return 0
    }
}

oa.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "emptyElement" || s === "view:emptyElement" || s === "element" || s === "view:element") : s === "emptyElement" || s === "view:emptyElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
};

function Dw() {
    return null
}

class Xs extends It {
    constructor(e, t, i, n) {
        super(e, t, i, n), this.getFillerOffset = zw
    }

    _insertChild(e, t) {
        if (t && (t instanceof oi || Array.from(t).length > 0)) throw new p("view-uielement-cannot-add", [this, t]);
        return 0
    }

    render(e, t) {
        return this.toDomElement(e)
    }

    toDomElement(e) {
        const t = e.createElement(this.name);
        for (const i of this.getAttributeKeys()) t.setAttribute(i, this.getAttribute(i));
        return t
    }
}

Xs.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "uiElement" || s === "view:uiElement" || s === "element" || s === "view:element") : s === "uiElement" || s === "view:uiElement" || s === "element" || s === "view:element" || s === "node" || s === "view:node"
};

function Nw(s) {
    s.document.on("arrowKey", (e, t) => Hw(e, t, s.domConverter), {priority: "low"})
}

function zw() {
    return null
}

function Hw(s, e, t) {
    if (e.keyCode == M.arrowright) {
        const i = e.domTarget.ownerDocument.defaultView.getSelection(),
            n = i.rangeCount == 1 && i.getRangeAt(0).collapsed;
        if (n || e.shiftKey) {
            const o = i.focusNode, r = i.focusOffset, a = t.domPositionToView(o, r);
            if (a === null) return;
            let l = !1;
            const c = a.getLastMatchingPosition(u => (u.item.is("uiElement") && (l = !0), !!(u.item.is("uiElement") || u.item.is("attributeElement"))));
            if (l) {
                const u = t.viewPositionToDom(c);
                n ? i.collapse(u.parent, u.offset) : i.extend(u.parent, u.offset)
            }
        }
    }
}

class ra extends It {
    constructor(e, t, i, n) {
        super(e, t, i, n), this.getFillerOffset = Uw
    }

    _insertChild(e, t) {
        if (t && (t instanceof oi || Array.from(t).length > 0)) throw new p("view-rawelement-cannot-add", [this, t]);
        return 0
    }

    render(e, t) {
    }
}

ra.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "rawElement" || s === "view:rawElement" || s === "element" || s === "view:element") : s === "rawElement" || s === "view:rawElement" || s === this.name || s === "view:" + this.name || s === "element" || s === "view:element" || s === "node" || s === "view:node"
};

function Uw() {
    return null
}

let Xt = class extends W(si) {
    document;
    _children = [];
    _customProperties = new Map;

    constructor(e, t) {
        super(), this.document = e, t && this._insertChild(0, t)
    }

    [Symbol.iterator]() {
        return this._children[Symbol.iterator]()
    }

    get childCount() {
        return this._children.length
    }

    get isEmpty() {
        return this.childCount === 0
    }

    get root() {
        return this
    }

    get parent() {
        return null
    }

    get name() {
    }

    get getFillerOffset() {
    }

    getCustomProperty(e) {
        return this._customProperties.get(e)
    }

    * getCustomProperties() {
        yield* this._customProperties.entries()
    }

    _appendChild(e) {
        return this._insertChild(this.childCount, e)
    }

    getChild(e) {
        return this._children[e]
    }

    getChildIndex(e) {
        return this._children.indexOf(e)
    }

    getChildren() {
        return this._children[Symbol.iterator]()
    }

    _insertChild(e, t) {
        this._fireChange("children", this, {index: e});
        let i = 0;
        const n = $w(this.document, t);
        for (const o of n) o.parent !== null && o._remove(), o.parent = this, this._children.splice(e, 0, o), e++, i++;
        return i
    }

    _removeChildren(e, t = 1) {
        this._fireChange("children", this, {index: e});
        for (let i = e; i < e + t; i++) this._children[i].parent = null;
        return this._children.splice(e, t)
    }

    _fireChange(e, t, i) {
        this.fire(`change:${e}`, t, i)
    }

    _setCustomProperty(e, t) {
        this._customProperties.set(e, t)
    }

    _removeCustomProperty(e) {
        return this._customProperties.delete(e)
    }
};
Xt.prototype.is = function (s) {
    return s === "documentFragment" || s === "view:documentFragment"
};

function $w(s, e) {
    return typeof e == "string" ? [new ge(s, e)] : (ze(e) || (e = [e]), Array.from(e).map(t => typeof t == "string" ? new ge(s, t) : t instanceof yt ? new ge(s, t.data) : t))
}

class kh {
    document;
    _cloneGroups = new Map;
    _slotFactory = null;

    constructor(e) {
        this.document = e
    }

    setSelection(...e) {
        this.document.selection._setTo(...e)
    }

    setSelectionFocus(e, t) {
        this.document.selection._setFocus(e, t)
    }

    createDocumentFragment(e) {
        return new Xt(this.document, e)
    }

    createText(e) {
        return new ge(this.document, e)
    }

    createAttributeElement(e, t, i = {}) {
        const n = new Li(this.document, e, t);
        return typeof i.priority == "number" && (n._priority = i.priority), i.id && (n._id = i.id), i.renderUnsafeAttributes && n._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), n
    }

    createContainerElement(e, t, i = {}, n = {}) {
        let o = null;
        Xe(i) ? n = i : o = i;
        const r = new An(this.document, e, t, o);
        return n.renderUnsafeAttributes && r._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), r
    }

    createEditableElement(e, t, i = {}) {
        const n = new Qs(this.document, e, t);
        return i.renderUnsafeAttributes && n._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), n
    }

    createEmptyElement(e, t, i = {}) {
        const n = new oa(this.document, e, t);
        return i.renderUnsafeAttributes && n._unsafeAttributesToRender.push(...i.renderUnsafeAttributes), n
    }

    createUIElement(e, t, i) {
        const n = new Xs(this.document, e, t);
        return i && (n.render = i), n
    }

    createRawElement(e, t, i, n = {}) {
        const o = new ra(this.document, e, t);
        return i && (o.render = i), n.renderUnsafeAttributes && o._unsafeAttributesToRender.push(...n.renderUnsafeAttributes), o
    }

    setAttribute(e, t, i, n) {
        n !== void 0 ? n._setAttribute(e, t, i) : i._setAttribute(e, t)
    }

    removeAttribute(e, t, i) {
        i !== void 0 ? i._removeAttribute(e, t) : t._removeAttribute(e)
    }

    addClass(e, t) {
        t._addClass(e)
    }

    removeClass(e, t) {
        t._removeClass(e)
    }

    setStyle(e, t, i) {
        Xe(e) && i === void 0 ? t._setStyle(e) : i._setStyle(e, t)
    }

    removeStyle(e, t) {
        t._removeStyle(e)
    }

    setCustomProperty(e, t, i) {
        i._setCustomProperty(e, t)
    }

    removeCustomProperty(e, t) {
        return t._removeCustomProperty(e)
    }

    breakAttributes(e) {
        return e instanceof k ? this._breakAttributes(e) : this._breakAttributesRange(e)
    }

    breakContainer(e) {
        const t = e.parent;
        if (!t.is("containerElement")) throw new p("view-writer-break-non-container-element", this.document);
        if (!t.parent) throw new p("view-writer-break-root", this.document);
        if (e.isAtStart) return k._createBefore(t);
        if (!e.isAtEnd) {
            const i = t._clone(!1);
            this.insert(k._createAfter(t), i);
            const n = new B(e, k._createAt(t, "end")), o = new k(i, 0);
            this.move(n, o)
        }
        return k._createAfter(t)
    }

    mergeAttributes(e) {
        const t = e.offset, i = e.parent;
        if (i.is("$text")) return e;
        if (i.is("attributeElement") && i.childCount === 0) {
            const r = i.parent, a = i.index;
            return i._remove(), this._removeFromClonedElementsGroup(i), this.mergeAttributes(new k(r, a))
        }
        const n = i.getChild(t - 1), o = i.getChild(t);
        if (!n || !o) return e;
        if (n.is("$text") && o.is("$text")) return fl(n, o);
        if (n.is("attributeElement") && o.is("attributeElement") && n.isSimilar(o)) {
            const r = n.childCount;
            return n._appendChild(o.getChildren()), o._remove(), this._removeFromClonedElementsGroup(o), this.mergeAttributes(new k(n, r))
        }
        return e
    }

    mergeContainers(e) {
        const t = e.nodeBefore, i = e.nodeAfter;
        if (!t || !i || !t.is("containerElement") || !i.is("containerElement")) throw new p("view-writer-merge-containers-invalid-position", this.document);
        const n = t.getChild(t.childCount - 1), o = n instanceof ge ? k._createAt(n, "end") : k._createAt(t, "end");
        return this.move(B._createIn(i), k._createAt(t, "end")), this.remove(B._createOn(i)), o
    }

    insert(e, t) {
        t = ze(t) ? [...t] : [t], Ch(t, this.document);
        const i = t.reduce((r, a) => {
            const l = r[r.length - 1], c = !a.is("uiElement");
            return !l || l.breakAttributes != c ? r.push({breakAttributes: c, nodes: [a]}) : l.nodes.push(a), r
        }, []);
        let n = null, o = e;
        for (const {nodes: r, breakAttributes: a} of i) {
            const l = this._insertNodes(o, r, a);
            n || (n = l.start), o = l.end
        }
        return n ? new B(n, o) : new B(e)
    }

    remove(e) {
        const t = e instanceof B ? e : B._createOn(e);
        if (sn(t, this.document), t.isCollapsed) return new Xt(this.document);
        const {start: i, end: n} = this._breakAttributesRange(t, !0), o = i.parent, r = n.offset - i.offset,
            a = o._removeChildren(i.offset, r);
        for (const c of a) this._removeFromClonedElementsGroup(c);
        const l = this.mergeAttributes(i);
        return t.start = l, t.end = l.clone(), new Xt(this.document, a)
    }

    clear(e, t) {
        sn(e, this.document);
        const i = e.getWalker({direction: "backward", ignoreElementEnd: !0});
        for (const n of i) {
            const o = n.item;
            let r;
            if (o.is("element") && t.isSimilar(o)) r = B._createOn(o); else if (!n.nextPosition.isAfter(e.start) && o.is("$textProxy")) {
                const a = o.getAncestors().find(l => l.is("element") && t.isSimilar(l));
                a && (r = B._createIn(a))
            }
            r && (r.end.isAfter(e.end) && (r.end = e.end), r.start.isBefore(e.start) && (r.start = e.start), this.remove(r))
        }
    }

    move(e, t) {
        let i;
        if (t.isAfter(e.end)) {
            t = this._breakAttributes(t, !0);
            const n = t.parent, o = n.childCount;
            e = this._breakAttributesRange(e, !0), i = this.remove(e), t.offset += n.childCount - o
        } else i = this.remove(e);
        return this.insert(t, i)
    }

    wrap(e, t) {
        if (!(t instanceof Li)) throw new p("view-writer-wrap-invalid-attribute", this.document);
        if (sn(e, this.document), e.isCollapsed) {
            let i = e.start;
            i.parent.is("element") && !Ww(i.parent) && (i = i.getLastMatchingPosition(o => o.item.is("uiElement"))), i = this._wrapPosition(i, t);
            const n = this.document.selection;
            return n.isCollapsed && n.getFirstPosition().isEqual(e.start) && this.setSelection(i), new B(i)
        } else return this._wrapRange(e, t)
    }

    unwrap(e, t) {
        if (!(t instanceof Li)) throw new p("view-writer-unwrap-invalid-attribute", this.document);
        if (sn(e, this.document), e.isCollapsed) return e;
        const {start: i, end: n} = this._breakAttributesRange(e, !0), o = i.parent,
            r = this._unwrapChildren(o, i.offset, n.offset, t), a = this.mergeAttributes(r.start);
        a.isEqual(r.start) || r.end.offset--;
        const l = this.mergeAttributes(r.end);
        return new B(a, l)
    }

    rename(e, t) {
        const i = new An(this.document, e, t.getAttributes());
        return this.insert(k._createAfter(t), i), this.move(B._createIn(t), k._createAt(i, 0)), this.remove(B._createOn(t)), i
    }

    clearClonedElementsGroup(e) {
        this._cloneGroups.delete(e)
    }

    createPositionAt(e, t) {
        return k._createAt(e, t)
    }

    createPositionAfter(e) {
        return k._createAfter(e)
    }

    createPositionBefore(e) {
        return k._createBefore(e)
    }

    createRange(e, t) {
        return new B(e, t)
    }

    createRangeOn(e) {
        return B._createOn(e)
    }

    createRangeIn(e) {
        return B._createIn(e)
    }

    createSelection(...e) {
        return new Et(...e)
    }

    createSlot(e = "children") {
        if (!this._slotFactory) throw new p("view-writer-invalid-create-slot-context", this.document);
        return this._slotFactory(this, e)
    }

    _registerSlotFactory(e) {
        this._slotFactory = e
    }

    _clearSlotFactory() {
        this._slotFactory = null
    }

    _insertNodes(e, t, i) {
        let n;
        if (i ? n = fr(e) : n = e.parent.is("$text") ? e.parent.parent : e.parent, !n) throw new p("view-writer-invalid-position-container", this.document);
        let o;
        i ? o = this._breakAttributes(e, !0) : o = e.parent.is("$text") ? To(e) : e;
        const r = n._insertChild(o.offset, t);
        for (const u of t) this._addToClonedElementsGroup(u);
        const a = o.getShiftedBy(r), l = this.mergeAttributes(o);
        l.isEqual(o) || a.offset--;
        const c = this.mergeAttributes(a);
        return new B(l, c)
    }

    _wrapChildren(e, t, i, n) {
        let o = t;
        const r = [];
        for (; o < i;) {
            const l = e.getChild(o), c = l.is("$text"), u = l.is("attributeElement");
            if (u && l._canMergeAttributesFrom(n)) l._mergeAttributesFrom(n), r.push(new k(e, o)); else if (c || !u || qw(n, l)) {
                const d = n._clone();
                l._remove(), d._appendChild(l), e._insertChild(o, d), this._addToClonedElementsGroup(d), r.push(new k(e, o))
            } else this._wrapChildren(l, 0, l.childCount, n);
            o++
        }
        let a = 0;
        for (const l of r) {
            if (l.offset -= a, l.offset == t) continue;
            this.mergeAttributes(l).isEqual(l) || (a++, i--)
        }
        return B._createFromParentsAndOffsets(e, t, e, i)
    }

    _unwrapChildren(e, t, i, n) {
        let o = t;
        const r = [];
        for (; o < i;) {
            const l = e.getChild(o);
            if (!l.is("attributeElement")) {
                o++;
                continue
            }
            if (l.isSimilar(n)) {
                const c = l.getChildren(), u = l.childCount;
                l._remove(), e._insertChild(o, c), this._removeFromClonedElementsGroup(l), r.push(new k(e, o), new k(e, o + u)), o += u, i += u - 1;
                continue
            }
            if (l._canSubtractAttributesOf(n)) {
                l._subtractAttributesOf(n), r.push(new k(e, o), new k(e, o + 1)), o++;
                continue
            }
            this._unwrapChildren(l, 0, l.childCount, n), o++
        }
        let a = 0;
        for (const l of r) {
            if (l.offset -= a, l.offset == t || l.offset == i) continue;
            this.mergeAttributes(l).isEqual(l) || (a++, i--)
        }
        return B._createFromParentsAndOffsets(e, t, e, i)
    }

    _wrapRange(e, t) {
        const {start: i, end: n} = this._breakAttributesRange(e, !0), o = i.parent,
            r = this._wrapChildren(o, i.offset, n.offset, t), a = this.mergeAttributes(r.start);
        a.isEqual(r.start) || r.end.offset--;
        const l = this.mergeAttributes(r.end);
        return new B(a, l)
    }

    _wrapPosition(e, t) {
        if (t.isSimilar(e.parent)) return hl(e.clone());
        e.parent.is("$text") && (e = To(e));
        const i = this.createAttributeElement("_wrapPosition-fake-element");
        i._priority = Number.POSITIVE_INFINITY, i.isSimilar = () => !1, e.parent._insertChild(e.offset, i);
        const n = new B(e, e.getShiftedBy(1));
        this.wrap(n, t);
        const o = new k(i.parent, i.index);
        i._remove();
        const r = o.nodeBefore, a = o.nodeAfter;
        return r && r.is("view:$text") && a && a.is("view:$text") ? fl(r, a) : hl(o)
    }

    _breakAttributesRange(e, t = !1) {
        const i = e.start, n = e.end;
        if (sn(e, this.document), e.isCollapsed) {
            const l = this._breakAttributes(e.start, t);
            return new B(l, l)
        }
        const o = this._breakAttributes(n, t), r = o.parent.childCount, a = this._breakAttributes(i, t);
        return o.offset += o.parent.childCount - r, new B(a, o)
    }

    _breakAttributes(e, t = !1) {
        const i = e.offset, n = e.parent;
        if (e.parent.is("emptyElement")) throw new p("view-writer-cannot-break-empty-element", this.document);
        if (e.parent.is("uiElement")) throw new p("view-writer-cannot-break-ui-element", this.document);
        if (e.parent.is("rawElement")) throw new p("view-writer-cannot-break-raw-element", this.document);
        if (!t && n.is("$text") && mr(n.parent) || mr(n)) return e.clone();
        if (n.is("$text")) return this._breakAttributes(To(e), t);
        const o = n.childCount;
        if (i == o) {
            const r = new k(n.parent, n.index + 1);
            return this._breakAttributes(r, t)
        } else if (i === 0) {
            const r = new k(n.parent, n.index);
            return this._breakAttributes(r, t)
        } else {
            const r = n.index + 1, a = n._clone();
            n.parent._insertChild(r, a), this._addToClonedElementsGroup(a);
            const l = n.childCount - i, c = n._removeChildren(i, l);
            a._appendChild(c);
            const u = new k(n.parent, r);
            return this._breakAttributes(u, t)
        }
    }

    _addToClonedElementsGroup(e) {
        if (!e.root.is("rootElement")) return;
        if (e.is("element")) for (const n of e.getChildren()) this._addToClonedElementsGroup(n);
        const t = e.id;
        if (!t) return;
        let i = this._cloneGroups.get(t);
        i || (i = new Set, this._cloneGroups.set(t, i)), i.add(e), e._clonesGroup = i
    }

    _removeFromClonedElementsGroup(e) {
        if (e.is("element")) for (const n of e.getChildren()) this._removeFromClonedElementsGroup(n);
        const t = e.id;
        if (!t) return;
        const i = this._cloneGroups.get(t);
        i && i.delete(e)
    }
}

function Ww(s) {
    return Array.from(s.getChildren()).some(e => !e.is("uiElement"))
}

function fr(s) {
    let e = s.parent;
    for (; !mr(e);) {
        if (!e) return;
        e = e.parent
    }
    return e
}

function qw(s, e) {
    return s.priority < e.priority ? !0 : s.priority > e.priority ? !1 : s.getIdentity() < e.getIdentity()
}

function hl(s) {
    const e = s.nodeBefore;
    if (e && e.is("$text")) return new k(e, e.data.length);
    const t = s.nodeAfter;
    return t && t.is("$text") ? new k(t, 0) : s
}

function To(s) {
    if (s.offset == s.parent.data.length) return new k(s.parent.parent, s.parent.index + 1);
    if (s.offset === 0) return new k(s.parent.parent, s.parent.index);
    const e = s.parent.data.slice(s.offset);
    return s.parent._data = s.parent.data.slice(0, s.offset), s.parent.parent._insertChild(s.parent.index + 1, new ge(s.root.document, e)), new k(s.parent.parent, s.parent.index + 1)
}

function fl(s, e) {
    const t = s.data.length;
    return s._data += e.data, e._remove(), new k(s, t)
}

const jw = [ge, Li, An, oa, ra, Xs];

function Ch(s, e) {
    for (const t of s) {
        if (!jw.some(i => t instanceof i)) throw new p("view-writer-insert-invalid-node-type", e);
        t.is("$text") || Ch(t.getChildren(), e)
    }
}

function mr(s) {
    return s && (s.is("containerElement") || s.is("documentFragment"))
}

function sn(s, e) {
    const t = fr(s.start), i = fr(s.end);
    if (!t || !i || t !== i) throw new p("view-writer-invalid-range-container", e)
}

const Eh = s => s.createTextNode(" "), Th = s => {
    const e = s.createElement("span");
    return e.dataset.ckeFiller = "true", e.innerText = " ", e
}, Ah = s => {
    const e = s.createElement("br");
    return e.dataset.ckeFiller = "true", e
}, De = 7, xn = "⁠".repeat(De);

function ke(s) {
    return typeof s == "string" ? s.substr(0, De) === xn : X(s) && s.data.substr(0, De) === xn
}

function Oi(s) {
    return s.data.length == De && ke(s)
}

function ml(s) {
    const e = typeof s == "string" ? s : s.data;
    return ke(s) ? e.slice(De) : e
}

function Gw(s) {
    s.document.on("arrowKey", Kw, {priority: "low"})
}

function Kw(s, e) {
    if (e.keyCode == M.arrowleft) {
        const t = e.domTarget.ownerDocument.defaultView.getSelection();
        if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const i = t.getRangeAt(0).startContainer, n = t.getRangeAt(0).startOffset;
            ke(i) && n <= De && t.collapse(i, 0)
        }
    }
}

class Zw extends H() {
    domDocuments = new Set;
    domConverter;
    markedAttributes = new Set;
    markedChildren = new Set;
    markedTexts = new Set;
    selection;
    _inlineFiller = null;
    _fakeSelectionContainer = null;

    constructor(e, t) {
        super(), this.domConverter = e, this.selection = t, this.set("isFocused", !1), this.set("isSelecting", !1), this.set("isComposing", !1), x.isBlink && !x.isAndroid && this.on("change:isSelecting", () => {
            this.isSelecting || this.render()
        })
    }

    markToSync(e, t) {
        if (e === "text") this.domConverter.mapViewToDom(t.parent) && this.markedTexts.add(t); else {
            if (!this.domConverter.mapViewToDom(t)) return;
            if (e === "attributes") this.markedAttributes.add(t); else if (e === "children") this.markedChildren.add(t); else throw new p("view-renderer-unknown-type", this)
        }
    }

    render() {
        if (this.isComposing && !x.isAndroid) return;
        let e = null;
        const t = x.isBlink && !x.isAndroid ? !this.isSelecting : !0;
        for (const i of this.markedChildren) this._updateChildrenMappings(i);
        t ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? e = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (e = this.selection.getFirstPosition(), this.markedChildren.add(e.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (e = this.domConverter.domPositionToView(this._inlineFiller), e && e.parent.is("$text") && (e = k._createBefore(e.parent)));
        for (const i of this.markedAttributes) this._updateAttrs(i);
        for (const i of this.markedChildren) this._updateChildren(i, {inlineFillerPosition: e});
        for (const i of this.markedTexts) !this.markedChildren.has(i.parent) && this.domConverter.mapViewToDom(i.parent) && this._updateText(i, {inlineFillerPosition: e});
        if (t) if (e) {
            const i = this.domConverter.viewPositionToDom(e), n = i.parent.ownerDocument;
            ke(i.parent) ? this._inlineFiller = i.parent : this._inlineFiller = gl(n, i.parent, i.offset)
        } else this._inlineFiller = null;
        this._updateFocus(), this._updateSelection(), this.domConverter._clearTemporaryCustomProperties(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear()
    }

    _updateChildrenMappings(e) {
        const t = this.domConverter.mapViewToDom(e);
        if (!t) return;
        const i = Array.from(t.childNodes), n = Array.from(this.domConverter.viewChildrenToDom(e, {withChildren: !1})),
            o = this._diffNodeLists(i, n), r = this._findUpdateActions(o, i, n, Qw);
        if (r.indexOf("update") !== -1) {
            const a = {equal: 0, insert: 0, delete: 0};
            for (const l of r) if (l === "update") {
                const c = a.equal + a.insert, u = a.equal + a.delete, d = e.getChild(c);
                d && !d.is("uiElement") && !d.is("rawElement") && this._updateElementMappings(d, i[u]), el(n[c]), a.equal++
            } else a[l]++
        }
    }

    _updateElementMappings(e, t) {
        this.domConverter.unbindDomElement(t), this.domConverter.bindElements(t, e), this.markedChildren.add(e), this.markedAttributes.add(e)
    }

    _getInlineFillerPosition() {
        const e = this.selection.getFirstPosition();
        return e.parent.is("$text") ? k._createBefore(e.parent) : e
    }

    _isSelectionInInlineFiller() {
        if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) return !1;
        const e = this.selection.getFirstPosition(), t = this.domConverter.viewPositionToDom(e);
        return !!(t && X(t.parent) && ke(t.parent))
    }

    _removeInlineFiller() {
        const e = this._inlineFiller;
        if (!ke(e)) throw new p("view-renderer-filler-was-lost", this);
        Oi(e) ? e.remove() : e.data = e.data.substr(De), this._inlineFiller = null
    }

    _needsInlineFillerAtSelection() {
        if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) return !1;
        const e = this.selection.getFirstPosition(), t = e.parent, i = e.offset;
        if (!this.domConverter.mapViewToDom(t.root) || !t.is("element") || !Jw(t)) return !1;
        const n = e.nodeBefore, o = e.nodeAfter;
        return !(n instanceof ge || o instanceof ge || i === t.getFillerOffset() && (!n || !n.is("element", "br")) || x.isAndroid && (n || o))
    }

    _updateText(e, t) {
        const i = this.domConverter.findCorrespondingDomText(e);
        let o = this.domConverter.viewToDom(e).data;
        const r = t.inlineFillerPosition;
        r && r.parent == e.parent && r.offset == e.index && (o = xn + o), this._updateTextNode(i, o)
    }

    _updateAttrs(e) {
        const t = this.domConverter.mapViewToDom(e);
        if (t) {
            for (const i of Array.from(t.attributes)) {
                const n = i.name;
                e.hasAttribute(n) || this.domConverter.removeDomElementAttribute(t, n)
            }
            for (const i of e.getAttributeKeys()) this.domConverter.setDomElementAttribute(t, i, e.getAttribute(i), e)
        }
    }

    _updateChildren(e, t) {
        const i = this.domConverter.mapViewToDom(e);
        if (!i) return;
        if (x.isAndroid) {
            let d = null;
            for (const h of Array.from(i.childNodes)) {
                if (d && X(d) && X(h)) {
                    i.normalize();
                    break
                }
                d = h
            }
        }
        const n = t.inlineFillerPosition, o = i.childNodes,
            r = Array.from(this.domConverter.viewChildrenToDom(e, {bind: !0}));
        n && n.parent === e && gl(i.ownerDocument, r, n.offset);
        const a = this._diffNodeLists(o, r), l = this._findUpdateActions(a, o, r, Yw);
        let c = 0;
        const u = new Set;
        for (const d of l) d === "delete" ? (u.add(o[c]), el(o[c])) : (d === "equal" || d === "update") && c++;
        c = 0;
        for (const d of l) d === "insert" ? (lh(i, c, r[c]), c++) : d === "update" ? (this._updateTextNode(o[c], r[c].data), c++) : d === "equal" && (this._markDescendantTextToSync(this.domConverter.domToView(r[c])), c++);
        for (const d of u) d.parentNode || this.domConverter.unbindDomElement(d)
    }

    _diffNodeLists(e, t) {
        return e = tb(e, this._fakeSelectionContainer), Bi(e, t, Xw.bind(null, this.domConverter))
    }

    _findUpdateActions(e, t, i, n) {
        if (e.indexOf("insert") === -1 || e.indexOf("delete") === -1) return e;
        let o = [], r = [], a = [];
        const l = {equal: 0, insert: 0, delete: 0};
        for (const c of e) c === "insert" ? a.push(i[l.equal + l.insert]) : c === "delete" ? r.push(t[l.equal + l.delete]) : (o = o.concat(Bi(r, a, n).map(u => u === "equal" ? "update" : u)), o.push("equal"), r = [], a = []), l[c]++;
        return o.concat(Bi(r, a, n).map(c => c === "equal" ? "update" : c))
    }

    _updateTextNode(e, t) {
        const i = e.data;
        i != t && (x.isAndroid && this.isComposing && i.replace(/\u00A0/g, " ") == t.replace(/\u00A0/g, " ") || this._updateTextNodeInternal(e, t))
    }

    _updateTextNodeInternal(e, t) {
        const i = qd(e.data, t);
        for (const n of i) n.type === "insert" ? e.insertData(n.index, n.values.join("")) : e.deleteData(n.index, n.howMany)
    }

    _markDescendantTextToSync(e) {
        if (e) {
            if (e.is("$text")) this.markedTexts.add(e); else if (e.is("element")) for (const t of e.getChildren()) this._markDescendantTextToSync(t)
        }
    }

    _updateSelection() {
        if (x.isBlink && !x.isAndroid && this.isSelecting && !this.markedChildren.size) return;
        if (this.selection.rangeCount === 0) {
            this._removeDomSelection(), this._removeFakeSelection();
            return
        }
        const e = this.domConverter.mapViewToDom(this.selection.editableElement);
        if (!this.isFocused || !e) {
            !this.selection.isFake && this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected && this._removeFakeSelection();
            return
        }
        this.selection.isFake ? this._updateFakeSelection(e) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(e)) : this.isComposing && x.isAndroid || this._updateDomSelection(e)
    }

    _updateFakeSelection(e) {
        const t = e.ownerDocument;
        this._fakeSelectionContainer || (this._fakeSelectionContainer = ib(t));
        const i = this._fakeSelectionContainer;
        if (this.domConverter.bindFakeSelection(i, this.selection), !this._fakeSelectionNeedsUpdate(e)) return;
        (!i.parentElement || i.parentElement != e) && e.appendChild(i), i.textContent = this.selection.fakeSelectionLabel || " ";
        const n = t.getSelection(), o = t.createRange();
        n.removeAllRanges(), o.selectNodeContents(i), n.addRange(o)
    }

    _updateDomSelection(e) {
        const t = e.ownerDocument.defaultView.getSelection();
        if (!this._domSelectionNeedsUpdate(t)) return;
        const i = this.domConverter.viewPositionToDom(this.selection.anchor),
            n = this.domConverter.viewPositionToDom(this.selection.focus);
        t.setBaseAndExtent(i.parent, i.offset, n.parent, n.offset), x.isGecko && eb(n, t)
    }

    _domSelectionNeedsUpdate(e) {
        if (!this.domConverter.isDomSelectionCorrect(e)) return !0;
        const t = e && this.domConverter.domSelectionToView(e);
        return !(t && this.selection.isEqual(t) || !this.selection.isCollapsed && this.selection.isSimilar(t))
    }

    _fakeSelectionNeedsUpdate(e) {
        const t = this._fakeSelectionContainer, i = e.ownerDocument.getSelection();
        return !t || t.parentElement !== e || i.anchorNode !== t && !t.contains(i.anchorNode) ? !0 : t.textContent !== this.selection.fakeSelectionLabel
    }

    _removeDomSelection() {
        for (const e of this.domDocuments) {
            const t = e.getSelection();
            if (t.rangeCount) {
                const i = e.activeElement, n = this.domConverter.mapDomToView(i);
                i && n && t.removeAllRanges()
            }
        }
    }

    _removeFakeSelection() {
        const e = this._fakeSelectionContainer;
        e && e.remove()
    }

    _updateFocus() {
        if (this.isFocused) {
            const e = this.selection.editableElement;
            e && this.domConverter.focus(e)
        }
    }
}

function Jw(s) {
    if (s.getAttribute("contenteditable") == "false") return !1;
    const e = s.findAncestor(t => t.hasAttribute("contenteditable"));
    return !e || e.getAttribute("contenteditable") == "true"
}

function gl(s, e, t) {
    const i = e instanceof Array ? e : e.childNodes, n = i[t];
    if (X(n)) return n.data = xn + n.data, n;
    {
        const o = s.createTextNode(xn);
        return Array.isArray(e) ? i.splice(t, 0, o) : lh(e, t, o), o
    }
}

function Qw(s, e) {
    return zt(s) && zt(e) && !X(s) && !X(e) && !vn(s) && !vn(e) && s.tagName.toLowerCase() === e.tagName.toLowerCase()
}

function Yw(s, e) {
    return zt(s) && zt(e) && X(s) && X(e)
}

function Xw(s, e, t) {
    return e === t ? !0 : X(e) && X(t) ? e.data === t.data : !!(s.isBlockFiller(e) && s.isBlockFiller(t))
}

function eb(s, e) {
    let t = s.parent, i = s.offset;
    if (X(t) && Oi(t) && (i = Vi(t) + 1, t = t.parentNode), t.nodeType != Node.ELEMENT_NODE || i != t.childNodes.length - 1) return;
    const n = t.childNodes[i];
    n && n.tagName == "BR" && e.addRange(e.getRangeAt(0))
}

function tb(s, e) {
    const t = Array.from(s);
    return t.length == 0 || !e || t[t.length - 1] == e && t.pop(), t
}

function ib(s) {
    const e = s.createElement("div");
    return e.className = "ck-fake-selection-container", Object.assign(e.style, {
        position: "fixed",
        top: 0,
        left: "-9999px",
        width: "42px"
    }), e.textContent = " ", e
}

const nb = Ah(C.document), sb = Eh(C.document), ob = Th(C.document), es = "data-ck-unsafe-attribute-",
    pl = "data-ck-unsafe-element";

class eo {
    document;
    renderingMode;
    blockFillerMode;
    preElements;
    blockElements;
    inlineObjectElements;
    unsafeElements;
    _domDocument;
    _domToViewMapping = new WeakMap;
    _viewToDomMapping = new WeakMap;
    _fakeSelectionMapping = new WeakMap;
    _rawContentElementMatcher = new He;
    _inlineObjectElementMatcher = new He;
    _elementsWithTemporaryCustomProperties = new Set;

    constructor(e, {blockFillerMode: t, renderingMode: i = "editing"} = {}) {
        this.document = e, this.renderingMode = i, this.blockFillerMode = t || (i === "editing" ? "br" : "nbsp"), this.preElements = ["pre", "textarea"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = this.renderingMode === "editing" ? C.document : C.document.implementation.createHTMLDocument("")
    }

    get domDocument() {
        return this._domDocument
    }

    bindFakeSelection(e, t) {
        this._fakeSelectionMapping.set(e, new Et(t))
    }

    fakeSelectionToView(e) {
        return this._fakeSelectionMapping.get(e)
    }

    bindElements(e, t) {
        this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e)
    }

    unbindDomElement(e) {
        const t = this._domToViewMapping.get(e);
        if (t) {
            this._domToViewMapping.delete(e), this._viewToDomMapping.delete(t);
            for (const i of e.children) this.unbindDomElement(i)
        }
    }

    bindDocumentFragments(e, t) {
        this._domToViewMapping.set(e, t), this._viewToDomMapping.set(t, e)
    }

    shouldRenderAttribute(e, t, i) {
        return this.renderingMode === "data" ? !0 : (e = e.toLowerCase(), e.startsWith("on") || e === "srcdoc" && t.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i) ? !1 : i === "img" && (e === "src" || e === "srcset") || i === "source" && e === "srcset" ? !0 : !t.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i))
    }

    setContentOf(e, t) {
        if (this.renderingMode === "data") {
            e.innerHTML = t;
            return
        }
        const i = new DOMParser().parseFromString(t, "text/html"), n = i.createDocumentFragment(),
            o = i.body.childNodes;
        for (; o.length > 0;) n.appendChild(o[0]);
        const r = i.createTreeWalker(n, NodeFilter.SHOW_ELEMENT), a = [];
        let l;
        for (; l = r.nextNode();) a.push(l);
        for (const c of a) {
            for (const d of c.getAttributeNames()) this.setDomElementAttribute(c, d, c.getAttribute(d));
            const u = c.tagName.toLowerCase();
            this._shouldRenameElement(u) && (vl(u), c.replaceWith(this._createReplacementDomElement(u, c)))
        }
        for (; e.firstChild;) e.firstChild.remove();
        e.append(n)
    }

    viewToDom(e, t = {}) {
        if (e.is("$text")) {
            const i = this._processDataFromViewText(e);
            return this._domDocument.createTextNode(i)
        } else {
            const i = e;
            if (this.mapViewToDom(i)) if (i.getCustomProperty("editingPipeline:doNotReuseOnce")) this._elementsWithTemporaryCustomProperties.add(i); else return this.mapViewToDom(i);
            let n;
            if (i.is("documentFragment")) n = this._domDocument.createDocumentFragment(), t.bind && this.bindDocumentFragments(n, i); else {
                if (i.is("uiElement")) return i.name === "$comment" ? n = this._domDocument.createComment(i.getCustomProperty("$rawContent")) : n = i.render(this._domDocument, this), t.bind && this.bindElements(n, i), n;
                this._shouldRenameElement(i.name) ? (vl(i.name), n = this._createReplacementDomElement(i.name)) : i.hasAttribute("xmlns") ? n = this._domDocument.createElementNS(i.getAttribute("xmlns"), i.name) : n = this._domDocument.createElement(i.name), i.is("rawElement") && i.render(n, this), t.bind && this.bindElements(n, i);
                for (const o of i.getAttributeKeys()) this.setDomElementAttribute(n, o, i.getAttribute(o), i)
            }
            if (t.withChildren !== !1) for (const o of this.viewChildrenToDom(i, t)) n instanceof HTMLTemplateElement ? n.content.appendChild(o) : n.appendChild(o);
            return n
        }
    }

    setDomElementAttribute(e, t, i, n) {
        const o = this.shouldRenderAttribute(t, i, e.tagName.toLowerCase()) || n && n.shouldRenderUnsafeAttribute(t);
        if (o || L("domconverter-unsafe-attribute-detected", {domElement: e, key: t, value: i}), !ch(t)) {
            L("domconverter-invalid-attribute-detected", {domElement: e, key: t, value: i});
            return
        }
        e.hasAttribute(t) && !o ? e.removeAttribute(t) : e.hasAttribute(es + t) && o && e.removeAttribute(es + t), e.setAttribute(o ? t : es + t, i)
    }

    removeDomElementAttribute(e, t) {
        t != pl && (e.removeAttribute(t), e.removeAttribute(es + t))
    }

    * viewChildrenToDom(e, t = {}) {
        const i = e.getFillerOffset && e.getFillerOffset();
        let n = 0;
        for (const o of e.getChildren()) {
            i === n && (yield this._getBlockFiller());
            const r = o.is("element") && !!o.getCustomProperty("dataPipeline:transparentRendering") && !re(o.getAttributes());
            if (r && this.renderingMode == "data") if (o.is("rawElement")) {
                const a = this._domDocument.createElement(o.name);
                o.render(a, this), yield* [...a.childNodes]
            } else yield* this.viewChildrenToDom(o, t); else r && L("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {viewElement: o}), yield this.viewToDom(o, t);
            n++
        }
        i === n && (yield this._getBlockFiller())
    }

    viewRangeToDom(e) {
        const t = this.viewPositionToDom(e.start), i = this.viewPositionToDom(e.end),
            n = this._domDocument.createRange();
        return n.setStart(t.parent, t.offset), n.setEnd(i.parent, i.offset), n
    }

    viewPositionToDom(e) {
        const t = e.parent;
        if (t.is("$text")) {
            const i = this.findCorrespondingDomText(t);
            if (!i) return null;
            let n = e.offset;
            return ke(i) && (n += De), i.data && n > i.data.length && (n = i.data.length), {parent: i, offset: n}
        } else {
            let i, n, o;
            if (e.offset === 0) {
                if (i = this.mapViewToDom(t), !i) return null;
                o = i.childNodes[0]
            } else {
                const a = e.nodeBefore;
                if (n = a.is("$text") ? this.findCorrespondingDomText(a) : this.mapViewToDom(a), !n) return null;
                i = n.parentNode, o = n.nextSibling
            }
            if (X(o) && ke(o)) return {parent: o, offset: De};
            const r = n ? Vi(n) + 1 : 0;
            return {parent: i, offset: r}
        }
    }

    domToView(e, t = {}) {
        const i = [], n = this._domToView(e, t, i), o = n.next().value;
        return !o || (n.next(), this._processDomInlineNodes(null, i, t), this.blockFillerMode == "br" && bl(o)) || o.is("$text") && o.data.length == 0 ? null : o
    }

    * domChildrenToView(e, t = {}, i = []) {
        let n = [];
        e instanceof HTMLTemplateElement ? n = [...e.content.childNodes] : n = [...e.childNodes];
        for (let o = 0; o < n.length; o++) {
            const r = n[o], a = this._domToView(r, t, i), l = a.next().value;
            l !== null && (this._isBlockViewElement(l) && this._processDomInlineNodes(e, i, t), this.blockFillerMode == "br" && bl(l) || (yield l), a.next())
        }
        this._processDomInlineNodes(e, i, t)
    }

    domSelectionToView(e) {
        if (ub(e)) return new Et([]);
        if (e.rangeCount === 1) {
            let n = e.getRangeAt(0).startContainer;
            X(n) && (n = n.parentNode);
            const o = this.fakeSelectionToView(n);
            if (o) return o
        }
        const t = this.isDomSelectionBackward(e), i = [];
        for (let n = 0; n < e.rangeCount; n++) {
            const o = e.getRangeAt(n), r = this.domRangeToView(o);
            r && i.push(r)
        }
        return new Et(i, {backward: t})
    }

    domRangeToView(e) {
        const t = this.domPositionToView(e.startContainer, e.startOffset),
            i = this.domPositionToView(e.endContainer, e.endOffset);
        return t && i ? new B(t, i) : null
    }

    domPositionToView(e, t = 0) {
        if (this.isBlockFiller(e)) return this.domPositionToView(e.parentNode, Vi(e));
        const i = this.mapDomToView(e);
        if (i && (i.is("uiElement") || i.is("rawElement"))) return k._createBefore(i);
        if (X(e)) {
            if (Oi(e)) return this.domPositionToView(e.parentNode, Vi(e));
            const n = this.findCorrespondingViewText(e);
            let o = t;
            return n ? (ke(e) && (o -= De, o = o < 0 ? 0 : o), new k(n, o)) : null
        } else {
            if (t === 0) {
                const n = this.mapDomToView(e);
                if (n) return new k(n, 0)
            } else {
                const n = e.childNodes[t - 1];
                if (X(n) && Oi(n) || n && this.isBlockFiller(n)) return this.domPositionToView(n.parentNode, Vi(n));
                const o = X(n) ? this.findCorrespondingViewText(n) : this.mapDomToView(n);
                if (o && o.parent) return new k(o.parent, o.index + 1)
            }
            return null
        }
    }

    mapDomToView(e) {
        return this.getHostViewElement(e) || this._domToViewMapping.get(e)
    }

    findCorrespondingViewText(e) {
        if (Oi(e)) return null;
        const t = this.getHostViewElement(e);
        if (t) return t;
        const i = e.previousSibling;
        if (i) {
            if (!this.isElement(i)) return null;
            const n = this.mapDomToView(i);
            if (n) {
                const o = n.nextSibling;
                return o instanceof ge ? o : null
            }
        } else {
            const n = this.mapDomToView(e.parentNode);
            if (n) {
                const o = n.getChild(0);
                return o instanceof ge ? o : null
            }
        }
        return null
    }

    mapViewToDom(e) {
        return this._viewToDomMapping.get(e)
    }

    findCorrespondingDomText(e) {
        const t = e.previousSibling;
        return t && this.mapViewToDom(t) ? this.mapViewToDom(t).nextSibling : !t && e.parent && this.mapViewToDom(e.parent) ? this.mapViewToDom(e.parent).childNodes[0] : null
    }

    focus(e) {
        const t = this.mapViewToDom(e);
        if (!t || t.ownerDocument.activeElement === t) return;
        const {scrollX: i, scrollY: n} = C.window, o = [];
        wl(t, r => {
            const {scrollLeft: a, scrollTop: l} = r;
            o.push([a, l])
        }), t.focus(), wl(t, r => {
            const [a, l] = o.shift();
            r.scrollLeft = a, r.scrollTop = l
        }), C.window.scrollTo(i, n)
    }

    _clearDomSelection() {
        const e = this.mapViewToDom(this.document.selection.editableElement);
        if (!e) return;
        const t = e.ownerDocument.defaultView.getSelection(), i = this.domSelectionToView(t);
        i && i.rangeCount > 0 && t.removeAllRanges()
    }

    isElement(e) {
        return e && e.nodeType == Node.ELEMENT_NODE
    }

    isDocumentFragment(e) {
        return e && e.nodeType == Node.DOCUMENT_FRAGMENT_NODE
    }

    isBlockFiller(e) {
        return this.blockFillerMode == "br" ? e.isEqualNode(nb) : _l(e, this.blockElements) ? !0 : e.isEqualNode(ob) || ab(e, this.blockElements)
    }

    isDomSelectionBackward(e) {
        if (e.isCollapsed) return !1;
        const t = this._domDocument.createRange();
        try {
            t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset)
        } catch {
            return !1
        }
        const i = t.collapsed;
        return t.detach(), i
    }

    getHostViewElement(e) {
        const t = Dp(e);
        for (t.pop(); t.length;) {
            const i = t.pop(), n = this._domToViewMapping.get(i);
            if (n && (n.is("uiElement") || n.is("rawElement"))) return n
        }
        return null
    }

    isDomSelectionCorrect(e) {
        return this._isDomSelectionPositionCorrect(e.anchorNode, e.anchorOffset) && this._isDomSelectionPositionCorrect(e.focusNode, e.focusOffset)
    }

    registerRawContentMatcher(e) {
        this._rawContentElementMatcher.add(e)
    }

    registerInlineObjectMatcher(e) {
        this._inlineObjectElementMatcher.add(e)
    }

    _clearTemporaryCustomProperties() {
        for (const e of this._elementsWithTemporaryCustomProperties) e._removeCustomProperty("editingPipeline:doNotReuseOnce");
        this._elementsWithTemporaryCustomProperties.clear()
    }

    _getBlockFiller() {
        switch (this.blockFillerMode) {
            case"nbsp":
                return Eh(this._domDocument);
            case"markedNbsp":
                return Th(this._domDocument);
            case"br":
                return Ah(this._domDocument)
        }
    }

    _isDomSelectionPositionCorrect(e, t) {
        if (X(e) && ke(e) && t < De || this.isElement(e) && ke(e.childNodes[t])) return !1;
        const i = this.mapDomToView(e);
        return !(i && (i.is("uiElement") || i.is("rawElement")))
    }

    * _domToView(e, t, i) {
        if (this.blockFillerMode != "br" && _l(e, this.blockElements)) return null;
        const n = this.getHostViewElement(e);
        if (n) return n;
        if (vn(e) && t.skipComments) return null;
        if (X(e)) {
            if (Oi(e)) return null;
            {
                const o = e.data;
                if (o === "") return null;
                const r = new ge(this.document, o);
                return i.push(r), r
            }
        } else {
            let o = this.mapDomToView(e);
            if (o) return this._isInlineObjectElement(o) && i.push(o), o;
            if (this.isDocumentFragment(e)) o = new Xt(this.document), t.bind && this.bindDocumentFragments(e, o); else {
                o = this._createViewElement(e, t), t.bind && this.bindElements(e, o);
                const a = e.attributes;
                if (a) for (let l = a.length, c = 0; c < l; c++) o._setAttribute(a[c].name, a[c].value);
                if (this._isViewElementWithRawContent(o, t)) return o._setCustomProperty("$rawContent", e.innerHTML), this._isBlockViewElement(o) || i.push(o), o;
                if (vn(e)) return o._setCustomProperty("$rawContent", e.data), o
            }
            yield o;
            const r = [];
            if (t.withChildren !== !1) for (const a of this.domChildrenToView(e, t, r)) o._appendChild(a);
            if (this._isInlineObjectElement(o)) i.push(o), this._processDomInlineNodes(null, r, t); else for (const a of r) i.push(a)
        }
    }

    _processDomInlineNodes(e, t, i) {
        if (!t.length || e && !this.isDocumentFragment(e) && !this._isBlockDomElement(e)) return;
        let n = !1;
        for (let o = 0; o < t.length; o++) {
            const r = t[o];
            if (!r.is("$text")) {
                n = !1;
                continue
            }
            let a, l = !1;
            if (this._isPreFormatted(r)) a = ml(r.data); else {
                a = r.data.replace(/[ \n\t\r]{1,}/g, " "), l = /[^\S\u00A0]/.test(a.charAt(a.length - 1));
                const c = o > 0 ? t[o - 1] : null, u = o + 1 < t.length ? t[o + 1] : null,
                    d = !c || c.is("element") && c.name == "br" || n, h = u ? !1 : !ke(r.data);
                i.withChildren !== !1 && (d && (a = a.replace(/^ /, "")), h && (a = a.replace(/ $/, ""))), a = ml(a), this.blockFillerMode != "br" && r.parent && (cb(r.parent, a) ? (a = "", r.parent.parent && (r.parent.parent._setCustomProperty("$hasBlockFiller", !0), r.parent._remove())) : lb(r.parent, a, this.blockElements) && (a = "", r.parent._setCustomProperty("$hasBlockFiller", !0))), a = a.replace(/ \u00A0/g, "  ");
                const f = u && u.is("element") && u.name != "br", m = u && u.is("$text") && u.data.charAt(0) == " ";
                (/[ \u00A0]\u00A0$/.test(a) || !u || f || m) && (a = a.replace(/\u00A0$/, " ")), (d || c && c.is("element") && c.name != "br") && (a = a.replace(/^\u00A0/, " "))
            }
            a.length == 0 && r.parent ? (r._remove(), t.splice(o, 1), o--) : (r._data = a, n = l)
        }
        t.length = 0
    }

    _processDataFromViewText(e) {
        let t = e.data;
        if (this._isPreFormatted(e)) return t;
        if (t.charAt(0) == " ") {
            const i = this._getTouchingInlineViewNode(e, !1);
            (i && i.is("$textProxy") && this._nodeEndsWithSpace(i) || !i) && (t = " " + t.substr(1))
        }
        if (t.charAt(t.length - 1) == " ") {
            const i = this._getTouchingInlineViewNode(e, !0), n = i && i.is("$textProxy") && i.data.charAt(0) == " ";
            (t.charAt(t.length - 2) == " " || !i || n) && (t = t.substr(0, t.length - 1) + " ")
        }
        return t.replace(/ {2}/g, "  ")
    }

    _nodeEndsWithSpace(e) {
        if (this._isPreFormatted(e)) return !1;
        const t = this._processDataFromViewText(e);
        return t.charAt(t.length - 1) == " "
    }

    _isPreFormatted(e) {
        if (rb(e, this.preElements)) return !0;
        for (const t of e.getAncestors({parentFirst: !0})) if (!(!t.is("element") || !t.hasStyle("white-space") || t.getStyle("white-space") === "inherit")) return ["pre", "pre-wrap", "break-spaces"].includes(t.getStyle("white-space"));
        return !1
    }

    _getTouchingInlineViewNode(e, t) {
        const i = new Yt({
            startPosition: t ? k._createAfter(e) : k._createBefore(e),
            direction: t ? "forward" : "backward"
        });
        for (const {item: n} of i) {
            if (n.is("$textProxy")) return n;
            if (n.is("element") && n.getCustomProperty("dataPipeline:transparentRendering")) continue;
            if (n.is("element", "br")) return null;
            if (this._isInlineObjectElement(n)) return n;
            if (n.is("containerElement")) return null
        }
        return null
    }

    _isBlockDomElement(e) {
        return this.isElement(e) && this.blockElements.includes(e.tagName.toLowerCase())
    }

    _isBlockViewElement(e) {
        return e.is("element") && this.blockElements.includes(e.name)
    }

    _isInlineObjectElement(e) {
        return e.is("element") ? e.name == "br" || this.inlineObjectElements.includes(e.name) || !!this._inlineObjectElementMatcher.match(e) : !1
    }

    _createViewElement(e, t) {
        if (vn(e)) return new Xs(this.document, "$comment");
        const i = t.keepOriginalCase ? e.tagName : e.tagName.toLowerCase();
        return new It(this.document, i)
    }

    _isViewElementWithRawContent(e, t) {
        return t.withChildren !== !1 && e.is("element") && !!this._rawContentElementMatcher.match(e)
    }

    _shouldRenameElement(e) {
        const t = e.toLowerCase();
        return this.renderingMode === "editing" && this.unsafeElements.includes(t)
    }

    _createReplacementDomElement(e, t) {
        const i = this._domDocument.createElement("span");
        if (i.setAttribute(pl, e), t) {
            for (; t.firstChild;) i.appendChild(t.firstChild);
            for (const n of t.getAttributeNames()) i.setAttribute(n, t.getAttribute(n))
        }
        return i
    }
}

function rb(s, e) {
    return s.getAncestors().some(t => t.is("element") && e.includes(t.name))
}

function wl(s, e) {
    let t = s;
    for (; t;) e(t), t = t.parentElement
}

function ab(s, e) {
    return s.isEqualNode(sb) && xh(s, e) && s.parentNode.childNodes.length === 1
}

function xh(s, e) {
    const t = s.parentNode;
    return !!t && !!t.tagName && e.includes(t.tagName.toLowerCase())
}

function lb(s, e, t) {
    return e == " " && s && s.is("element") && s.childCount == 1 && t.includes(s.name)
}

function cb(s, e) {
    return e == " " && s && s.is("element", "span") && s.childCount == 1 && s.hasAttribute("data-cke-filler")
}

function bl(s) {
    return s.is("element", "br") && s.hasAttribute("data-cke-filler")
}

function _l(s, e) {
    return s.tagName === "BR" && xh(s, e) && s.parentNode.childNodes.length === 1
}

function vl(s) {
    s === "script" && L("domconverter-unsafe-script-element-detected"), s === "style" && L("domconverter-unsafe-style-element-detected")
}

function ub(s) {
    if (!x.isGecko || !s.rangeCount) return !1;
    const e = s.getRangeAt(0).startContainer;
    try {
        Object.prototype.toString.call(e)
    } catch {
        return !0
    }
    return !1
}

class gt extends xe() {
    view;
    document;
    _isEnabled = !1;

    constructor(e) {
        super(), this.view = e, this.document = e.document
    }

    get isEnabled() {
        return this._isEnabled
    }

    enable() {
        this._isEnabled = !0
    }

    disable() {
        this._isEnabled = !1
    }

    destroy() {
        this.disable(), this.stopListening()
    }

    checkShouldIgnoreEventFromTarget(e) {
        return e && e.nodeType === 3 && (e = e.parentNode), !e || e.nodeType !== 1 ? !1 : e.matches("[data-cke-ignore-events], [data-cke-ignore-events] *")
    }
}

class ei {
    view;
    document;
    domEvent;
    domTarget;

    constructor(e, t, i) {
        this.view = e, this.document = e.document, this.domEvent = t, this.domTarget = t.target, Hd(this, i)
    }

    get target() {
        return this.view.domConverter.mapDomToView(this.domTarget)
    }

    preventDefault() {
        this.domEvent.preventDefault()
    }

    stopPropagation() {
        this.domEvent.stopPropagation()
    }
}

class Pt extends gt {
    useCapture = !1;
    usePassive = !1;

    observe(e) {
        (typeof this.domEventType == "string" ? [this.domEventType] : this.domEventType).forEach(i => {
            this.listenTo(e, i, (n, o) => {
                this.isEnabled && !this.checkShouldIgnoreEventFromTarget(o.target) && this.onDomEvent(o)
            }, {useCapture: this.useCapture, usePassive: this.usePassive})
        })
    }

    stopObserving(e) {
        this.stopListening(e)
    }

    fire(e, t, i) {
        this.isEnabled && this.document.fire(e, new ei(this.view, t, i))
    }
}

class db extends Pt {
    domEventType = ["keydown", "keyup"];

    onDomEvent(e) {
        const t = {
            keyCode: e.keyCode,
            altKey: e.altKey,
            ctrlKey: e.ctrlKey,
            shiftKey: e.shiftKey,
            metaKey: e.metaKey,
            get keystroke() {
                return zi(this)
            }
        };
        this.fire(e.type, e, t)
    }
}

class hb extends gt {
    _fireSelectionChangeDoneDebounced;

    constructor(e) {
        super(e), this._fireSelectionChangeDoneDebounced = it(t => {
            this.document.fire("selectionChangeDone", t)
        }, 200)
    }

    observe() {
        const e = this.document;
        e.on("arrowKey", (t, i) => {
            e.selection.isFake && this.isEnabled && i.preventDefault()
        }, {context: "$capture"}), e.on("arrowKey", (t, i) => {
            e.selection.isFake && this.isEnabled && this._handleSelectionMove(i.keyCode)
        }, {priority: "lowest"})
    }

    stopObserving() {
    }

    destroy() {
        super.destroy(), this._fireSelectionChangeDoneDebounced.cancel()
    }

    _handleSelectionMove(e) {
        const t = this.document.selection, i = new Et(t.getRanges(), {backward: t.isBackward, fake: !1});
        (e == M.arrowleft || e == M.arrowup) && i.setTo(i.getFirstPosition()), (e == M.arrowright || e == M.arrowdown) && i.setTo(i.getLastPosition());
        const n = {oldSelection: t, newSelection: i, domSelection: null};
        this.document.fire("selectionChange", n), this._fireSelectionChangeDoneDebounced(n)
    }
}

let Ih = class extends gt {
    domConverter;
    _config;
    _domElements;
    _mutationObserver;

    constructor(e) {
        super(e), this._config = {
            childList: !0,
            characterData: !0,
            subtree: !0
        }, this.domConverter = e.domConverter, this._domElements = new Set, this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this))
    }

    flush() {
        this._onMutations(this._mutationObserver.takeRecords())
    }

    observe(e) {
        this._domElements.add(e), this.isEnabled && this._mutationObserver.observe(e, this._config)
    }

    stopObserving(e) {
        if (this._domElements.delete(e), this.isEnabled) {
            this._mutationObserver.disconnect();
            for (const t of this._domElements) this._mutationObserver.observe(t, this._config)
        }
    }

    enable() {
        super.enable();
        for (const e of this._domElements) this._mutationObserver.observe(e, this._config)
    }

    disable() {
        super.disable(), this._mutationObserver.disconnect()
    }

    destroy() {
        super.destroy(), this._mutationObserver.disconnect()
    }

    _onMutations(e) {
        if (e.length === 0) return;
        const t = this.domConverter, i = new Set, n = new Set;
        for (const r of e) {
            const a = t.mapDomToView(r.target);
            a && (a.is("uiElement") || a.is("rawElement") || r.type === "childList" && !this._isBogusBrMutation(r) && n.add(a))
        }
        for (const r of e) {
            const a = t.mapDomToView(r.target);
            if (!(a && (a.is("uiElement") || a.is("rawElement"))) && r.type === "characterData") {
                const l = t.findCorrespondingViewText(r.target);
                l && !n.has(l.parent) ? i.add(l) : !l && ke(r.target) && n.add(t.mapDomToView(r.target.parentNode))
            }
        }
        const o = [];
        for (const r of i) o.push({type: "text", node: r});
        for (const r of n) {
            const a = t.mapViewToDom(r), l = Array.from(r.getChildren()),
                c = Array.from(t.domChildrenToView(a, {withChildren: !1}));
            sr(l, c, fb) || o.push({type: "children", node: r})
        }
        o.length && this.document.fire("mutations", {mutations: o})
    }

    _isBogusBrMutation(e) {
        let t = null;
        return e.nextSibling === null && e.removedNodes.length === 0 && e.addedNodes.length == 1 && (t = this.domConverter.domToView(e.addedNodes[0], {withChildren: !1})), t && t.is("element", "br")
    }
};

function fb(s, e) {
    if (!Array.isArray(s)) return s === e ? !0 : s.is("$text") && e.is("$text") ? s.data === e.data : !1
}

class Ls extends Pt {
    _renderTimeoutId = null;
    _isFocusChanging = !1;
    domEventType = ["focus", "blur"];

    constructor(e) {
        super(e), this.useCapture = !0;
        const t = this.document;
        t.on("focus", () => this._handleFocus()), t.on("blur", (i, n) => this._handleBlur(n)), t.on("beforeinput", () => {
            t.isFocused || this._handleFocus()
        }, {priority: "highest"})
    }

    flush() {
        this._isFocusChanging && (this._isFocusChanging = !1, this.document.isFocused = !0)
    }

    onDomEvent(e) {
        this.fire(e.type, e)
    }

    destroy() {
        this._clearTimeout(), super.destroy()
    }

    _handleFocus() {
        this._clearTimeout(), this._isFocusChanging = !0, this._renderTimeoutId = setTimeout(() => {
            this._renderTimeoutId = null, this.flush(), this.view.change(() => {
            })
        }, 50)
    }

    _handleBlur(e) {
        const t = this.document.selection.editableElement;
        (t === null || t === e.target) && (this.document.isFocused = !1, this._isFocusChanging = !1, this.view.change(() => {
        }))
    }

    _clearTimeout() {
        this._renderTimeoutId && (clearTimeout(this._renderTimeoutId), this._renderTimeoutId = null)
    }
}

class mb extends gt {
    mutationObserver;
    focusObserver;
    selection;
    domConverter;
    _documents = new WeakSet;
    _fireSelectionChangeDoneDebounced;
    _clearInfiniteLoopInterval;
    _documentIsSelectingInactivityTimeoutDebounced;
    _loopbackCounter = 0;
    _pendingSelectionChange = new Set;

    constructor(e) {
        super(e), this.mutationObserver = e.getObserver(Ih), this.focusObserver = e.getObserver(Ls), this.selection = this.document.selection, this.domConverter = e.domConverter, this._fireSelectionChangeDoneDebounced = it(t => {
            this.document.fire("selectionChangeDone", t)
        }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = it(() => this.document.isSelecting = !1, 5e3), this.view.document.on("change:isFocused", (t, i, n) => {
            if (n && this._pendingSelectionChange.size) {
                for (const o of Array.from(this._pendingSelectionChange)) this._handleSelectionChange(o);
                this._pendingSelectionChange.clear()
            }
        })
    }

    observe(e) {
        const t = e.ownerDocument, i = () => {
            this.document.isSelecting = !0, this._documentIsSelectingInactivityTimeoutDebounced()
        }, n = () => {
            this.document.isSelecting && (this._handleSelectionChange(t), this.document.isSelecting = !1, this._documentIsSelectingInactivityTimeoutDebounced.cancel())
        };
        this.listenTo(e, "selectstart", i, {priority: "highest"}), this.listenTo(e, "keydown", n, {
            priority: "highest",
            useCapture: !0
        }), this.listenTo(e, "keyup", n, {
            priority: "highest",
            useCapture: !0
        }), !this._documents.has(t) && (this.listenTo(t, "mouseup", n, {
            priority: "highest",
            useCapture: !0
        }), this.listenTo(t, "selectionchange", () => {
            this.document.isComposing && !x.isAndroid || (this._handleSelectionChange(t), this._documentIsSelectingInactivityTimeoutDebounced())
        }), this.listenTo(this.view.document, "compositionstart", () => {
            this._handleSelectionChange(t)
        }, {priority: "lowest"}), this._documents.add(t))
    }

    stopObserving(e) {
        this.stopListening(e)
    }

    destroy() {
        super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel()
    }

    _reportInfiniteLoop() {
    }

    _handleSelectionChange(e) {
        if (!this.isEnabled) return;
        const t = e.defaultView.getSelection();
        if (this.checkShouldIgnoreEventFromTarget(t.anchorNode)) return;
        this.mutationObserver.flush();
        const i = this.domConverter.domSelectionToView(t);
        if (i.rangeCount == 0) {
            this.view.hasDomSelection = !1;
            return
        }
        if (this.view.hasDomSelection = !0, this.focusObserver.flush(), !this.view.document.isFocused && !this.view.document.isReadOnly) {
            this._pendingSelectionChange.add(e);
            return
        }
        if (this._pendingSelectionChange.delete(e), !(this.selection.isEqual(i) && this.domConverter.isDomSelectionCorrect(t))) {
            if (++this._loopbackCounter > 60) {
                this._reportInfiniteLoop();
                return
            }
            if (this.selection.isSimilar(i)) this.view.forceRender(); else {
                const n = {oldSelection: this.selection, newSelection: i, domSelection: t};
                this.document.fire("selectionChange", n), this._fireSelectionChangeDoneDebounced(n)
            }
        }
    }

    _clearInfiniteLoop() {
        this._loopbackCounter = 0
    }
}

class gb extends Pt {
    domEventType = ["compositionstart", "compositionupdate", "compositionend"];

    constructor(e) {
        super(e);
        const t = this.document;
        t.on("compositionstart", () => {
            t.isComposing = !0
        }), t.on("compositionend", () => {
            t.isComposing = !1
        })
    }

    onDomEvent(e) {
        this.fire(e.type, e, {data: e.data})
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class Sh {
    _files;
    _native;

    constructor(e, t = {}) {
        this._files = t.cacheFiles ? yl(e) : null, this._native = e
    }

    get files() {
        return this._files || (this._files = yl(this._native)), this._files
    }

    get types() {
        return this._native.types
    }

    getData(e) {
        return this._native.getData(e)
    }

    setData(e, t) {
        this._native.setData(e, t)
    }

    set effectAllowed(e) {
        this._native.effectAllowed = e
    }

    get effectAllowed() {
        return this._native.effectAllowed
    }

    set dropEffect(e) {
        this._native.dropEffect = e
    }

    get dropEffect() {
        return this._native.dropEffect
    }

    setDragImage(e, t, i) {
        this._native.setDragImage(e, t, i)
    }

    get isCanceled() {
        return this._native.dropEffect == "none" || !!this._native.mozUserCancelled
    }
}

function yl(s) {
    const e = Array.from(s.files || []), t = Array.from(s.items || []);
    return e.length ? e : t.filter(i => i.kind === "file").map(i => i.getAsFile())
}

class pb extends Pt {
    domEventType = "beforeinput";

    onDomEvent(e) {
        const t = e.getTargetRanges(), i = this.view, n = i.document;
        let o = null, r = null, a = [];
        if (e.dataTransfer && (o = new Sh(e.dataTransfer)), e.data !== null ? r = e.data : o && (r = o.getData("text/plain")), n.selection.isFake) a = Array.from(n.selection.getRanges()), e.preventDefault(); else if (t.length) a = t.map(l => {
            let c = i.domConverter.domPositionToView(l.startContainer, l.startOffset);
            const u = i.domConverter.domPositionToView(l.endContainer, l.endOffset);
            if (c && ke(l.startContainer) && l.startOffset < De) {
                e.preventDefault();
                let d = De - l.startOffset;
                c = c.getLastMatchingPosition(h => !!(h.item.is("attributeElement") || h.item.is("uiElement") || h.item.is("$textProxy") && d--), {
                    direction: "backward",
                    singleCharacters: !0
                })
            }
            if (wb(l.endContainer, l.endOffset) && e.preventDefault(), c) return i.createRange(c, u);
            if (u) return i.createRange(u)
        }).filter(l => !!l); else if (x.isAndroid) {
            const l = e.target.ownerDocument.defaultView.getSelection();
            a = Array.from(i.domConverter.domSelectionToView(l).getRanges())
        }
        if (x.isAndroid && e.inputType == "insertCompositionText" && r && r.endsWith(`
`)) {
            this.fire(e.type, e, {inputType: "insertParagraph", targetRanges: [i.createRange(a[0].end)]});
            return
        }
        if (["insertText", "insertReplacementText"].includes(e.inputType) && r && r.includes(`
`)) {
            const l = r.split(/\n{1,2}/g);
            let c = a;
            e.preventDefault();
            for (let u = 0; u < l.length; u++) {
                const d = l[u];
                d != "" && (this.fire(e.type, e, {
                    data: d,
                    dataTransfer: o,
                    targetRanges: c,
                    inputType: e.inputType,
                    isComposing: e.isComposing
                }), c = [n.selection.getFirstRange()]), u + 1 < l.length && (this.fire(e.type, e, {
                    inputType: "insertParagraph",
                    targetRanges: c
                }), c = [n.selection.getFirstRange()])
            }
            return
        }
        this.fire(e.type, e, {
            data: r,
            dataTransfer: o,
            targetRanges: a,
            inputType: e.inputType,
            isComposing: e.isComposing
        })
    }
}

function wb(s, e) {
    for (; s.parentNode;) {
        if (X(s)) {
            if (e != s.data.length) return !1
        } else if (e != s.childNodes.length) return !1;
        if (e = Vi(s) + 1, s = s.parentNode, e < s.childNodes.length && ke(s.childNodes[e])) return !0
    }
    return !1
}

class bb extends gt {
    constructor(e) {
        super(e), this.document.on("keydown", (t, i) => {
            if (this.isEnabled && Jp(i.keyCode)) {
                const n = new ri(this.document, "arrowKey", this.document.selection.getFirstRange());
                this.document.fire(n, i), n.stop.called && t.stop()
            }
        })
    }

    observe() {
    }

    stopObserving() {
    }
}

class _b extends gt {
    constructor(e) {
        super(e);
        const t = this.document;
        t.on("keydown", (i, n) => {
            if (!this.isEnabled || n.keyCode != M.tab || n.ctrlKey) return;
            const o = new ri(t, "tab", t.selection.getFirstRange());
            t.fire(o, n), o.stop.called && i.stop()
        })
    }

    observe() {
    }

    stopObserving() {
    }
}

let vb = class extends H() {
    document;
    domConverter;
    domRoots = new Map;
    _renderer;
    _initialDomRootAttributes = new WeakMap;
    _observers = new Map;
    _writer;
    _ongoingChange = !1;
    _postFixersInProgress = !1;
    _renderingDisabled = !1;
    _hasChangedSinceTheLastRendering = !1;

    constructor(e) {
        super(), this.document = new Ys(e), this.domConverter = new eo(this.document), this.set("isRenderingInProgress", !1), this.set("hasDomSelection", !1), this._renderer = new Zw(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new kh(this.document), this.addObserver(Ih), this.addObserver(Ls), this.addObserver(mb), this.addObserver(db), this.addObserver(hb), this.addObserver(gb), this.addObserver(bb), this.addObserver(pb), this.addObserver(_b), Gw(this), Nw(this), this.on("render", () => {
            this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = !1
        }), this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = !0
        }), this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = !0
        }), x.isiOS && this.listenTo(this.document, "blur", (t, i) => {
            this.domConverter.mapDomToView(i.domEvent.relatedTarget) || this.domConverter._clearDomSelection()
        }), this.listenTo(this.document, "mutations", (t, {mutations: i}) => {
            i.forEach(n => this._renderer.markToSync(n.type, n.node))
        }, {priority: "low"}), this.listenTo(this.document, "mutations", () => {
            this.forceRender()
        }, {priority: "lowest"})
    }

    attachDomRoot(e, t = "main") {
        const i = this.document.getRoot(t);
        i._name = e.tagName.toLowerCase();
        const n = {};
        for (const {
            name: r,
            value: a
        } of Array.from(e.attributes)) n[r] = a, r === "class" ? this._writer.addClass(a.split(" "), i) : i.hasAttribute(r) || this._writer.setAttribute(r, a, i);
        this._initialDomRootAttributes.set(e, n);
        const o = () => {
            this._writer.setAttribute("contenteditable", (!i.isReadOnly).toString(), i), i.isReadOnly ? this._writer.addClass("ck-read-only", i) : this._writer.removeClass("ck-read-only", i)
        };
        o(), this.domRoots.set(t, e), this.domConverter.bindElements(e, i), this._renderer.markToSync("children", i), this._renderer.markToSync("attributes", i), this._renderer.domDocuments.add(e.ownerDocument), i.on("change:children", (r, a) => this._renderer.markToSync("children", a)), i.on("change:attributes", (r, a) => this._renderer.markToSync("attributes", a)), i.on("change:text", (r, a) => this._renderer.markToSync("text", a)), i.on("change:isReadOnly", () => this.change(o)), i.on("change", () => {
            this._hasChangedSinceTheLastRendering = !0
        });
        for (const r of this._observers.values()) r.observe(e, t)
    }

    detachDomRoot(e) {
        const t = this.domRoots.get(e);
        Array.from(t.attributes).forEach(({name: n}) => t.removeAttribute(n));
        const i = this._initialDomRootAttributes.get(t);
        for (const n in i) t.setAttribute(n, i[n]);
        this.domRoots.delete(e), this.domConverter.unbindDomElement(t);
        for (const n of this._observers.values()) n.stopObserving(t)
    }

    getDomRoot(e = "main") {
        return this.domRoots.get(e)
    }

    addObserver(e) {
        let t = this._observers.get(e);
        if (t) return t;
        t = new e(this), this._observers.set(e, t);
        for (const [i, n] of this.domRoots) t.observe(n, i);
        return t.enable(), t
    }

    getObserver(e) {
        return this._observers.get(e)
    }

    disableObservers() {
        for (const e of this._observers.values()) e.disable()
    }

    enableObservers() {
        for (const e of this._observers.values()) e.enable()
    }

    scrollToTheSelection({alignToTop: e, forceScroll: t, viewportOffset: i = 20, ancestorOffset: n = 20} = {}) {
        const o = this.document.selection.getFirstRange();
        if (!o) return;
        const r = Ve({alignToTop: e, forceScroll: t, viewportOffset: i, ancestorOffset: n});
        typeof i == "number" && (i = {top: i, bottom: i, left: i, right: i});
        const a = {
            target: this.domConverter.viewRangeToDom(o),
            viewportOffset: i,
            ancestorOffset: n,
            alignToTop: e,
            forceScroll: t
        };
        this.fire("scrollToTheSelection", a, r), dh(a)
    }

    focus() {
        if (!this.document.isFocused) {
            const e = this.document.selection.editableElement;
            e && (this.domConverter.focus(e), this.forceRender())
        }
    }

    change(e) {
        if (this.isRenderingInProgress || this._postFixersInProgress) throw new p("cannot-change-view-tree", this);
        try {
            if (this._ongoingChange) return e(this._writer);
            this._ongoingChange = !0;
            const t = e(this._writer);
            return this._ongoingChange = !1, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = !0, this.document._callPostFixers(this._writer), this._postFixersInProgress = !1, this.fire("render")), t
        } catch (t) {/* istanbul ignore next -- @preserve */
            p.rethrowUnexpectedError(t, this)
        }
    }

    forceRender() {
        this._hasChangedSinceTheLastRendering = !0, this.getObserver(Ls).flush(), this.change(() => {
        })
    }

    destroy() {
        for (const e of this._observers.values()) e.destroy();
        this.document.destroy(), this.stopListening()
    }

    createPositionAt(e, t) {
        return k._createAt(e, t)
    }

    createPositionAfter(e) {
        return k._createAfter(e)
    }

    createPositionBefore(e) {
        return k._createBefore(e)
    }

    createRange(e, t) {
        return new B(e, t)
    }

    createRangeOn(e) {
        return B._createOn(e)
    }

    createRangeIn(e) {
        return B._createIn(e)
    }

    createSelection(...e) {
        return new Et(...e)
    }

    _disableRendering(e) {
        this._renderingDisabled = e, e == !1 && this.change(() => {
        })
    }

    _render() {
        this.isRenderingInProgress = !0, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = !1
    }
};

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class qt {
    is() {
        throw new Error("is() method is abstract")
    }
}

class et extends qt {
    textNode;
    data;
    offsetInText;

    constructor(e, t, i) {
        if (super(), this.textNode = e, t < 0 || t > e.offsetSize) throw new p("model-textproxy-wrong-offsetintext", this);
        if (i < 0 || t + i > e.offsetSize) throw new p("model-textproxy-wrong-length", this);
        this.data = e.data.substring(t, t + i), this.offsetInText = t
    }

    get startOffset() {
        return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null
    }

    get offsetSize() {
        return this.data.length
    }

    get endOffset() {
        return this.startOffset !== null ? this.startOffset + this.offsetSize : null
    }

    get isPartial() {
        return this.offsetSize !== this.textNode.offsetSize
    }

    get parent() {
        return this.textNode.parent
    }

    get root() {
        return this.textNode.root
    }

    getPath() {
        const e = this.textNode.getPath();
        return e.length > 0 && (e[e.length - 1] += this.offsetInText), e
    }

    getAncestors(e = {}) {
        const t = [];
        let i = e.includeSelf ? this : this.parent;
        for (; i;) t[e.parentFirst ? "push" : "unshift"](i), i = i.parent;
        return t
    }

    hasAttribute(e) {
        return this.textNode.hasAttribute(e)
    }

    getAttribute(e) {
        return this.textNode.getAttribute(e)
    }

    getAttributes() {
        return this.textNode.getAttributes()
    }

    getAttributeKeys() {
        return this.textNode.getAttributeKeys()
    }
}

et.prototype.is = function (s) {
    return s === "$textProxy" || s === "model:$textProxy" || s === "textProxy" || s === "model:textProxy"
};

class Ct {
    direction;
    boundaries;
    singleCharacters;
    shallow;
    ignoreElementEnd;
    _position;
    _boundaryStartParent;
    _boundaryEndParent;
    _visitedParent;

    constructor(e) {
        if (!e || !e.boundaries && !e.startPosition) throw new p("model-tree-walker-no-start-position", null);
        const t = e.direction || "forward";
        if (t != "forward" && t != "backward") throw new p("model-tree-walker-unknown-direction", e, {direction: t});
        this.direction = t, this.boundaries = e.boundaries || null, e.startPosition ? this._position = e.startPosition.clone() : this._position = y._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!e.singleCharacters, this.shallow = !!e.shallow, this.ignoreElementEnd = !!e.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent
    }

    [Symbol.iterator]() {
        return this
    }

    get position() {
        return this._position
    }

    skip(e) {
        let t, i, n, o;
        do n = this.position, o = this._visitedParent, {done: t, value: i} = this.next(); while (!t && e(i));
        t || (this._position = n, this._visitedParent = o)
    }

    jumpTo(e) {
        this._boundaryStartParent && e.isBefore(this.boundaries.start) ? e = this.boundaries.start : this._boundaryEndParent && e.isAfter(this.boundaries.end) && (e = this.boundaries.end), this._position = e.clone(), this._visitedParent = e.parent
    }

    next() {
        return this.direction == "forward" ? this._next() : this._previous()
    }

    _next() {
        const e = this.position, t = this.position.clone(), i = this._visitedParent;
        if (i.parent === null && t.offset === i.maxOffset) return {done: !0, value: void 0};
        if (i === this._boundaryEndParent && t.offset == this.boundaries.end.offset) return {done: !0, value: void 0};
        const n = yn(t, i), o = n || Ph(t, i, n);
        if (o && o.is("model:element")) {
            if (!this.shallow) t.path.push(0), this._visitedParent = o; else {
                if (this.boundaries && this.boundaries.end.isBefore(t)) return {done: !0, value: void 0};
                t.offset++
            }
            return this._position = t, Kt("elementStart", o, e, t, 1)
        }
        if (o && o.is("model:$text")) {
            let r;
            if (this.singleCharacters) r = 1; else {
                let c = o.endOffset;
                this._boundaryEndParent == i && this.boundaries.end.offset < c && (c = this.boundaries.end.offset), r = c - t.offset
            }
            const a = t.offset - o.startOffset, l = new et(o, a, r);
            return t.offset += r, this._position = t, Kt("text", l, e, t, r)
        }
        return t.path.pop(), t.offset++, this._position = t, this._visitedParent = i.parent, this.ignoreElementEnd ? this._next() : Kt("elementEnd", i, e, t)
    }

    _previous() {
        const e = this.position, t = this.position.clone(), i = this._visitedParent;
        if (i.parent === null && t.offset === 0) return {done: !0, value: void 0};
        if (i == this._boundaryStartParent && t.offset == this.boundaries.start.offset) return {
            done: !0,
            value: void 0
        };
        const n = t.parent, o = yn(t, n), r = o || Rh(t, n, o);
        if (r && r.is("model:element")) return t.offset--, this.shallow ? (this._position = t, Kt("elementStart", r, e, t, 1)) : (t.path.push(r.maxOffset), this._position = t, this._visitedParent = r, this.ignoreElementEnd ? this._previous() : Kt("elementEnd", r, e, t));
        if (r && r.is("model:$text")) {
            let a;
            if (this.singleCharacters) a = 1; else {
                let u = r.startOffset;
                this._boundaryStartParent == i && this.boundaries.start.offset > u && (u = this.boundaries.start.offset), a = t.offset - u
            }
            const l = t.offset - r.startOffset, c = new et(r, l - a, a);
            return t.offset -= a, this._position = t, Kt("text", c, e, t, a)
        }
        return t.path.pop(), this._position = t, this._visitedParent = i.parent, Kt("elementStart", i, e, t, 1)
    }
}

function Kt(s, e, t, i, n) {
    return {done: !1, value: {type: s, item: e, previousPosition: t, nextPosition: i, length: n}}
}

class y extends qt {
    root;
    path;
    stickiness;

    constructor(e, t, i = "toNone") {
        if (super(), !e.is("element") && !e.is("documentFragment")) throw new p("model-position-root-invalid", e);
        if (!Array.isArray(t) || t.length === 0) throw new p("model-position-path-incorrect-format", e, {path: t});
        e.is("rootElement") ? t = t.slice() : (t = [...e.getPath(), ...t], e = e.root), this.root = e, this.path = t, this.stickiness = i
    }

    get offset() {
        return this.path[this.path.length - 1]
    }

    set offset(e) {
        this.path[this.path.length - 1] = e
    }

    get parent() {
        let e = this.root;
        for (let t = 0; t < this.path.length - 1; t++) if (e = e.getChildAtOffset(this.path[t]), !e) throw new p("model-position-path-incorrect", this, {position: this});
        if (e.is("$text")) throw new p("model-position-path-incorrect", this, {position: this});
        return e
    }

    get index() {
        return this.parent.offsetToIndex(this.offset)
    }

    get textNode() {
        return yn(this, this.parent)
    }

    get nodeAfter() {
        const e = this.parent;
        return Ph(this, e, yn(this, e))
    }

    get nodeBefore() {
        const e = this.parent;
        return Rh(this, e, yn(this, e))
    }

    get isAtStart() {
        return this.offset === 0
    }

    get isAtEnd() {
        return this.offset == this.parent.maxOffset
    }

    isValid() {
        if (this.offset < 0) return !1;
        let e = this.root;
        for (let t = 0; t < this.path.length - 1; t++) if (e = e.getChildAtOffset(this.path[t]), !e) return !1;
        return this.offset <= e.maxOffset
    }

    compareWith(e) {
        if (this.root != e.root) return "different";
        const t = _e(this.path, e.path);
        switch (t) {
            case"same":
                return "same";
            case"prefix":
                return "before";
            case"extension":
                return "after";
            default:
                return this.path[t] < e.path[t] ? "before" : "after"
        }
    }

    getLastMatchingPosition(e, t = {}) {
        t.startPosition = this;
        const i = new Ct(t);
        return i.skip(e), i.position
    }

    getParentPath() {
        return this.path.slice(0, -1)
    }

    getAncestors() {
        const e = this.parent;
        return e.is("documentFragment") ? [e] : e.getAncestors({includeSelf: !0})
    }

    findAncestor(e) {
        const t = this.parent;
        return t.is("element") ? t.findAncestor(e, {includeSelf: !0}) : null
    }

    getCommonPath(e) {
        if (this.root != e.root) return [];
        const t = _e(this.path, e.path), i = typeof t == "string" ? Math.min(this.path.length, e.path.length) : t;
        return this.path.slice(0, i)
    }

    getCommonAncestor(e) {
        const t = this.getAncestors(), i = e.getAncestors();
        let n = 0;
        for (; t[n] == i[n] && t[n];) n++;
        return n === 0 ? null : t[n - 1]
    }

    getShiftedBy(e) {
        const t = this.clone(), i = t.offset + e;
        return t.offset = i < 0 ? 0 : i, t
    }

    isAfter(e) {
        return this.compareWith(e) == "after"
    }

    isBefore(e) {
        return this.compareWith(e) == "before"
    }

    isEqual(e) {
        return this.compareWith(e) == "same"
    }

    isTouching(e) {
        if (this.root !== e.root) return !1;
        const t = Math.min(this.path.length, e.path.length);
        for (let i = 0; i < t; i++) {
            const n = this.path[i] - e.path[i];
            if (n < -1 || n > 1) return !1;
            if (n === 1) return kl(e, this, i);
            if (n === -1) return kl(this, e, i)
        }
        return this.path.length === e.path.length ? !0 : this.path.length > e.path.length ? gr(this.path, t) : gr(e.path, t)
    }

    hasSameParentAs(e) {
        if (this.root !== e.root) return !1;
        const t = this.getParentPath(), i = e.getParentPath();
        return _e(t, i) == "same"
    }

    getTransformedByOperation(e) {
        let t;
        switch (e.type) {
            case"insert":
                t = this._getTransformedByInsertOperation(e);
                break;
            case"move":
            case"remove":
            case"reinsert":
                t = this._getTransformedByMoveOperation(e);
                break;
            case"split":
                t = this._getTransformedBySplitOperation(e);
                break;
            case"merge":
                t = this._getTransformedByMergeOperation(e);
                break;
            default:
                t = y._createAt(this);
                break
        }
        return t
    }

    _getTransformedByInsertOperation(e) {
        return this._getTransformedByInsertion(e.position, e.howMany)
    }

    _getTransformedByMoveOperation(e) {
        return this._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany)
    }

    _getTransformedBySplitOperation(e) {
        const t = e.movedRange;
        return t.containsPosition(this) || t.start.isEqual(this) && this.stickiness == "toNext" ? this._getCombined(e.splitPosition, e.moveTargetPosition) : e.graveyardPosition ? this._getTransformedByMove(e.graveyardPosition, e.insertionPosition, 1) : this._getTransformedByInsertion(e.insertionPosition, 1)
    }

    _getTransformedByMergeOperation(e) {
        const t = e.movedRange, i = t.containsPosition(this) || t.start.isEqual(this);
        let n;
        return i ? (n = this._getCombined(e.sourcePosition, e.targetPosition), e.sourcePosition.isBefore(e.targetPosition) && (n = n._getTransformedByDeletion(e.deletionPosition, 1))) : this.isEqual(e.deletionPosition) ? n = y._createAt(e.deletionPosition) : n = this._getTransformedByMove(e.deletionPosition, e.graveyardPosition, 1), n
    }

    _getTransformedByDeletion(e, t) {
        const i = y._createAt(this);
        if (this.root != e.root) return i;
        if (_e(e.getParentPath(), this.getParentPath()) == "same") {
            if (e.offset < this.offset) {
                if (e.offset + t > this.offset) return null;
                i.offset -= t
            }
        } else if (_e(e.getParentPath(), this.getParentPath()) == "prefix") {
            const n = e.path.length - 1;
            if (e.offset <= this.path[n]) {
                if (e.offset + t > this.path[n]) return null;
                i.path[n] -= t
            }
        }
        return i
    }

    _getTransformedByInsertion(e, t) {
        const i = y._createAt(this);
        if (this.root != e.root) return i;
        if (_e(e.getParentPath(), this.getParentPath()) == "same") (e.offset < this.offset || e.offset == this.offset && this.stickiness != "toPrevious") && (i.offset += t); else if (_e(e.getParentPath(), this.getParentPath()) == "prefix") {
            const n = e.path.length - 1;
            e.offset <= this.path[n] && (i.path[n] += t)
        }
        return i
    }

    _getTransformedByMove(e, t, i) {
        if (t = t._getTransformedByDeletion(e, i), e.isEqual(t)) return y._createAt(this);
        const n = this._getTransformedByDeletion(e, i);
        return n === null || e.isEqual(this) && this.stickiness == "toNext" || e.getShiftedBy(i).isEqual(this) && this.stickiness == "toPrevious" ? this._getCombined(e, t) : n._getTransformedByInsertion(t, i)
    }

    _getCombined(e, t) {
        const i = e.path.length - 1, n = y._createAt(t);
        return n.stickiness = this.stickiness, n.offset = n.offset + this.path[i] - e.offset, n.path = [...n.path, ...this.path.slice(i + 1)], n
    }

    toJSON() {
        return {root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness}
    }

    clone() {
        return new this.constructor(this.root, this.path, this.stickiness)
    }

    static _createAt(e, t, i = "toNone") {
        if (e.is("model:position")) return new y(e.root, e.path, e.stickiness);
        {
            const n = e;
            if (t == "end") t = n.maxOffset; else {
                if (t == "before") return this._createBefore(n, i);
                if (t == "after") return this._createAfter(n, i);
                if (t !== 0 && !t) throw new p("model-createpositionat-offset-required", [this, e])
            }
            if (!n.is("element") && !n.is("documentFragment")) throw new p("model-position-parent-incorrect", [this, e]);
            const o = n.getPath();
            return o.push(t), new this(n.root, o, i)
        }
    }

    static _createAfter(e, t) {
        if (!e.parent) throw new p("model-position-after-root", [this, e], {root: e});
        return this._createAt(e.parent, e.endOffset, t)
    }

    static _createBefore(e, t) {
        if (!e.parent) throw new p("model-position-before-root", e, {root: e});
        return this._createAt(e.parent, e.startOffset, t)
    }

    static fromJSON(e, t) {
        if (e.root === "$graveyard") {
            const i = new y(t.graveyard, e.path);
            return i.stickiness = e.stickiness, i
        }
        if (!t.getRoot(e.root)) throw new p("model-position-fromjson-no-root", t, {rootName: e.root});
        return new y(t.getRoot(e.root), e.path, e.stickiness)
    }
}

y.prototype.is = function (s) {
    return s === "position" || s === "model:position"
};

function yn(s, e) {
    const t = e.getChildAtOffset(s.offset);
    return t && t.is("$text") && t.startOffset < s.offset ? t : null
}

function Ph(s, e, t) {
    return t !== null ? null : e.getChildAtOffset(s.offset)
}

function Rh(s, e, t) {
    return t !== null ? null : e.getChild(e.offsetToIndex(s.offset) - 1)
}

function kl(s, e, t) {
    return !(t + 1 === s.path.length || !gr(e.path, t + 1) || !yb(s, t + 1))
}

function gr(s, e) {
    for (; e < s.length;) {
        if (s[e] !== 0) return !1;
        e++
    }
    return !0
}

function yb(s, e) {
    let t = s.parent, i = s.path.length - 1, n = 0;
    for (; i >= e;) {
        if (s.path[i] + n !== t.maxOffset) return !1;
        n = 1, i--, t = t.parent
    }
    return !0
}

class b extends qt {
    start;
    end;

    constructor(e, t) {
        super(), this.start = y._createAt(e), this.end = t ? y._createAt(t) : y._createAt(e), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious"
    }

    * [Symbol.iterator]() {
        yield* new Ct({boundaries: this, ignoreElementEnd: !0})
    }

    get isCollapsed() {
        return this.start.isEqual(this.end)
    }

    get isFlat() {
        const e = this.start.getParentPath(), t = this.end.getParentPath();
        return _e(e, t) == "same"
    }

    get root() {
        return this.start.root
    }

    containsPosition(e) {
        return e.isAfter(this.start) && e.isBefore(this.end)
    }

    containsRange(e, t = !1) {
        e.isCollapsed && (t = !1);
        const i = this.containsPosition(e.start) || t && this.start.isEqual(e.start),
            n = this.containsPosition(e.end) || t && this.end.isEqual(e.end);
        return i && n
    }

    containsItem(e) {
        const t = y._createBefore(e);
        return this.containsPosition(t) || this.start.isEqual(t)
    }

    isEqual(e) {
        return this.start.isEqual(e.start) && this.end.isEqual(e.end)
    }

    isIntersecting(e) {
        return this.start.isBefore(e.end) && this.end.isAfter(e.start)
    }

    getDifference(e) {
        const t = [];
        return this.isIntersecting(e) ? (this.containsPosition(e.start) && t.push(new b(this.start, e.start)), this.containsPosition(e.end) && t.push(new b(e.end, this.end))) : t.push(new b(this.start, this.end)), t
    }

    getIntersection(e) {
        if (this.isIntersecting(e)) {
            let t = this.start, i = this.end;
            return this.containsPosition(e.start) && (t = e.start), this.containsPosition(e.end) && (i = e.end), new b(t, i)
        }
        return null
    }

    getJoined(e, t = !1) {
        let i = this.isIntersecting(e);
        if (i || (this.start.isBefore(e.start) ? i = t ? this.end.isTouching(e.start) : this.end.isEqual(e.start) : i = t ? e.end.isTouching(this.start) : e.end.isEqual(this.start)), !i) return null;
        let n = this.start, o = this.end;
        return e.start.isBefore(n) && (n = e.start), e.end.isAfter(o) && (o = e.end), new b(n, o)
    }

    getMinimalFlatRanges() {
        const e = [], t = this.start.getCommonPath(this.end).length, i = y._createAt(this.start);
        let n = i.parent;
        for (; i.path.length > t + 1;) {
            const o = n.maxOffset - i.offset;
            o !== 0 && e.push(new b(i, i.getShiftedBy(o))), i.path = i.path.slice(0, -1), i.offset++, n = n.parent
        }
        for (; i.path.length <= this.end.path.length;) {
            const o = this.end.path[i.path.length - 1], r = o - i.offset;
            r !== 0 && e.push(new b(i, i.getShiftedBy(r))), i.offset = o, i.path.push(0)
        }
        return e
    }

    getWalker(e = {}) {
        return e.boundaries = this, new Ct(e)
    }

    * getItems(e = {}) {
        e.boundaries = this, e.ignoreElementEnd = !0;
        const t = new Ct(e);
        for (const i of t) yield i.item
    }

    * getPositions(e = {}) {
        e.boundaries = this;
        const t = new Ct(e);
        yield t.position;
        for (const i of t) yield i.nextPosition
    }

    getTransformedByOperation(e) {
        switch (e.type) {
            case"insert":
                return this._getTransformedByInsertOperation(e);
            case"move":
            case"remove":
            case"reinsert":
                return this._getTransformedByMoveOperation(e);
            case"split":
                return [this._getTransformedBySplitOperation(e)];
            case"merge":
                return [this._getTransformedByMergeOperation(e)]
        }
        return [new b(this.start, this.end)]
    }

    getTransformedByOperations(e) {
        const t = [new b(this.start, this.end)];
        for (const i of e) for (let n = 0; n < t.length; n++) {
            const o = t[n].getTransformedByOperation(i);
            t.splice(n, 1, ...o), n += o.length - 1
        }
        for (let i = 0; i < t.length; i++) {
            const n = t[i];
            for (let o = i + 1; o < t.length; o++) {
                const r = t[o];
                (n.containsRange(r) || r.containsRange(n) || n.isEqual(r)) && t.splice(o, 1)
            }
        }
        return t
    }

    getCommonAncestor() {
        return this.start.getCommonAncestor(this.end)
    }

    getContainedElement() {
        if (this.isCollapsed) return null;
        const e = this.start.nodeAfter, t = this.end.nodeBefore;
        return e && e.is("element") && e === t ? e : null
    }

    toJSON() {
        return {start: this.start.toJSON(), end: this.end.toJSON()}
    }

    clone() {
        return new this.constructor(this.start, this.end)
    }

    _getTransformedByInsertOperation(e, t = !1) {
        return this._getTransformedByInsertion(e.position, e.howMany, t)
    }

    _getTransformedByMoveOperation(e, t = !1) {
        const i = e.sourcePosition, n = e.howMany, o = e.targetPosition;
        return this._getTransformedByMove(i, o, n, t)
    }

    _getTransformedBySplitOperation(e) {
        const t = this.start._getTransformedBySplitOperation(e);
        let i = this.end._getTransformedBySplitOperation(e);
        return this.end.isEqual(e.insertionPosition) && (i = this.end.getShiftedBy(1)), t.root != i.root && (i = this.end.getShiftedBy(-1)), new b(t, i)
    }

    _getTransformedByMergeOperation(e) {
        if (this.start.isEqual(e.targetPosition) && this.end.isEqual(e.deletionPosition)) return new b(this.start);
        let t = this.start._getTransformedByMergeOperation(e), i = this.end._getTransformedByMergeOperation(e);
        return t.root != i.root && (i = this.end.getShiftedBy(-1)), t.isAfter(i) ? (e.sourcePosition.isBefore(e.targetPosition) ? (t = y._createAt(i), t.offset = 0) : (e.deletionPosition.isEqual(t) || (i = e.deletionPosition), t = e.targetPosition), new b(t, i)) : new b(t, i)
    }

    _getTransformedByInsertion(e, t, i = !1) {
        if (i && this.containsPosition(e)) return [new b(this.start, e), new b(e.getShiftedBy(t), this.end._getTransformedByInsertion(e, t))];
        {
            const n = new b(this.start, this.end);
            return n.start = n.start._getTransformedByInsertion(e, t), n.end = n.end._getTransformedByInsertion(e, t), [n]
        }
    }

    _getTransformedByMove(e, t, i, n = !1) {
        if (this.isCollapsed) {
            const d = this.start._getTransformedByMove(e, t, i);
            return [new b(d)]
        }
        const o = b._createFromPositionAndShift(e, i), r = t._getTransformedByDeletion(e, i);
        if (this.containsPosition(t) && !n && (o.containsPosition(this.start) || o.containsPosition(this.end))) {
            const d = this.start._getTransformedByMove(e, t, i), h = this.end._getTransformedByMove(e, t, i);
            return [new b(d, h)]
        }
        let a;
        const l = this.getDifference(o);
        let c = null;
        const u = this.getIntersection(o);
        if (l.length == 1 ? c = new b(l[0].start._getTransformedByDeletion(e, i), l[0].end._getTransformedByDeletion(e, i)) : l.length == 2 && (c = new b(this.start, this.end._getTransformedByDeletion(e, i))), c ? a = c._getTransformedByInsertion(r, i, u !== null || n) : a = [], u) {
            const d = new b(u.start._getCombined(o.start, r), u.end._getCombined(o.start, r));
            a.length == 2 ? a.splice(1, 0, d) : a.push(d)
        }
        return a
    }

    _getTransformedByDeletion(e, t) {
        let i = this.start._getTransformedByDeletion(e, t), n = this.end._getTransformedByDeletion(e, t);
        return i == null && n == null ? null : (i == null && (i = e), n == null && (n = e), new b(i, n))
    }

    static _createFromPositionAndShift(e, t) {
        const i = e, n = e.getShiftedBy(t);
        return t > 0 ? new this(i, n) : new this(n, i)
    }

    static _createIn(e) {
        return new this(y._createAt(e, 0), y._createAt(e, e.maxOffset))
    }

    static _createOn(e) {
        return this._createFromPositionAndShift(y._createBefore(e), e.offsetSize)
    }

    static _createFromRanges(e) {
        if (e.length === 0) throw new p("range-create-from-ranges-empty-array", null);
        if (e.length == 1) return e[0].clone();
        const t = e[0];
        e.sort((o, r) => o.start.isAfter(r.start) ? 1 : -1);
        const i = e.indexOf(t), n = new this(t.start, t.end);
        for (let o = i - 1; o >= 0 && e[o].end.isEqual(n.start); o--) n.start = y._createAt(e[o].start);
        for (let o = i + 1; o < e.length && e[o].start.isEqual(n.end); o++) n.end = y._createAt(e[o].end);
        return n
    }

    static fromJSON(e, t) {
        return new this(y.fromJSON(e.start, t), y.fromJSON(e.end, t))
    }
}

b.prototype.is = function (s) {
    return s === "range" || s === "model:range"
};

class Vh extends W() {
    _modelToViewMapping = new WeakMap;
    _viewToModelMapping = new WeakMap;
    _viewToModelLengthCallbacks = new Map;
    _markerNameToElements = new Map;
    _elementToMarkerNames = new Map;
    _deferredBindingRemovals = new Map;
    _unboundMarkerNames = new Set;
    _cache = new kb;

    constructor() {
        super(), this.on("modelToViewPosition", (e, t) => {
            if (t.viewPosition) return;
            const i = this._modelToViewMapping.get(t.modelPosition.parent);
            if (!i) throw new p("mapping-model-position-view-parent-not-found", this, {modelPosition: t.modelPosition});
            t.viewPosition = this.findPositionIn(i, t.modelPosition.offset)
        }, {priority: "low"}), this.on("viewToModelPosition", (e, t) => {
            if (t.modelPosition) return;
            const i = this.findMappedViewAncestor(t.viewPosition), n = this._viewToModelMapping.get(i),
                o = this._toModelOffset(t.viewPosition.parent, t.viewPosition.offset, i);
            t.modelPosition = y._createAt(n, o)
        }, {priority: "low"})
    }

    bindElements(e, t) {
        this._modelToViewMapping.set(e, t), this._viewToModelMapping.set(t, e)
    }

    unbindViewElement(e, t = {}) {
        const i = this.toModelElement(e);
        if (this._elementToMarkerNames.has(e)) for (const n of this._elementToMarkerNames.get(e)) this._unboundMarkerNames.add(n);
        t.defer ? this._deferredBindingRemovals.set(e, e.root) : (this._viewToModelMapping.delete(e) && this._cache.stopTracking(e), this._modelToViewMapping.get(i) == e && this._modelToViewMapping.delete(i))
    }

    unbindModelElement(e) {
        const t = this.toViewElement(e);
        this._modelToViewMapping.delete(e), this._viewToModelMapping.get(t) == e && this._viewToModelMapping.delete(t) && this._cache.stopTracking(t)
    }

    bindElementToMarker(e, t) {
        const i = this._markerNameToElements.get(t) || new Set;
        i.add(e);
        const n = this._elementToMarkerNames.get(e) || new Set;
        n.add(t), this._markerNameToElements.set(t, i), this._elementToMarkerNames.set(e, n)
    }

    unbindElementFromMarkerName(e, t) {
        const i = this._markerNameToElements.get(t);
        i && (i.delete(e), i.size == 0 && this._markerNameToElements.delete(t));
        const n = this._elementToMarkerNames.get(e);
        n && (n.delete(t), n.size == 0 && this._elementToMarkerNames.delete(e))
    }

    flushUnboundMarkerNames() {
        const e = Array.from(this._unboundMarkerNames);
        return this._unboundMarkerNames.clear(), e
    }

    flushDeferredBindings() {
        for (const [e, t] of this._deferredBindingRemovals) e.root == t && this.unbindViewElement(e);
        this._deferredBindingRemovals = new Map
    }

    clearBindings() {
        this._modelToViewMapping = new WeakMap, this._viewToModelMapping = new WeakMap, this._markerNameToElements = new Map, this._elementToMarkerNames = new Map, this._unboundMarkerNames = new Set, this._deferredBindingRemovals = new Map
    }

    toModelElement(e) {
        return this._viewToModelMapping.get(e)
    }

    toViewElement(e) {
        return this._modelToViewMapping.get(e)
    }

    toModelRange(e) {
        return new b(this.toModelPosition(e.start), this.toModelPosition(e.end))
    }

    toViewRange(e) {
        return new B(this.toViewPosition(e.start), this.toViewPosition(e.end))
    }

    toModelPosition(e) {
        const t = {viewPosition: e, mapper: this};
        return this.fire("viewToModelPosition", t), t.modelPosition
    }

    toViewPosition(e, t = {}) {
        const i = {modelPosition: e, mapper: this, isPhantom: t.isPhantom};
        return this.fire("modelToViewPosition", i), i.viewPosition
    }

    markerNameToElements(e) {
        const t = this._markerNameToElements.get(e);
        if (!t) return null;
        const i = new Set;
        for (const n of t) if (n.is("attributeElement")) for (const o of n.getElementsWithSameId()) i.add(o); else i.add(n);
        return i
    }

    registerViewToModelLength(e, t) {
        this._viewToModelLengthCallbacks.set(e, t)
    }

    findMappedViewAncestor(e) {
        let t = e.parent;
        for (; !this._viewToModelMapping.has(t);) t = t.parent;
        return t
    }

    _toModelOffset(e, t, i) {
        if (i != e) {
            const o = this._toModelOffset(e.parent, e.index, i), r = this._toModelOffset(e, t, e);
            return o + r
        }
        if (e.is("$text")) return t;
        let n = 0;
        for (let o = 0; o < t; o++) n += this.getModelLength(e.getChild(o));
        return n
    }

    getModelLength(e) {
        const t = [e];
        let i = 0;
        for (; t.length > 0;) {
            const n = t.pop(),
                o = n.name && this._viewToModelLengthCallbacks.size > 0 && this._viewToModelLengthCallbacks.get(n.name);
            if (o) i += o(n); else if (this._viewToModelMapping.has(n)) i += 1; else if (n.is("$text")) i += n.data.length; else {
                if (n.is("uiElement")) continue;
                for (const r of n.getChildren()) t.push(r)
            }
        }
        return i
    }

    findPositionIn(e, t) {
        if (t === 0) return this._moveViewPositionToTextNode(new k(e, 0));
        if (this._viewToModelLengthCallbacks.size == 0 && this._viewToModelMapping.has(e)) {
            const n = this._cache.getClosest(e, t);
            return this._findPositionStartingFrom(n.viewPosition, n.modelOffset, t, e, !0)
        } else return this._findPositionStartingFrom(new k(e, 0), 0, t, e, !1)
    }

    _findPositionStartingFrom(e, t, i, n, o) {
        let r = e.parent, a = e.offset;
        if (r.is("$text")) return new k(r, i - t);
        let l, c = t, u = 0;
        for (; c < i;) {
            if (l = r.getChild(a), !l) {
                if (r == n) throw new p("mapping-model-offset-not-found", this, {modelOffset: i, viewContainer: n});
                a = r.parent.getChildIndex(r) + 1, r = r.parent, o && this._cache.save(r, a, n, c);
                continue
            }
            o ? u = this._getModelLengthAndCache(l, n, c) : u = this.getModelLength(l), c += u, a++
        }
        let d = new k(r, a);
        if (o) for (; d.isAtEnd && d.parent !== n && d.parent.parent;) {
            const h = d.parent.parent, f = h.getChildIndex(d.parent) + 1;
            this._cache.save(h, f, n, c), d = new k(h, f)
        }
        return c == i ? this._moveViewPositionToTextNode(d) : this._findPositionStartingFrom(new k(l, 0), c - u, i, n, o)
    }

    _getModelLengthAndCache(e, t, i) {
        let n = 0;
        if (this._viewToModelMapping.has(e)) n = 1; else if (e.is("$text")) n = e.data.length; else if (!e.is("uiElement")) for (const o of e.getChildren()) n += this._getModelLengthAndCache(o, t, i + n);
        return this._cache.save(e.parent, e.index + 1, t, i + n), n
    }

    _moveViewPositionToTextNode(e) {
        const t = e.nodeBefore, i = e.nodeAfter;
        return t && t.is("view:$text") ? new k(t, t.data.length) : i && i.is("view:$text") ? new k(i, 0) : e
    }
}

class kb extends W() {
    _cachedMapping = new WeakMap;
    _nodeToCacheListIndex = new WeakMap;
    _invalidateOnChildrenChangeCallback = (e, t, i) => {
        this._clearCacheInsideParent(t, i.index)
    };
    _invalidateOnTextChangeCallback = (e, t) => {
        this._clearCacheAfter(t)
    };

    save(e, t, i, n) {
        const o = this._cachedMapping.get(i), r = o.cacheMap.get(n);
        if (r) {
            const u = e.getChild(t - 1),
                d = r.viewPosition.nodeBefore ? this._nodeToCacheListIndex.get(r.viewPosition.nodeBefore) : 0;
            this._nodeToCacheListIndex.set(u, d);
            return
        }
        const l = {viewPosition: new k(e, t), modelOffset: n};
        o.maxModelOffset = n > o.maxModelOffset ? n : o.maxModelOffset, o.cacheMap.set(n, l);
        let c = o.cacheList.length - 1;
        for (; c >= 0 && o.cacheList[c].modelOffset > n;) c--;
        if (o.cacheList.splice(c + 1, 0, l), t > 0) {
            const u = e.getChild(t - 1);
            this._nodeToCacheListIndex.set(u, c + 1)
        }
    }

    getClosest(e, t) {
        const i = this._cachedMapping.get(e);
        let n;
        if (i) if (t > i.maxModelOffset) n = i.cacheList[i.cacheList.length - 1]; else {
            const o = i.cacheMap.get(t);
            o ? n = o : n = this._findInCacheList(i.cacheList, t)
        } else n = this.startTracking(e);
        return {modelOffset: n.modelOffset, viewPosition: n.viewPosition.clone()}
    }

    startTracking(e) {
        const i = {viewPosition: new k(e, 0), modelOffset: 0},
            n = {maxModelOffset: 0, cacheList: [i], cacheMap: new Map([[0, i]])};
        return this._cachedMapping.set(e, n), e.on("change:children", this._invalidateOnChildrenChangeCallback), e.on("change:text", this._invalidateOnTextChangeCallback), i
    }

    stopTracking(e) {
        e.off("change:children", this._invalidateOnChildrenChangeCallback), e.off("change:text", this._invalidateOnTextChangeCallback), this._cachedMapping.delete(e)
    }

    _clearCacheInsideParent(e, t) {
        if (t == 0) this._cachedMapping.has(e) ? this._clearCacheAll(e) : this._clearCacheInsideParent(e.parent, e.index); else {
            const i = e.getChild(t - 1);
            this._clearCacheAfter(i)
        }
    }

    _clearCacheAll(e) {
        const t = this._cachedMapping.get(e);
        t.maxModelOffset > 0 && (t.maxModelOffset = 0, t.cacheList.length = 1, t.cacheMap.clear(), t.cacheMap.set(0, t.cacheList[0]))
    }

    _clearCacheAfter(e) {
        const t = this._nodeToCacheListIndex.get(e);
        if (t === void 0) {
            const n = e.parent;
            this._cachedMapping.has(n) || this._clearCacheInsideParent(n.parent, n.index);
            return
        }
        let i = e.parent;
        for (; !this._cachedMapping.has(i);) i = i.parent;
        this._clearCacheFromCacheIndex(i, t)
    }

    _clearCacheFromCacheIndex(e, t) {
        t === 0 && (t = 1);
        const i = this._cachedMapping.get(e), n = i.cacheList[t - 1];
        if (!n) return;
        i.maxModelOffset = n.modelOffset;
        const o = i.cacheList.splice(t);
        for (const r of o) {
            i.cacheMap.delete(r.modelOffset);
            const a = r.viewPosition.nodeBefore;
            this._nodeToCacheListIndex.delete(a)
        }
    }

    _findInCacheList(e, t) {
        let i = 0, n = e.length - 1, o = n - i >> 1, r = e[o];
        for (; i < n;) r.modelOffset < t ? i = o + 1 : n = o - 1, o = i + (n - i >> 1), r = e[o];
        return r.modelOffset <= t ? r : e[o - 1]
    }
}

class Cb {
    _consumable = new Map;
    _textProxyRegistry = new Map;

    add(e, t) {
        t = ts(t), e instanceof et && (e = this._getSymbolForTextProxy(e)), this._consumable.has(e) || this._consumable.set(e, new Map), this._consumable.get(e).set(t, !0)
    }

    consume(e, t) {
        return t = ts(t), e instanceof et && (e = this._getSymbolForTextProxy(e)), this.test(e, t) ? (this._consumable.get(e).set(t, !1), !0) : !1
    }

    test(e, t) {
        t = ts(t), e instanceof et && (e = this._getSymbolForTextProxy(e));
        const i = this._consumable.get(e);
        if (i === void 0) return null;
        const n = i.get(t);
        return n === void 0 ? null : n
    }

    revert(e, t) {
        t = ts(t), e instanceof et && (e = this._getSymbolForTextProxy(e));
        const i = this.test(e, t);
        return i === !1 ? (this._consumable.get(e).set(t, !0), !0) : i === !0 ? !1 : null
    }

    verifyAllConsumed(e) {
        const t = [];
        for (const [i, n] of this._consumable) for (const [o, r] of n) {
            const a = o.split(":")[0];
            r && e == a && t.push({event: o, item: i.name || i.description})
        }
        if (t.length) throw new p("conversion-model-consumable-not-consumed", null, {items: t})
    }

    _getSymbolForTextProxy(e) {
        let t = null;
        const i = this._textProxyRegistry.get(e.startOffset);
        if (i) {
            const n = i.get(e.endOffset);
            n && (t = n.get(e.parent))
        }
        return t || (t = this._addSymbolForTextProxy(e)), t
    }

    _addSymbolForTextProxy(e) {
        const t = e.startOffset, i = e.endOffset, n = e.parent, o = Symbol("$textProxy:" + e.data);
        let r, a;
        return r = this._textProxyRegistry.get(t), r || (r = new Map, this._textProxyRegistry.set(t, r)), a = r.get(i), a || (a = new Map, r.set(i, a)), a.set(n, o), o
    }
}

function ts(s) {
    const e = s.split(":");
    return e[0] == "insert" ? e[0] : e[0] == "addMarker" || e[0] == "removeMarker" ? s : e.length > 1 ? e[0] + ":" + e[1] : e[0]
}

class Oh extends W() {
    _conversionApi;
    _firedEventsMap;

    constructor(e) {
        super(), this._conversionApi = {dispatcher: this, ...e}, this._firedEventsMap = new WeakMap
    }

    convertChanges(e, t, i) {
        const n = this._createConversionApi(i, e.getRefreshedItems());
        for (const r of e.getMarkersToRemove()) this._convertMarkerRemove(r.name, r.range, n);
        const o = this._reduceChanges(e.getChanges());
        for (const r of o) r.type === "insert" ? this._convertInsert(b._createFromPositionAndShift(r.position, r.length), n) : r.type === "reinsert" ? this._convertReinsert(b._createFromPositionAndShift(r.position, r.length), n) : r.type === "remove" ? this._convertRemove(r.position, r.length, r.name, n) : this._convertAttribute(r.range, r.attributeKey, r.attributeOldValue, r.attributeNewValue, n);
        n.mapper.flushDeferredBindings();
        for (const r of n.mapper.flushUnboundMarkerNames()) {
            const a = t.get(r).getRange();
            this._convertMarkerRemove(r, a, n), this._convertMarkerAdd(r, a, n)
        }
        for (const r of e.getMarkersToAdd()) this._convertMarkerAdd(r.name, r.range, n);
        n.consumable.verifyAllConsumed("insert")
    }

    convert(e, t, i, n = {}) {
        const o = this._createConversionApi(i, void 0, n);
        this._convertInsert(e, o);
        for (const [r, a] of t) this._convertMarkerAdd(r, a, o);
        o.consumable.verifyAllConsumed("insert")
    }

    convertSelection(e, t, i) {
        const n = this._createConversionApi(i);
        this.fire("cleanSelection", {selection: e}, n);
        const o = e.getFirstPosition().root;
        if (!n.mapper.toViewElement(o)) return;
        const r = Array.from(t.getMarkersAtPosition(e.getFirstPosition()));
        if (this._addConsumablesForSelection(n.consumable, e, r), this.fire("selection", {selection: e}, n), !!e.isCollapsed) {
            for (const a of r) if (n.consumable.test(e, "addMarker:" + a.name)) {
                const l = a.getRange();
                if (!Eb(e.getFirstPosition(), a, n.mapper)) continue;
                const c = {item: e, markerName: a.name, markerRange: l};
                this.fire(`addMarker:${a.name}`, c, n)
            }
            for (const a of e.getAttributeKeys()) if (n.consumable.test(e, "attribute:" + a)) {
                const l = {
                    item: e,
                    range: e.getFirstRange(),
                    attributeKey: a,
                    attributeOldValue: null,
                    attributeNewValue: e.getAttribute(a)
                };
                this.fire(`attribute:${a}:$text`, l, n)
            }
        }
    }

    _convertInsert(e, t, i = {}) {
        i.doNotAddConsumables || this._addConsumablesForInsert(t.consumable, e);
        for (const n of e.getWalker({shallow: !0})) this._testAndFire("insert", Cl(n), t)
    }

    _convertRemove(e, t, i, n) {
        this.fire(`remove:${i}`, {position: e, length: t}, n)
    }

    _convertAttribute(e, t, i, n, o) {
        this._addConsumablesForRange(o.consumable, e, `attribute:${t}`);
        for (const r of e) {
            const a = {
                item: r.item,
                range: b._createFromPositionAndShift(r.previousPosition, r.length),
                attributeKey: t,
                attributeOldValue: i,
                attributeNewValue: n
            };
            this._testAndFire(`attribute:${t}`, a, o)
        }
    }

    _convertReinsert(e, t) {
        const i = Array.from(e.getWalker({shallow: !0}));
        this._addConsumablesForInsert(t.consumable, i);
        for (const n of i.map(Cl)) this._testAndFire("insert", {...n, reconversion: !0}, t)
    }

    _convertMarkerAdd(e, t, i) {
        if (t.root.rootName == "$graveyard") return;
        const n = `addMarker:${e}`;
        if (i.consumable.add(t, n), this.fire(n, {markerName: e, markerRange: t}, i), !!i.consumable.consume(t, n)) {
            this._addConsumablesForRange(i.consumable, t, n);
            for (const o of t.getItems()) {
                if (!i.consumable.test(o, n)) continue;
                const r = {item: o, range: b._createOn(o), markerName: e, markerRange: t};
                this.fire(n, r, i)
            }
        }
    }

    _convertMarkerRemove(e, t, i) {
        t.root.rootName != "$graveyard" && this.fire(`removeMarker:${e}`, {markerName: e, markerRange: t}, i)
    }

    _reduceChanges(e) {
        const t = {changes: e};
        return this.fire("reduceChanges", t), t.changes
    }

    _addConsumablesForInsert(e, t) {
        for (const i of t) {
            const n = i.item;
            if (e.test(n, "insert") === null) {
                e.add(n, "insert");
                for (const o of n.getAttributeKeys()) e.add(n, "attribute:" + o)
            }
        }
        return e
    }

    _addConsumablesForRange(e, t, i) {
        for (const n of t.getItems()) e.add(n, i);
        return e
    }

    _addConsumablesForSelection(e, t, i) {
        e.add(t, "selection");
        for (const n of i) e.add(t, "addMarker:" + n.name);
        for (const n of t.getAttributeKeys()) e.add(t, "attribute:" + n);
        return e
    }

    _testAndFire(e, t, i) {
        const n = Tb(e, t), o = t.item.is("$textProxy") ? i.consumable._getSymbolForTextProxy(t.item) : t.item,
            r = this._firedEventsMap.get(i), a = r.get(o);
        if (!a) r.set(o, new Set([n])); else if (!a.has(n)) a.add(n); else return;
        this.fire(n, t, i)
    }

    _testAndFireAddAttributes(e, t) {
        const i = {item: e, range: b._createOn(e)};
        for (const n of i.item.getAttributeKeys()) i.attributeKey = n, i.attributeOldValue = null, i.attributeNewValue = i.item.getAttribute(n), this._testAndFire(`attribute:${n}`, i, t)
    }

    _createConversionApi(e, t = new Set, i = {}) {
        const n = {
            ...this._conversionApi,
            consumable: new Cb,
            writer: e,
            options: i,
            convertItem: o => this._convertInsert(b._createOn(o), n),
            convertChildren: o => this._convertInsert(b._createIn(o), n, {doNotAddConsumables: !0}),
            convertAttributes: o => this._testAndFireAddAttributes(o, n),
            canReuseView: o => !t.has(n.mapper.toModelElement(o))
        };
        return this._firedEventsMap.set(n, new Map), n
    }
}

function Eb(s, e, t) {
    const i = e.getRange(), n = Array.from(s.getAncestors());
    return n.shift(), n.reverse(), !n.some(r => {
        if (i.containsItem(r)) return !!t.toViewElement(r).getCustomProperty("addHighlight")
    })
}

function Tb(s, e) {
    const t = e.item.is("element") ? e.item.name : "$text";
    return `${s}:${t}`
}

function Cl(s) {
    return {item: s.item, range: b._createFromPositionAndShift(s.previousPosition, s.length)}
}

let ai = class extends qt {
    parent = null;
    _attrs;
    _index = null;
    _startOffset = null;

    constructor(e) {
        super(), this._attrs = nt(e)
    }

    get document() {
        return null
    }

    get index() {
        return this._index
    }

    get startOffset() {
        return this._startOffset
    }

    get offsetSize() {
        return 1
    }

    get endOffset() {
        return this.startOffset === null ? null : this.startOffset + this.offsetSize
    }

    get nextSibling() {
        const e = this.index;
        return e !== null && this.parent.getChild(e + 1) || null
    }

    get previousSibling() {
        const e = this.index;
        return e !== null && this.parent.getChild(e - 1) || null
    }

    get root() {
        let e = this;
        for (; e.parent;) e = e.parent;
        return e
    }

    isAttached() {
        return this.parent === null ? !1 : this.root.isAttached()
    }

    getPath() {
        const e = [];
        let t = this;
        for (; t.parent;) e.unshift(t.startOffset), t = t.parent;
        return e
    }

    getAncestors(e = {}) {
        const t = [];
        let i = e.includeSelf ? this : this.parent;
        for (; i;) t[e.parentFirst ? "push" : "unshift"](i), i = i.parent;
        return t
    }

    getCommonAncestor(e, t = {}) {
        const i = this.getAncestors(t), n = e.getAncestors(t);
        let o = 0;
        for (; i[o] == n[o] && i[o];) o++;
        return o === 0 ? null : i[o - 1]
    }

    isBefore(e) {
        if (this == e || this.root !== e.root) return !1;
        const t = this.getPath(), i = e.getPath(), n = _e(t, i);
        switch (n) {
            case"prefix":
                return !0;
            case"extension":
                return !1;
            default:
                return t[n] < i[n]
        }
    }

    isAfter(e) {
        return this == e || this.root !== e.root ? !1 : !this.isBefore(e)
    }

    hasAttribute(e) {
        return this._attrs.has(e)
    }

    getAttribute(e) {
        return this._attrs.get(e)
    }

    getAttributes() {
        return this._attrs.entries()
    }

    getAttributeKeys() {
        return this._attrs.keys()
    }

    toJSON() {
        const e = {};
        return this._attrs.size && (e.attributes = Array.from(this._attrs).reduce((t, i) => (t[i[0]] = i[1], t), {})), e
    }

    _clone(e) {
        return new this.constructor(this._attrs)
    }

    _remove() {
        this.parent._removeChildren(this.index)
    }

    _setAttribute(e, t) {
        this._attrs.set(e, t)
    }

    _setAttributesTo(e) {
        this._attrs = nt(e)
    }

    _removeAttribute(e) {
        return this._attrs.delete(e)
    }

    _clearAttributes() {
        this._attrs.clear()
    }
};
ai.prototype.is = function (s) {
    return s === "node" || s === "model:node"
};

class Fe extends W(qt) {
    _lastRangeBackward = !1;
    _attrs = new Map;
    _ranges = [];

    constructor(...e) {
        super(), e.length && this.setTo(...e)
    }

    get anchor() {
        if (this._ranges.length > 0) {
            const e = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e.end : e.start
        }
        return null
    }

    get focus() {
        if (this._ranges.length > 0) {
            const e = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? e.start : e.end
        }
        return null
    }

    get isCollapsed() {
        return this._ranges.length === 1 ? this._ranges[0].isCollapsed : !1
    }

    get rangeCount() {
        return this._ranges.length
    }

    get isBackward() {
        return !this.isCollapsed && this._lastRangeBackward
    }

    isEqual(e) {
        if (this.rangeCount != e.rangeCount) return !1;
        if (this.rangeCount === 0) return !0;
        if (!this.anchor.isEqual(e.anchor) || !this.focus.isEqual(e.focus)) return !1;
        for (const t of this._ranges) {
            let i = !1;
            for (const n of e._ranges) if (t.isEqual(n)) {
                i = !0;
                break
            }
            if (!i) return !1
        }
        return !0
    }

    * getRanges() {
        for (const e of this._ranges) yield new b(e.start, e.end)
    }

    getFirstRange() {
        let e = null;
        for (const t of this._ranges) (!e || t.start.isBefore(e.start)) && (e = t);
        return e ? new b(e.start, e.end) : null
    }

    getLastRange() {
        let e = null;
        for (const t of this._ranges) (!e || t.end.isAfter(e.end)) && (e = t);
        return e ? new b(e.start, e.end) : null
    }

    getFirstPosition() {
        const e = this.getFirstRange();
        return e ? e.start.clone() : null
    }

    getLastPosition() {
        const e = this.getLastRange();
        return e ? e.end.clone() : null
    }

    setTo(...e) {
        let [t, i, n] = e;
        if (typeof i == "object" && (n = i, i = void 0), t === null) this._setRanges([]); else if (t instanceof Fe) this._setRanges(t.getRanges(), t.isBackward); else if (t && typeof t.getRanges == "function") this._setRanges(t.getRanges(), t.isBackward); else if (t instanceof b) this._setRanges([t], !!n && !!n.backward); else if (t instanceof y) this._setRanges([new b(t)]); else if (t instanceof ai) {
            const o = !!n && !!n.backward;
            let r;
            if (i == "in") r = b._createIn(t); else if (i == "on") r = b._createOn(t); else if (i !== void 0) r = new b(y._createAt(t, i)); else throw new p("model-selection-setto-required-second-parameter", [this, t]);
            this._setRanges([r], o)
        } else if (ze(t)) this._setRanges(t, n && !!n.backward); else throw new p("model-selection-setto-not-selectable", [this, t])
    }

    _setRanges(e, t = !1) {
        const i = Array.from(e), n = i.some(o => {
            if (!(o instanceof b)) throw new p("model-selection-set-ranges-not-range", [this, e]);
            return this._ranges.every(r => !r.isEqual(o))
        });
        i.length === this._ranges.length && !n || (this._replaceAllRanges(i), this._lastRangeBackward = !!t, this.fire("change:range", {directChange: !0}))
    }

    setFocus(e, t) {
        if (this.anchor === null) throw new p("model-selection-setfocus-no-ranges", [this, e]);
        const i = y._createAt(e, t);
        if (i.compareWith(this.focus) == "same") return;
        const n = this.anchor;
        this._ranges.length && this._popRange(), i.compareWith(n) == "before" ? (this._pushRange(new b(i, n)), this._lastRangeBackward = !0) : (this._pushRange(new b(n, i)), this._lastRangeBackward = !1), this.fire("change:range", {directChange: !0})
    }

    getAttribute(e) {
        return this._attrs.get(e)
    }

    getAttributes() {
        return this._attrs.entries()
    }

    getAttributeKeys() {
        return this._attrs.keys()
    }

    hasAttribute(e) {
        return this._attrs.has(e)
    }

    removeAttribute(e) {
        this.hasAttribute(e) && (this._attrs.delete(e), this.fire("change:attribute", {
            attributeKeys: [e],
            directChange: !0
        }))
    }

    setAttribute(e, t) {
        this.getAttribute(e) !== t && (this._attrs.set(e, t), this.fire("change:attribute", {
            attributeKeys: [e],
            directChange: !0
        }))
    }

    getSelectedElement() {
        return this.rangeCount !== 1 ? null : this.getFirstRange().getContainedElement()
    }

    * getSelectedBlocks() {
        const e = new WeakSet;
        for (const t of this.getRanges()) {
            const i = El(t.start, e);
            xb(i, t) && (yield i);
            const n = t.getWalker();
            for (const r of n) {
                const a = r.item;
                r.type == "elementEnd" && Ab(a, e, t) ? yield a : r.type == "elementStart" && a.is("model:element") && a.root.document.model.schema.isBlock(a) && n.jumpTo(y._createAt(a, "end"))
            }
            const o = El(t.end, e);
            Ib(o, t) && (yield o)
        }
    }

    containsEntireContent(e = this.anchor.root) {
        const t = y._createAt(e, 0), i = y._createAt(e, "end");
        return t.isTouching(this.getFirstPosition()) && i.isTouching(this.getLastPosition())
    }

    _pushRange(e) {
        this._checkRange(e), this._ranges.push(new b(e.start, e.end))
    }

    _checkRange(e) {
        for (let t = 0; t < this._ranges.length; t++) if (e.isIntersecting(this._ranges[t])) throw new p("model-selection-range-intersects", [this, e], {
            addedRange: e,
            intersectingRange: this._ranges[t]
        })
    }

    _replaceAllRanges(e) {
        this._removeAllRanges();
        for (const t of e) this._pushRange(t)
    }

    _removeAllRanges() {
        for (; this._ranges.length > 0;) this._popRange()
    }

    _popRange() {
        this._ranges.pop()
    }
}

Fe.prototype.is = function (s) {
    return s === "selection" || s === "model:selection"
};

function Mh(s, e) {
    return e.has(s) ? !1 : (e.add(s), s.root.document.model.schema.isBlock(s) && !!s.parent)
}

function Ab(s, e, t) {
    return Mh(s, e) && aa(s, t)
}

function El(s, e) {
    const i = s.parent.root.document.model.schema, n = s.parent.getAncestors({parentFirst: !0, includeSelf: !0});
    let o = !1;
    const r = n.find(a => o ? !1 : (o = i.isLimit(a), !o && Mh(a, e)));
    return n.forEach(a => e.add(a)), r
}

function aa(s, e) {
    const t = Sb(s);
    return t ? !e.containsRange(b._createOn(t), !0) : !0
}

function xb(s, e) {
    return s ? e.isCollapsed || s.isEmpty ? !0 : e.start.isTouching(y._createAt(s, s.maxOffset)) ? !1 : aa(s, e) : !1
}

function Ib(s, e) {
    return s ? e.isCollapsed || s.isEmpty ? !0 : e.end.isTouching(y._createAt(s, 0)) ? !1 : aa(s, e) : !1
}

function Sb(s) {
    const e = s.root.document.model.schema;
    let t = s.parent;
    for (; t;) {
        if (e.isBlock(t)) return t;
        t = t.parent
    }
}

class Ce extends W(b) {
    constructor(e, t) {
        super(e, t), Pb.call(this)
    }

    detach() {
        this.stopListening()
    }

    toRange() {
        return new b(this.start, this.end)
    }

    static fromRange(e) {
        return new Ce(e.start, e.end)
    }
}

Ce.prototype.is = function (s) {
    return s === "liveRange" || s === "model:liveRange" || s == "range" || s === "model:range"
};

function Pb() {
    this.listenTo(this.root.document.model, "applyOperation", (s, e) => {
        const t = e[0];
        t.isDocumentOperation && Rb.call(this, t)
    }, {priority: "low"})
}

function Rb(s) {
    const e = this.getTransformedByOperation(s), t = b._createFromRanges(e), i = !t.isEqual(this), n = Vb(this, s);
    let o = null;
    if (i) {
        t.root.rootName == "$graveyard" && (s.type == "remove" ? o = s.sourcePosition : o = s.deletionPosition);
        const r = this.toRange();
        this.start = t.start, this.end = t.end, this.fire("change:range", r, {deletionPosition: o})
    } else n && this.fire("change:content", this.toRange(), {deletionPosition: o})
}

function Vb(s, e) {
    switch (e.type) {
        case"insert":
            return s.containsPosition(e.position);
        case"move":
        case"remove":
        case"reinsert":
        case"merge":
            return s.containsPosition(e.sourcePosition) || s.start.isEqual(e.sourcePosition) || s.containsPosition(e.targetPosition);
        case"split":
            return s.containsPosition(e.splitPosition) || s.containsPosition(e.insertionPosition)
    }
    return !1
}

class G extends ai {
    _data;

    constructor(e, t) {
        super(t), this._data = e || ""
    }

    get offsetSize() {
        return this.data.length
    }

    get data() {
        return this._data
    }

    toJSON() {
        const e = super.toJSON();
        return e.data = this.data, e
    }

    _clone() {
        return new G(this.data, this.getAttributes())
    }

    static fromJSON(e) {
        return new G(e.data, e.attributes)
    }
}

G.prototype.is = function (s) {
    return s === "$text" || s === "model:$text" || s === "text" || s === "model:text" || s === "node" || s === "model:node"
};
const In = "selection:";

class st extends W(qt) {
    _selection;

    constructor(e) {
        super(), this._selection = new Ob(e), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this)
    }

    get isCollapsed() {
        return this._selection.isCollapsed
    }

    get anchor() {
        return this._selection.anchor
    }

    get focus() {
        return this._selection.focus
    }

    get rangeCount() {
        return this._selection.rangeCount
    }

    get hasOwnRange() {
        return this._selection.hasOwnRange
    }

    get isBackward() {
        return this._selection.isBackward
    }

    get isGravityOverridden() {
        return this._selection.isGravityOverridden
    }

    get markers() {
        return this._selection.markers
    }

    get _ranges() {
        return this._selection._ranges
    }

    getRanges() {
        return this._selection.getRanges()
    }

    getFirstPosition() {
        return this._selection.getFirstPosition()
    }

    getLastPosition() {
        return this._selection.getLastPosition()
    }

    getFirstRange() {
        return this._selection.getFirstRange()
    }

    getLastRange() {
        return this._selection.getLastRange()
    }

    getSelectedBlocks() {
        return this._selection.getSelectedBlocks()
    }

    getSelectedElement() {
        return this._selection.getSelectedElement()
    }

    containsEntireContent(e) {
        return this._selection.containsEntireContent(e)
    }

    destroy() {
        this._selection.destroy()
    }

    getAttributeKeys() {
        return this._selection.getAttributeKeys()
    }

    getAttributes() {
        return this._selection.getAttributes()
    }

    getAttribute(e) {
        return this._selection.getAttribute(e)
    }

    hasAttribute(e) {
        return this._selection.hasAttribute(e)
    }

    refresh() {
        this._selection.updateMarkers(), this._selection._updateAttributes(!1)
    }

    observeMarkers(e) {
        this._selection.observeMarkers(e)
    }

    _setFocus(e, t) {
        this._selection.setFocus(e, t)
    }

    _setTo(...e) {
        this._selection.setTo(...e)
    }

    _setAttribute(e, t) {
        this._selection.setAttribute(e, t)
    }

    _removeAttribute(e) {
        this._selection.removeAttribute(e)
    }

    _getStoredAttributes() {
        return this._selection.getStoredAttributes()
    }

    _overrideGravity() {
        return this._selection.overrideGravity()
    }

    _restoreGravity(e) {
        this._selection.restoreGravity(e)
    }

    static _getStoreAttributeKey(e) {
        return In + e
    }

    static _isStoreAttributeKey(e) {
        return e.startsWith(In)
    }
}

st.prototype.is = function (s) {
    return s === "selection" || s == "model:selection" || s == "documentSelection" || s == "model:documentSelection"
};

class Ob extends Fe {
    markers = new ce({idProperty: "name"});
    _model;
    _document;
    _attributePriority = new Map;
    _selectionRestorePosition = null;
    _hasChangedRange = !1;
    _overriddenGravityRegister = new Set;
    _observedMarkers = new Set;

    constructor(e) {
        super(), this._model = e.model, this._document = e, this.listenTo(this._model, "applyOperation", (t, i) => {
            const n = i[0];
            !n.isDocumentOperation || n.type == "marker" || n.type == "rename" || n.type == "noop" || (this._ranges.length == 0 && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = !1, this.fire("change:range", {directChange: !1})))
        }, {priority: "lowest"}), this.on("change:range", () => {
            this._validateSelectionRanges(this.getRanges())
        }), this.listenTo(this._model.markers, "update", (t, i, n, o) => {
            this._updateMarker(i, o)
        }), this.listenTo(this._document, "change", (t, i) => {
            Mb(this._model, i)
        })
    }

    get isCollapsed() {
        return this._ranges.length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed
    }

    get anchor() {
        return super.anchor || this._document._getDefaultRange().start
    }

    get focus() {
        return super.focus || this._document._getDefaultRange().end
    }

    get rangeCount() {
        return this._ranges.length ? this._ranges.length : 1
    }

    get hasOwnRange() {
        return this._ranges.length > 0
    }

    get isGravityOverridden() {
        return !!this._overriddenGravityRegister.size
    }

    destroy() {
        for (let e = 0; e < this._ranges.length; e++) this._ranges[e].detach();
        this.stopListening()
    }

    * getRanges() {
        this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange()
    }

    getFirstRange() {
        return super.getFirstRange() || this._document._getDefaultRange()
    }

    getLastRange() {
        return super.getLastRange() || this._document._getDefaultRange()
    }

    setTo(...e) {
        super.setTo(...e), this._updateAttributes(!0), this.updateMarkers()
    }

    setFocus(e, t) {
        super.setFocus(e, t), this._updateAttributes(!0), this.updateMarkers()
    }

    setAttribute(e, t) {
        if (this._setAttribute(e, t)) {
            const i = [e];
            this.fire("change:attribute", {attributeKeys: i, directChange: !0})
        }
    }

    removeAttribute(e) {
        if (this._removeAttribute(e)) {
            const t = [e];
            this.fire("change:attribute", {attributeKeys: t, directChange: !0})
        }
    }

    overrideGravity() {
        const e = pe();
        return this._overriddenGravityRegister.add(e), this._overriddenGravityRegister.size === 1 && this._updateAttributes(!0), e
    }

    restoreGravity(e) {
        if (!this._overriddenGravityRegister.has(e)) throw new p("document-selection-gravity-wrong-restore", this, {uid: e});
        this._overriddenGravityRegister.delete(e), this.isGravityOverridden || this._updateAttributes(!0)
    }

    observeMarkers(e) {
        this._observedMarkers.add(e), this.updateMarkers()
    }

    _replaceAllRanges(e) {
        this._validateSelectionRanges(e), super._replaceAllRanges(e)
    }

    _popRange() {
        this._ranges.pop().detach()
    }

    _pushRange(e) {
        const t = this._prepareRange(e);
        t && this._ranges.push(t)
    }

    _validateSelectionRanges(e) {
        for (const t of e) if (!this._document._validateSelectionRange(t)) throw new p("document-selection-wrong-position", this, {range: t})
    }

    _prepareRange(e) {
        if (this._checkRange(e), e.root == this._document.graveyard) return;
        const t = Ce.fromRange(e);
        return t.on("change:range", (i, n, o) => {
            if (this._hasChangedRange = !0, t.root == this._document.graveyard) {
                this._selectionRestorePosition = o.deletionPosition;
                const r = this._ranges.indexOf(t);
                this._ranges.splice(r, 1), t.detach()
            }
        }), t
    }

    updateMarkers() {
        if (!this._observedMarkers.size) return;
        const e = [];
        let t = !1;
        for (const n of this._model.markers) {
            const o = n.name.split(":", 1)[0];
            if (!this._observedMarkers.has(o)) continue;
            const r = n.getRange();
            for (const a of this.getRanges()) r.containsRange(a, !a.isCollapsed) && e.push(n)
        }
        const i = Array.from(this.markers);
        for (const n of e) this.markers.has(n) || (this.markers.add(n), t = !0);
        for (const n of Array.from(this.markers)) e.includes(n) || (this.markers.remove(n), t = !0);
        t && this.fire("change:marker", {oldMarkers: i, directChange: !1})
    }

    _updateMarker(e, t) {
        const i = e.name.split(":", 1)[0];
        if (!this._observedMarkers.has(i)) return;
        let n = !1;
        const o = Array.from(this.markers), r = this.markers.has(e);
        if (!t) r && (this.markers.remove(e), n = !0); else {
            let a = !1;
            for (const l of this.getRanges()) if (t.containsRange(l, !l.isCollapsed)) {
                a = !0;
                break
            }
            a && !r ? (this.markers.add(e), n = !0) : !a && r && (this.markers.remove(e), n = !0)
        }
        n && this.fire("change:marker", {oldMarkers: o, directChange: !1})
    }

    _updateAttributes(e) {
        const t = nt(this._getSurroundingAttributes()), i = nt(this.getAttributes());
        if (e) this._attributePriority = new Map, this._attrs = new Map; else for (const [o, r] of this._attributePriority) r == "low" && (this._attrs.delete(o), this._attributePriority.delete(o));
        this._setAttributesTo(t);
        const n = [];
        for (const [o, r] of this.getAttributes()) (!i.has(o) || i.get(o) !== r) && n.push(o);
        for (const [o] of i) this.hasAttribute(o) || n.push(o);
        n.length > 0 && this.fire("change:attribute", {attributeKeys: n, directChange: !1})
    }

    _setAttribute(e, t, i = !0) {
        const n = i ? "normal" : "low";
        return n == "low" && this._attributePriority.get(e) == "normal" || super.getAttribute(e) === t ? !1 : (this._attrs.set(e, t), this._attributePriority.set(e, n), !0)
    }

    _removeAttribute(e, t = !0) {
        const i = t ? "normal" : "low";
        return i == "low" && this._attributePriority.get(e) == "normal" || (this._attributePriority.set(e, i), !super.hasAttribute(e)) ? !1 : (this._attrs.delete(e), !0)
    }

    _setAttributesTo(e) {
        const t = new Set;
        for (const [i, n] of this.getAttributes()) e.get(i) !== n && this._removeAttribute(i, !1);
        for (const [i, n] of e) this._setAttribute(i, n, !1) && t.add(i);
        return t
    }

    * getStoredAttributes() {
        const e = this.getFirstPosition().parent;
        if (this.isCollapsed && e.isEmpty) for (const t of e.getAttributeKeys()) t.startsWith(In) && (yield[t.substr(In.length), e.getAttribute(t)])
    }

    _getSurroundingAttributes() {
        const e = this.getFirstPosition(), t = this._model.schema;
        if (e.root.rootName == "$graveyard") return null;
        let i = null;
        if (this.isCollapsed) {
            const n = e.textNode ? e.textNode : e.nodeBefore, o = e.textNode ? e.textNode : e.nodeAfter;
            if (this.isGravityOverridden || (i = on(n, t)), i || (i = on(o, t)), !this.isGravityOverridden && !i) {
                let r = n;
                for (; r && !i;) r = r.previousSibling, i = on(r, t)
            }
            if (!i) {
                let r = o;
                for (; r && !i;) r = r.nextSibling, i = on(r, t)
            }
            i || (i = this.getStoredAttributes())
        } else {
            const n = this.getFirstRange();
            for (const o of n) {
                if (o.item.is("element") && t.isObject(o.item)) {
                    i = on(o.item, t);
                    break
                }
                if (o.type == "text") {
                    i = o.item.getAttributes();
                    break
                }
            }
        }
        return i
    }

    _fixGraveyardSelection(e) {
        const t = this._model.schema.getNearestSelectionRange(e);
        t && this._pushRange(t)
    }
}

function on(s, e) {
    if (!s) return null;
    if (s instanceof et || s instanceof G) return s.getAttributes();
    if (!e.isInline(s)) return null;
    if (!e.isObject(s)) return [];
    const t = [];
    for (const [i, n] of s.getAttributes()) e.checkAttribute("$text", i) && e.getAttributeProperties(i).copyFromObject !== !1 && t.push([i, n]);
    return t
}

function Mb(s, e) {
    const t = s.document.differ;
    for (const i of t.getChanges()) {
        if (i.type != "insert") continue;
        const n = i.position.parent;
        i.length === n.maxOffset && s.enqueueChange(e, r => {
            const a = Array.from(n.getAttributeKeys()).filter(l => l.startsWith(In));
            for (const l of a) r.removeAttribute(l, n)
        })
    }
}

class kn {
    _nodes = [];
    _offsetToNode = [];

    constructor(e) {
        e && this._insertNodes(0, e)
    }

    [Symbol.iterator]() {
        return this._nodes[Symbol.iterator]()
    }

    get length() {
        return this._nodes.length
    }

    get maxOffset() {
        return this._offsetToNode.length
    }

    getNode(e) {
        return this._nodes[e] || null
    }

    getNodeAtOffset(e) {
        return this._offsetToNode[e] || null
    }

    getNodeIndex(e) {
        return e.index
    }

    getNodeStartOffset(e) {
        return e.startOffset
    }

    indexToOffset(e) {
        if (e == this._nodes.length) return this.maxOffset;
        const t = this._nodes[e];
        if (!t) throw new p("model-nodelist-index-out-of-bounds", this);
        return this.getNodeStartOffset(t)
    }

    offsetToIndex(e) {
        if (e == this._offsetToNode.length) return this._nodes.length;
        const t = this._offsetToNode[e];
        if (!t) throw new p("model-nodelist-offset-out-of-bounds", this, {offset: e, nodeList: this});
        return this.getNodeIndex(t)
    }

    _insertNodes(e, t) {
        const i = [];
        for (const o of t) {
            if (!(o instanceof ai)) throw new p("model-nodelist-insertnodes-not-node", this);
            i.push(o)
        }
        let n = this.indexToOffset(e);
        al(this._nodes, i, e), al(this._offsetToNode, Bb(i), n);
        for (let o = e; o < this._nodes.length; o++) this._nodes[o]._index = o, this._nodes[o]._startOffset = n, n += this._nodes[o].offsetSize
    }

    _removeNodes(e, t = 1) {
        if (t == 0) return [];
        let i = this.indexToOffset(e);
        const n = this._nodes.splice(e, t), o = n[n.length - 1], r = o.startOffset + o.offsetSize - i;
        this._offsetToNode.splice(i, r);
        for (const a of n) a._index = null, a._startOffset = null;
        for (let a = e; a < this._nodes.length; a++) this._nodes[a]._index = a, this._nodes[a]._startOffset = i, i += this._nodes[a].offsetSize;
        return n
    }

    _removeNodesArray(e) {
        if (e.length == 0) return;
        for (const i of e) i._index = null, i._startOffset = null;
        this._nodes = this._nodes.filter(i => i.index !== null), this._offsetToNode = this._offsetToNode.filter(i => i.index !== null);
        let t = 0;
        for (let i = 0; i < this._nodes.length; i++) this._nodes[i]._index = i, this._nodes[i]._startOffset = t, t += this._nodes[i].offsetSize
    }

    toJSON() {
        return this._nodes.map(e => e.toJSON())
    }
}

function Bb(s) {
    const e = [];
    let t = 0;
    for (const i of s) for (let n = 0; n < i.offsetSize; n++) e[t++] = i;
    return e
}

class j extends ai {
    name;
    _children = new kn;

    constructor(e, t, i) {
        super(t), this.name = e, i && this._insertChild(0, i)
    }

    get childCount() {
        return this._children.length
    }

    get maxOffset() {
        return this._children.maxOffset
    }

    get isEmpty() {
        return this.childCount === 0
    }

    getChild(e) {
        return this._children.getNode(e)
    }

    getChildAtOffset(e) {
        return this._children.getNodeAtOffset(e)
    }

    getChildren() {
        return this._children[Symbol.iterator]()
    }

    getChildIndex(e) {
        return this._children.getNodeIndex(e)
    }

    getChildStartOffset(e) {
        return this._children.getNodeStartOffset(e)
    }

    offsetToIndex(e) {
        return this._children.offsetToIndex(e)
    }

    getNodeByPath(e) {
        let t = this;
        for (const i of e) t = t.getChildAtOffset(i);
        return t
    }

    findAncestor(e, t = {}) {
        let i = t.includeSelf ? this : this.parent;
        for (; i;) {
            if (i.name === e) return i;
            i = i.parent
        }
        return null
    }

    toJSON() {
        const e = super.toJSON();
        if (e.name = this.name, this._children.length > 0) {
            e.children = [];
            for (const t of this._children) e.children.push(t.toJSON())
        }
        return e
    }

    _clone(e = !1) {
        const t = e ? Lb(this._children) : void 0;
        return new j(this.name, this.getAttributes(), t)
    }

    _appendChild(e) {
        this._insertChild(this.childCount, e)
    }

    _insertChild(e, t) {
        const i = Fb(t);
        for (const n of i) n.parent !== null && n._remove(), n.parent = this;
        this._children._insertNodes(e, i)
    }

    _removeChildren(e, t = 1) {
        const i = this._children._removeNodes(e, t);
        for (const n of i) n.parent = null;
        return i
    }

    _removeChildrenArray(e) {
        this._children._removeNodesArray(e);
        for (const t of e) t.parent = null
    }

    static fromJSON(e) {
        let t;
        if (e.children) {
            t = [];
            for (const i of e.children) i.name ? t.push(j.fromJSON(i)) : t.push(G.fromJSON(i))
        }
        return new j(e.name, e.attributes, t)
    }
}

j.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "element" || s === "model:element") : s === "element" || s === "model:element" || s === "node" || s === "model:node"
};

function Fb(s) {
    if (typeof s == "string") return [new G(s)];
    ze(s) || (s = [s]);
    const e = [];
    for (const t of s) typeof t == "string" ? e.push(new G(t)) : t instanceof et ? e.push(new G(t.data, t.getAttributes())) : e.push(t);
    return e
}

function Lb(s) {
    const e = [];
    for (const t of s) e.push(t._clone(!0));
    return e
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class Bh {
    _dispatchers;

    constructor(e) {
        this._dispatchers = e
    }

    add(e) {
        for (const t of this._dispatchers) e(t);
        return this
    }
}

class Db extends Bh {
    elementToElement(e) {
        return this.add(i_(e))
    }

    elementToStructure(e) {
        return this.add(n_(e))
    }

    attributeToElement(e) {
        return this.add(s_(e))
    }

    attributeToAttribute(e) {
        return this.add(o_(e))
    }

    markerToElement(e) {
        return this.add(r_(e))
    }

    markerToHighlight(e) {
        return this.add(l_(e))
    }

    markerToData(e) {
        return this.add(a_(e))
    }
}

function Fh() {
    return (s, e, t) => {
        if (!t.consumable.consume(e.item, s.name)) return;
        const i = t.writer, n = t.mapper.toViewPosition(e.range.start), o = i.createText(e.item.data);
        i.insert(n, o)
    }
}

function Lh() {
    return (s, e, t) => {
        t.convertAttributes(e.item), !e.reconversion && e.item.is("element") && !e.item.isEmpty && t.convertChildren(e.item)
    }
}

function Nb() {
    return (s, e, t) => {
        const i = t.mapper.toViewPosition(e.position), n = e.position.getShiftedBy(e.length),
            o = t.mapper.toViewPosition(n, {isPhantom: !0}), r = t.writer.createRange(i, o),
            a = t.writer.remove(r.getTrimmed());
        for (const l of t.writer.createRangeIn(a).getItems()) t.mapper.unbindViewElement(l, {defer: !0})
    }
}

function Dh(s, e) {
    const t = s.createAttributeElement("span", e.attributes);
    return e.classes && t._addClass(e.classes), typeof e.priority == "number" && (t._priority = e.priority), t._id = e.id, t
}

function zb() {
    return (s, e, t) => {
        const i = e.selection;
        if (i.isCollapsed || !t.consumable.consume(i, "selection")) return;
        const n = [];
        for (const o of i.getRanges()) n.push(t.mapper.toViewRange(o));
        t.writer.setSelection(n, {backward: i.isBackward})
    }
}

function Hb() {
    return (s, e, t) => {
        const i = e.selection;
        if (!i.isCollapsed || !t.consumable.consume(i, "selection")) return;
        const n = t.writer, o = i.getFirstPosition(), r = t.mapper.toViewPosition(o), a = n.breakAttributes(r);
        n.setSelection(a)
    }
}

function Ub() {
    return (s, e, t) => {
        const i = t.writer, n = i.document.selection;
        for (const o of n.getRanges()) o.isCollapsed && o.end.parent.isAttached() && t.writer.mergeAttributes(o.start);
        i.setSelection(null)
    }
}

function $b(s) {
    return (e, t, i) => {
        if (!i.consumable.test(t.item, e.name)) return;
        const n = s(t.attributeOldValue, i, t), o = s(t.attributeNewValue, i, t);
        if (!n && !o) return;
        i.consumable.consume(t.item, e.name);
        const r = i.writer, a = r.document.selection;
        if (t.item instanceof Fe || t.item instanceof st) r.wrap(a.getFirstRange(), o); else {
            let l = i.mapper.toViewRange(t.range);
            t.attributeOldValue !== null && n && (l = r.unwrap(l, n)), t.attributeNewValue !== null && o && r.wrap(l, o)
        }
    }
}

function Wb(s, e = g_) {
    return (t, i, n) => {
        if (!e(i.item, n.consumable, {preflight: !0})) return;
        const o = s(i.item, n, i);
        if (!o) return;
        e(i.item, n.consumable);
        const r = n.mapper.toViewPosition(i.range.start);
        n.mapper.bindElements(i.item, o), n.writer.insert(r, o), n.convertAttributes(i.item), $h(o, i.item.getChildren(), n, {reconversion: i.reconversion})
    }
}

function qb(s, e) {
    return (t, i, n) => {
        if (!e(i.item, n.consumable, {preflight: !0})) return;
        const o = new Map;
        n.writer._registerSlotFactory(d_(i.item, o, n));
        const r = s(i.item, n, i);
        if (n.writer._clearSlotFactory(), !r) return;
        h_(i.item, o, n), e(i.item, n.consumable);
        const a = n.mapper.toViewPosition(i.range.start);
        n.mapper.bindElements(i.item, r), n.writer.insert(a, r), n.convertAttributes(i.item), f_(r, o, n, {reconversion: i.reconversion})
    }
}

function jb(s) {
    return (e, t, i) => {
        t.isOpening = !0;
        const n = s(t, i);
        t.isOpening = !1;
        const o = s(t, i);
        if (!n || !o) return;
        const r = t.markerRange;
        if (r.isCollapsed && !i.consumable.consume(r, e.name)) return;
        for (const c of r) if (!i.consumable.consume(c.item, e.name)) return;
        const a = i.mapper, l = i.writer;
        l.insert(a.toViewPosition(r.start), n), i.mapper.bindElementToMarker(n, t.markerName), r.isCollapsed || (l.insert(a.toViewPosition(r.end), o), i.mapper.bindElementToMarker(o, t.markerName)), e.stop()
    }
}

function Gb() {
    return (s, e, t) => {
        const i = t.mapper.markerNameToElements(e.markerName);
        if (i) {
            for (const n of i) t.mapper.unbindElementFromMarkerName(n, e.markerName), t.writer.clear(t.writer.createRangeOn(n), n);
            t.writer.clearClonedElementsGroup(e.markerName), s.stop()
        }
    }
}

function Kb(s) {
    return (e, t, i) => {
        const n = s(t.markerName, i);
        if (!n) return;
        const o = t.markerRange;
        i.consumable.consume(o, e.name) && (Tl(o, !1, i, t, n), Tl(o, !0, i, t, n), e.stop())
    }
}

function Tl(s, e, t, i, n) {
    const o = e ? s.start : s.end, r = o.nodeAfter && o.nodeAfter.is("element") ? o.nodeAfter : null,
        a = o.nodeBefore && o.nodeBefore.is("element") ? o.nodeBefore : null;
    if (r || a) {
        let c, u;
        e && r || !e && !a ? (c = r, u = !0) : (c = a, u = !1);
        const d = t.mapper.toViewElement(c);
        if (d) {
            Zb(d, e, u, t, i, n);
            return
        }
    }
    const l = t.mapper.toViewPosition(o);
    Jb(l, e, t, i, n)
}

function Zb(s, e, t, i, n, o) {
    const r = `data-${o.group}-${e ? "start" : "end"}-${t ? "before" : "after"}`,
        a = s.hasAttribute(r) ? s.getAttribute(r).split(",") : [];
    a.unshift(o.name), i.writer.setAttribute(r, a.join(","), s), i.mapper.bindElementToMarker(s, n.markerName)
}

function Jb(s, e, t, i, n) {
    const o = `${n.group}-${e ? "start" : "end"}`, r = n.name ? {name: n.name} : null,
        a = t.writer.createUIElement(o, r);
    t.writer.insert(s, a), t.mapper.bindElementToMarker(a, i.markerName)
}

function Qb(s) {
    return (e, t, i) => {
        const n = s(t.markerName, i);
        if (!n) return;
        const o = i.mapper.markerNameToElements(t.markerName);
        if (!o) return;
        for (const a of o) i.mapper.unbindElementFromMarkerName(a, t.markerName), a.is("containerElement") ? (r(`data-${n.group}-start-before`, a), r(`data-${n.group}-start-after`, a), r(`data-${n.group}-end-before`, a), r(`data-${n.group}-end-after`, a)) : i.writer.clear(i.writer.createRangeOn(a), a);
        i.writer.clearClonedElementsGroup(t.markerName), e.stop();

        function r(a, l) {
            if (l.hasAttribute(a)) {
                const c = new Set(l.getAttribute(a).split(","));
                c.delete(n.name), c.size == 0 ? i.writer.removeAttribute(a, l) : i.writer.setAttribute(a, Array.from(c).join(","), l)
            }
        }
    }
}

function Yb(s) {
    return (e, t, i) => {
        if (!i.consumable.test(t.item, e.name)) return;
        const n = s(t.attributeOldValue, i, t), o = s(t.attributeNewValue, i, t);
        if (!n && !o) return;
        i.consumable.consume(t.item, e.name);
        const r = i.mapper.toViewElement(t.item), a = i.writer;
        if (!r) throw new p("conversion-attribute-to-attribute-on-text", i.dispatcher, t);
        if (t.attributeOldValue !== null && n) {
            let l = n.value;
            n.key == "style" && (typeof n.value == "string" ? l = new Fi(a.document.stylesProcessor).setTo(n.value).getStylesEntries().map(([c]) => c) : l = Object.keys(n.value)), a.removeAttribute(n.key, l, r)
        }
        if (t.attributeNewValue !== null && o) {
            let l = o.value;
            o.key == "style" && typeof o.value == "string" && (l = Object.fromEntries(new Fi(a.document.stylesProcessor).setTo(o.value).getStylesEntries())), a.setAttribute(o.key, l, !1, r)
        }
    }
}

function Xb(s) {
    return (e, t, i) => {
        if (!t.item || !(t.item instanceof Fe || t.item instanceof st) && !t.item.is("$textProxy")) return;
        const n = la(s, t, i);
        if (!n || !i.consumable.consume(t.item, e.name)) return;
        const o = i.writer, r = Dh(o, n), a = o.document.selection;
        if (t.item instanceof Fe || t.item instanceof st) o.wrap(a.getFirstRange(), r); else {
            const l = i.mapper.toViewRange(t.range), c = o.wrap(l, r);
            for (const u of c.getItems()) if (u.is("attributeElement") && u.isSimilar(r)) {
                i.mapper.bindElementToMarker(u, t.markerName);
                break
            }
        }
    }
}

function e_(s) {
    return (e, t, i) => {
        if (!t.item || !(t.item instanceof j)) return;
        const n = la(s, t, i);
        if (!n || !i.consumable.test(t.item, e.name)) return;
        const o = i.mapper.toViewElement(t.item);
        if (o && o.getCustomProperty("addHighlight")) {
            i.consumable.consume(t.item, e.name);
            for (const a of b._createIn(t.item)) i.consumable.consume(a.item, e.name);
            o.getCustomProperty("addHighlight")(o, n, i.writer), i.mapper.bindElementToMarker(o, t.markerName)
        }
    }
}

function t_(s) {
    return (e, t, i) => {
        if (t.markerRange.isCollapsed) return;
        const n = la(s, t, i);
        if (!n) return;
        const o = Dh(i.writer, n), r = i.mapper.markerNameToElements(t.markerName);
        if (r) {
            for (const a of r) i.mapper.unbindElementFromMarkerName(a, t.markerName), a.is("attributeElement") ? i.writer.unwrap(i.writer.createRangeOn(a), o) : a.getCustomProperty("removeHighlight")(a, n.id, i.writer);
            i.writer.clearClonedElementsGroup(t.markerName), e.stop()
        }
    }
}

function i_(s) {
    const e = Nh(s.model), t = Sn(s.view, "container");
    return e.attributes.length && (e.children = !0), i => {
        i.on(`insert:${e.name}`, Wb(t, Uh(e)), {priority: s.converterPriority || "normal"}), (e.children || e.attributes.length) && i.on("reduceChanges", Hh(e), {priority: "low"})
    }
}

function n_(s) {
    const e = Nh(s.model), t = Sn(s.view, "container");
    return e.children = !0, i => {
        if (i._conversionApi.schema.checkChild(e.name, "$text")) throw new p("conversion-element-to-structure-disallowed-text", i, {elementName: e.name});
        i.on(`insert:${e.name}`, qb(t, Uh(e)), {priority: s.converterPriority || "normal"}), i.on("reduceChanges", Hh(e), {priority: "low"})
    }
}

function s_(s) {
    s = Ve(s);
    let e = s.model;
    typeof e == "string" && (e = {key: e});
    let t = `attribute:${e.key}`;
    if (e.name && (t += ":" + e.name), e.values) for (const n of e.values) s.view[n] = Sn(s.view[n], "attribute"); else s.view = Sn(s.view, "attribute");
    const i = zh(s);
    return n => {
        n.on(t, $b(i), {priority: s.converterPriority || "normal"})
    }
}

function o_(s) {
    s = Ve(s);
    let e = s.model;
    typeof e == "string" && (e = {key: e});
    let t = `attribute:${e.key}`;
    if (e.name && (t += ":" + e.name), e.values) for (const n of e.values) s.view[n] = Al(s.view[n]); else s.view = Al(s.view);
    const i = zh(s);
    return n => {
        n.on(t, Yb(i), {priority: s.converterPriority || "normal"})
    }
}

function r_(s) {
    const e = Sn(s.view, "ui");
    return t => {
        t.on(`addMarker:${s.model}`, jb(e), {priority: s.converterPriority || "normal"}), t.on(`removeMarker:${s.model}`, Gb(), {priority: s.converterPriority || "normal"})
    }
}

function a_(s) {
    s = Ve(s);
    const e = s.model;
    let t = s.view;
    return t || (t = i => ({group: e, name: i.substr(s.model.length + 1)})), i => {
        i.on(`addMarker:${e}`, Kb(t), {priority: s.converterPriority || "normal"}), i.on(`removeMarker:${e}`, Qb(t), {priority: s.converterPriority || "normal"})
    }
}

function l_(s) {
    return e => {
        e.on(`addMarker:${s.model}`, Xb(s.view), {priority: s.converterPriority || "normal"}), e.on(`addMarker:${s.model}`, e_(s.view), {priority: s.converterPriority || "normal"}), e.on(`removeMarker:${s.model}`, t_(s.view), {priority: s.converterPriority || "normal"})
    }
}

function Nh(s) {
    return typeof s == "string" && (s = {name: s}), {
        name: s.name,
        attributes: s.attributes ? U(s.attributes) : [],
        children: !!s.children
    }
}

function Sn(s, e) {
    return typeof s == "function" ? s : (t, i) => c_(s, i, e)
}

function c_(s, e, t) {
    typeof s == "string" && (s = {name: s});
    let i;
    const n = e.writer, o = Object.assign({}, s.attributes);
    if (t == "container") i = n.createContainerElement(s.name, o); else if (t == "attribute") {
        const r = {priority: s.priority || Li.DEFAULT_PRIORITY};
        i = n.createAttributeElement(s.name, o, r)
    } else i = n.createUIElement(s.name, o);
    if (s.styles) {
        const r = Object.keys(s.styles);
        for (const a of r) n.setStyle(a, s.styles[a], i)
    }
    if (s.classes) {
        const r = s.classes;
        if (typeof r == "string") n.addClass(r, i); else for (const a of r) n.addClass(a, i)
    }
    return i
}

function zh(s) {
    return s.model.values ? (e, t, i) => {
        const n = s.view[e];
        return n ? n(e, t, i) : null
    } : s.view
}

function Al(s) {
    return typeof s == "string" ? e => ({
        key: s,
        value: e
    }) : typeof s == "object" ? s.value ? () => s : e => ({key: s.key, value: e}) : s
}

function la(s, e, t) {
    const i = typeof s == "function" ? s(e, t) : s;
    return i ? (i.priority || (i.priority = 10), i.id || (i.id = e.markerName), i) : null
}

function u_(s) {
    return (e, t) => {
        if (!e.is("element", s.name)) return !1;
        if (t.type == "attribute") {
            if (s.attributes.includes(t.attributeKey)) return !0
        } else {/* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. -- @preserve */
            if (s.children) return !0
        }
        return !1
    }
}

function Hh(s) {
    const e = u_(s);
    return (t, i) => {
        const n = [];
        i.reconvertedElements || (i.reconvertedElements = new Set);
        for (const o of i.changes) {
            const r = o.type == "attribute" ? o.range.start.nodeAfter : o.position.parent;
            if (!r || !e(r, o)) {
                n.push(o);
                continue
            }
            if (!i.reconvertedElements.has(r)) {
                i.reconvertedElements.add(r);
                const a = y._createBefore(r);
                let l = n.length;
                for (let c = n.length - 1; c >= 0; c--) {
                    const u = n[c], h = (u.type == "attribute" ? u.range.start : u.position).compareWith(a);
                    if (h == "before" || u.type == "remove" && h == "same") break;
                    l = c
                }
                n.splice(l, 0, {type: "remove", name: r.name, position: a, length: 1}, {
                    type: "reinsert",
                    name: r.name,
                    position: a,
                    length: 1
                })
            }
        }
        i.changes = n
    }
}

function Uh(s) {
    return (e, t, i = {}) => {
        const n = ["insert"];
        for (const o of s.attributes) e.hasAttribute(o) && n.push(`attribute:${o}`);
        return n.every(o => t.test(e, o)) ? (i.preflight || n.forEach(o => t.consume(e, o)), !0) : !1
    }
}

function d_(s, e, t) {
    return (i, n) => {
        const o = i.createContainerElement("$slot");
        let r = null;
        if (n === "children") r = Array.from(s.getChildren()); else if (typeof n == "function") r = Array.from(s.getChildren()).filter(a => n(a)); else throw new p("conversion-slot-mode-unknown", t.dispatcher, {modeOrFilter: n});
        return e.set(o, r), o
    }
}

function h_(s, e, t) {
    const i = Array.from(e.values()).flat(), n = new Set(i);
    if (n.size != i.length) throw new p("conversion-slot-filter-overlap", t.dispatcher, {element: s});
    if (n.size != s.childCount) throw new p("conversion-slot-filter-incomplete", t.dispatcher, {element: s})
}

function f_(s, e, t, i) {
    t.mapper.on("modelToViewPosition", r, {priority: "highest"});
    let n = null, o = null;
    for ([n, o] of e) $h(s, o, t, i), t.writer.move(t.writer.createRangeIn(n), t.writer.createPositionBefore(n)), t.writer.remove(n);
    t.mapper.off("modelToViewPosition", r);

    function r(a, l) {
        const c = l.modelPosition.nodeAfter, u = o.indexOf(c);
        u < 0 || (l.viewPosition = l.mapper.findPositionIn(n, u))
    }
}

function $h(s, e, t, i) {
    for (const n of e) m_(s.root, n, t, i) || t.convertItem(n)
}

function m_(s, e, t, i) {
    const {writer: n, mapper: o} = t;
    if (!i.reconversion) return !1;
    const r = o.toViewElement(e);
    return !r || r.root == s || !t.canReuseView(r) ? !1 : (n.move(n.createRangeOn(r), o.toViewPosition(y._createBefore(e))), !0)
}

function g_(s, e, {preflight: t} = {}) {
    return t ? e.test(s, "insert") : e.consume(s, "insert")
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Wh(s) {
    const {schema: e, document: t} = s.model;
    for (const i of t.getRoots()) if (i.isEmpty && !e.checkChild(i, "$text") && e.checkChild(i, "paragraph")) return s.insertElement("paragraph", i), !0;
    return !1
}

function qh(s, e, t) {
    const i = t.createContext(s);
    return !(!t.checkChild(i, "paragraph") || !t.checkChild(i.push("paragraph"), e))
}

function jh(s, e) {
    const t = e.createElement("paragraph");
    return e.insert(t, s), e.createPositionAt(t, 0)
}

class p_ extends Bh {
    elementToElement(e) {
        return this.add(Gh(e))
    }

    elementToAttribute(e) {
        return this.add(__(e))
    }

    attributeToAttribute(e) {
        return this.add(v_(e))
    }

    elementToMarker(e) {
        return this.add(y_(e))
    }

    dataToMarker(e) {
        return this.add(k_(e))
    }
}

function xl() {
    return (s, e, t) => {
        if (!e.modelRange && t.consumable.consume(e.viewItem, {name: !0})) {
            const {modelRange: i, modelCursor: n} = t.convertChildren(e.viewItem, e.modelCursor);
            e.modelRange = i, e.modelCursor = n
        }
    }
}

function w_() {
    return (s, e, {schema: t, consumable: i, writer: n}) => {
        let o = e.modelCursor;
        if (!i.test(e.viewItem)) return;
        if (!t.checkChild(o, "$text")) {
            if (!qh(o, "$text", t) || e.viewItem.data.trim().length == 0) return;
            o = jh(o, n)
        }
        i.consume(e.viewItem);
        const r = n.createText(e.viewItem.data);
        n.insert(r, o), e.modelRange = n.createRange(o, o.getShiftedBy(r.offsetSize)), e.modelCursor = e.modelRange.end
    }
}

function b_(s, e) {
    return (t, i) => {
        const n = i.newSelection, o = [];
        for (const a of n.getRanges()) o.push(e.toModelRange(a));
        const r = s.createSelection(o, {backward: n.isBackward});
        r.isEqual(s.document.selection) || s.change(a => {
            a.setSelection(r)
        })
    }
}

function Gh(s) {
    s = Ve(s);
    const e = pr(s), t = ca(s.view), i = t ? `element:${t}` : "element";
    return n => {
        n.on(i, e, {priority: s.converterPriority || "normal"})
    }
}

function __(s) {
    s = Ve(s), Kh(s);
    const e = Zh(s, !1), t = ca(s.view), i = t ? `element:${t}` : "element";
    return n => {
        n.on(i, e, {priority: s.converterPriority || "low"})
    }
}

function v_(s) {
    s = Ve(s);
    let e = null;
    (typeof s.view == "string" || s.view.key) && (e = T_(s)), Kh(s, e);
    const t = Zh(s, !0);
    return i => {
        i.on("element", t, {priority: s.converterPriority || "low"})
    }
}

function y_(s) {
    const e = I_(s.model);
    return Gh({...s, model: e})
}

function k_(s) {
    s = Ve(s), s.model || (s.model = n => n ? s.view + ":" + n : s.view);
    const e = {view: s.view, model: s.model}, t = pr(Il(e, "start")), i = pr(Il(e, "end"));
    return n => {
        n.on(`element:${s.view}-start`, t, {priority: s.converterPriority || "normal"}), n.on(`element:${s.view}-end`, i, {priority: s.converterPriority || "normal"});
        const o = Le.low, r = Le.highest, a = Le.get(s.converterPriority) / r;
        n.on("element", C_(e), {priority: o + a})
    }
}

function C_(s) {
    return (e, t, i) => {
        const n = `data-${s.view}`;
        if (!i.consumable.test(t.viewItem, {attributes: n + "-end-after"}) && !i.consumable.test(t.viewItem, {attributes: n + "-start-after"}) && !i.consumable.test(t.viewItem, {attributes: n + "-end-before"}) && !i.consumable.test(t.viewItem, {attributes: n + "-start-before"})) return;
        t.modelRange || Object.assign(t, i.convertChildren(t.viewItem, t.modelCursor)), i.consumable.consume(t.viewItem, {attributes: n + "-end-after"}) && o(t.modelRange.end, t.viewItem.getAttribute(n + "-end-after").split(",")), i.consumable.consume(t.viewItem, {attributes: n + "-start-after"}) && o(t.modelRange.end, t.viewItem.getAttribute(n + "-start-after").split(",")), i.consumable.consume(t.viewItem, {attributes: n + "-end-before"}) && o(t.modelRange.start, t.viewItem.getAttribute(n + "-end-before").split(",")), i.consumable.consume(t.viewItem, {attributes: n + "-start-before"}) && o(t.modelRange.start, t.viewItem.getAttribute(n + "-start-before").split(","));

        function o(r, a) {
            for (const l of a) {
                const c = s.model(l, i), u = i.writer.createElement("$marker", {"data-name": c});
                i.writer.insert(u, r), t.modelCursor.isEqual(r) ? t.modelCursor = t.modelCursor.getShiftedBy(1) : t.modelCursor = t.modelCursor._getTransformedByInsertion(r, 1), t.modelRange = t.modelRange._getTransformedByInsertion(r, 1)[0]
            }
        }
    }
}

function ca(s) {
    return typeof s == "string" ? s : typeof s == "object" && typeof s.name == "string" ? s.name : null
}

function pr(s) {
    const e = new He(s.view);
    return (t, i, n) => {
        const o = e.match(i.viewItem);
        if (!o) return;
        const r = o.match;
        if (r.name = !0, !n.consumable.test(i.viewItem, r)) return;
        const a = E_(s.model, i.viewItem, n);
        a && n.safeInsert(a, i.modelCursor) && (n.consumable.consume(i.viewItem, r), n.convertChildren(i.viewItem, a), n.updateConversionResult(a, i))
    }
}

function E_(s, e, t) {
    return s instanceof Function ? s(e, t) : t.writer.createElement(s)
}

function T_(s) {
    typeof s.view == "string" && (s.view = {key: s.view});
    const e = s.view.key, t = typeof s.view.value > "u" ? /[\s\S]*/ : s.view.value;
    let i;
    return e == "class" || e == "style" ? i = {[e == "class" ? "classes" : "styles"]: t} : i = {attributes: {[e]: t}}, s.view.name && (i.name = s.view.name), s.view = i, e
}

function Kh(s, e = null) {
    const t = e === null ? !0 : o => o.getAttribute(e), i = typeof s.model != "object" ? s.model : s.model.key,
        n = typeof s.model != "object" || typeof s.model.value > "u" ? t : s.model.value;
    s.model = {key: i, value: n}
}

function Zh(s, e) {
    const t = new He(s.view);
    return (i, n, o) => {
        if (!n.modelRange && e) return;
        const r = t.match(n.viewItem);
        if (!r || (A_(s.view, n.viewItem) ? r.match.name = !0 : delete r.match.name, !o.consumable.test(n.viewItem, r.match))) return;
        const a = s.model.key, l = typeof s.model.value == "function" ? s.model.value(n.viewItem, o, n) : s.model.value;
        if (l === null) return;
        n.modelRange || Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor)), x_(n.modelRange, {
            key: a,
            value: l
        }, e, o) && (o.consumable.test(n.viewItem, {name: !0}) && (r.match.name = !0), o.consumable.consume(n.viewItem, r.match))
    }
}

function A_(s, e) {
    const t = typeof s == "function" ? s(e) : s;
    return typeof t == "object" && !ca(t) ? !1 : !t.classes && !t.attributes && !t.styles
}

function x_(s, e, t, i) {
    let n = !1;
    for (const o of Array.from(s.getItems({shallow: t}))) i.schema.checkAttribute(o, e.key) && (n = !0, !o.hasAttribute(e.key) && i.writer.setAttribute(e.key, e.value, o));
    return n
}

function I_(s) {
    return (e, t) => {
        const i = typeof s == "string" ? s : s(e, t);
        return t.writer.createElement("$marker", {"data-name": i})
    }
}

function Il(s, e) {
    const t = (i, n) => {
        const o = i.getAttribute("name"), r = s.model(o, n);
        return n.writer.createElement("$marker", {"data-name": r})
    };
    return {view: `${s.view}-${e}`, model: t}
}

class S_ extends H() {
    model;
    view;
    mapper;
    downcastDispatcher;

    constructor(e, t) {
        super(), this.model = e, this.view = new vb(t), this.mapper = new Vh, this.downcastDispatcher = new Oh({
            mapper: this.mapper,
            schema: e.schema
        });
        const i = this.model.document, n = i.selection, o = this.model.markers;
        this.listenTo(this.model, "_beforeChanges", () => {
            this.view._disableRendering(!0)
        }, {priority: "highest"}), this.listenTo(this.model, "_afterChanges", () => {
            this.view._disableRendering(!1)
        }, {priority: "lowest"}), this.listenTo(i, "change", () => {
            this.view.change(r => {
                this.downcastDispatcher.convertChanges(i.differ, o, r), this.downcastDispatcher.convertSelection(n, o, r)
            })
        }, {priority: "low"}), this.listenTo(this.view.document, "selectionChange", b_(this.model, this.mapper)), this.downcastDispatcher.on("insert:$text", Fh(), {priority: "lowest"}), this.downcastDispatcher.on("insert", Lh(), {priority: "lowest"}), this.downcastDispatcher.on("remove", Nb(), {priority: "low"}), this.downcastDispatcher.on("cleanSelection", Ub()), this.downcastDispatcher.on("selection", zb(), {priority: "low"}), this.downcastDispatcher.on("selection", Hb(), {priority: "low"}), this.view.document.roots.bindTo(this.model.document.roots).using(r => {
            if (r.rootName == "$graveyard") return null;
            const a = new _h(this.view.document, r.name);
            return a.rootName = r.rootName, this.mapper.bindElements(r, a), a
        })
    }

    destroy() {
        this.view.destroy(), this.stopListening()
    }

    reconvertMarker(e) {
        const t = typeof e == "string" ? e : e.name, i = this.model.markers.get(t);
        if (!i) throw new p("editingcontroller-reconvertmarker-marker-not-exist", this, {markerName: t});
        this.model.change(() => {
            this.model.markers._refresh(i)
        })
    }

    reconvertItem(e) {
        this.model.change(() => {
            this.model.document.differ._refreshItem(e)
        })
    }
}

class P_ extends H() {
    _sourceDefinitions = {};
    _attributeProperties = Object.create(null);
    _customChildChecks = new Map;
    _customAttributeChecks = new Map;
    _genericCheckSymbol = Symbol("$generic");
    _compiledDefinitions;

    constructor() {
        super(), this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (e, t) => {
            t[0] = new Lt(t[0])
        }, {priority: "highest"}), this.on("checkChild", (e, t) => {
            t[0] = new Lt(t[0]), t[1] = this.getDefinition(t[1])
        }, {priority: "highest"})
    }

    register(e, t) {
        if (this._sourceDefinitions[e]) throw new p("schema-cannot-register-item-twice", this, {itemName: e});
        this._sourceDefinitions[e] = [Object.assign({}, t)], this._clearCache()
    }

    extend(e, t) {
        if (!this._sourceDefinitions[e]) throw new p("schema-cannot-extend-missing-item", this, {itemName: e});
        this._sourceDefinitions[e].push(Object.assign({}, t)), this._clearCache()
    }

    getDefinitions() {
        return this._compiledDefinitions || this._compile(), this._compiledDefinitions
    }

    getDefinition(e) {
        let t;
        return typeof e == "string" ? t = e : "is" in e && (e.is("$text") || e.is("$textProxy")) ? t = "$text" : t = e.name, this.getDefinitions()[t]
    }

    isRegistered(e) {
        return !!this.getDefinition(e)
    }

    isBlock(e) {
        const t = this.getDefinition(e);
        return !!(t && t.isBlock)
    }

    isLimit(e) {
        const t = this.getDefinition(e);
        return t ? !!(t.isLimit || t.isObject) : !1
    }

    isObject(e) {
        const t = this.getDefinition(e);
        return t ? !!(t.isObject || t.isLimit && t.isSelectable && t.isContent) : !1
    }

    isInline(e) {
        const t = this.getDefinition(e);
        return !!(t && t.isInline)
    }

    isSelectable(e) {
        const t = this.getDefinition(e);
        return t ? !!(t.isSelectable || t.isObject) : !1
    }

    isContent(e) {
        const t = this.getDefinition(e);
        return t ? !!(t.isContent || t.isObject) : !1
    }

    checkChild(e, t) {
        return t ? this._checkContextMatch(e, t) : !1
    }

    checkAttribute(e, t) {
        const i = this.getDefinition(e.last);
        if (!i) return !1;
        const n = this._evaluateAttributeChecks(e, t);
        return n !== void 0 ? n : i.allowAttributes.includes(t)
    }

    checkMerge(e, t) {
        if (e instanceof y) {
            const i = e.nodeBefore, n = e.nodeAfter;
            if (!(i instanceof j)) throw new p("schema-check-merge-no-element-before", this);
            if (!(n instanceof j)) throw new p("schema-check-merge-no-element-after", this);
            return this.checkMerge(i, n)
        }
        if (this.isLimit(e) || this.isLimit(t)) return !1;
        for (const i of t.getChildren()) if (!this.checkChild(e, i)) return !1;
        return !0
    }

    addChildCheck(e, t) {
        const i = t !== void 0 ? t : this._genericCheckSymbol, n = this._customChildChecks.get(i) || [];
        n.push(e), this._customChildChecks.set(i, n)
    }

    addAttributeCheck(e, t) {
        const i = t !== void 0 ? t : this._genericCheckSymbol, n = this._customAttributeChecks.get(i) || [];
        n.push(e), this._customAttributeChecks.set(i, n)
    }

    setAttributeProperties(e, t) {
        this._attributeProperties[e] = Object.assign(this.getAttributeProperties(e), t)
    }

    getAttributeProperties(e) {
        return this._attributeProperties[e] || Object.create(null)
    }

    getLimitElement(e) {
        let t;
        for (e instanceof y ? t = e.parent : t = (e instanceof b ? [e] : Array.from(e.getRanges())).reduce((n, o) => {
            const r = o.getCommonAncestor();
            return n ? n.getCommonAncestor(r, {includeSelf: !0}) : r
        }, null); !this.isLimit(t) && t.parent;) t = t.parent;
        return t
    }

    checkAttributeInSelection(e, t) {
        if (e.isCollapsed) {
            const n = [...e.getFirstPosition().getAncestors(), new G("", e.getAttributes())];
            return this.checkAttribute(n, t)
        } else {
            const i = e.getRanges();
            for (const n of i) for (const o of n) if (this.checkAttribute(o.item, t)) return !0
        }
        return !1
    }

    * getValidRanges(e, t) {
        e = j_(e);
        for (const i of e) yield* this._getValidRangesForRange(i, t)
    }

    getNearestSelectionRange(e, t = "both") {
        if (e.root.rootName == "$graveyard") return null;
        if (this.checkChild(e, "$text")) return new b(e);
        let i, n;
        const o = e.getAncestors().reverse().find(r => this.isLimit(r)) || e.root;
        (t == "both" || t == "backward") && (i = new Ct({
            boundaries: b._createIn(o),
            startPosition: e,
            direction: "backward"
        })), (t == "both" || t == "forward") && (n = new Ct({boundaries: b._createIn(o), startPosition: e}));
        for (const r of q_(i, n)) {
            const a = r.walker == i ? "elementEnd" : "elementStart", l = r.value;
            if (l.type == a && this.isObject(l.item)) return b._createOn(l.item);
            if (this.checkChild(l.nextPosition, "$text")) return new b(l.nextPosition)
        }
        return null
    }

    findAllowedParent(e, t) {
        let i = e.parent;
        for (; i;) {
            if (this.checkChild(i, t)) return i;
            if (this.isLimit(i)) return null;
            i = i.parent
        }
        return null
    }

    setAllowedAttributes(e, t, i) {
        const n = i.model;
        for (const [o, r] of Object.entries(t)) n.schema.checkAttribute(e, o) && i.setAttribute(o, r, e)
    }

    removeDisallowedAttributes(e, t) {
        for (const i of e) if (i.is("$text")) Sl(this, i, t); else {
            const o = b._createIn(i).getPositions();
            for (const r of o) {
                const a = r.nodeBefore || r.parent;
                Sl(this, a, t)
            }
        }
    }

    getAttributesWithProperty(e, t, i) {
        const n = {};
        for (const [o, r] of e.getAttributes()) {
            const a = this.getAttributeProperties(o);
            a[t] !== void 0 && (i === void 0 || i === a[t]) && (n[o] = r)
        }
        return n
    }

    createContext(e) {
        return new Lt(e)
    }

    _clearCache() {
        this._compiledDefinitions = null
    }

    _compile() {
        const e = {}, t = this._sourceDefinitions, i = Object.keys(t);
        for (const o of i) e[o] = R_(t[o], o);
        const n = Object.values(e);
        for (const o of n) V_(e, o), O_(e, o), M_(e, o), B_(e, o);
        for (const o of n) F_(e, o);
        for (const o of n) L_(e, o);
        for (const o of n) D_(e, o);
        for (const o of n) z_(e, o);
        for (const o of n) H_(e, o);
        this._compiledDefinitions = N_(e)
    }

    _checkContextMatch(e, t) {
        const i = e.last;
        let n = this._evaluateChildChecks(e, t);
        if (n = n !== void 0 ? n : t.allowIn.includes(i.name), !n) return !1;
        const o = this.getDefinition(i), r = e.trimLast();
        return o ? r.length == 0 ? !0 : this._checkContextMatch(r, o) : !1
    }

    _evaluateChildChecks(e, t) {
        const i = this._customChildChecks.get(this._genericCheckSymbol) || [],
            n = this._customChildChecks.get(t.name) || [];
        for (const o of [...i, ...n]) {
            const r = o(e, t);
            if (r !== void 0) return r
        }
    }

    _evaluateAttributeChecks(e, t) {
        const i = this._customAttributeChecks.get(this._genericCheckSymbol) || [],
            n = this._customAttributeChecks.get(t) || [];
        for (const o of [...i, ...n]) {
            const r = o(e, t);
            if (r !== void 0) return r
        }
    }

    * _getValidRangesForRange(e, t) {
        let i = e.start, n = e.start;
        for (const o of e.getItems({shallow: !0})) o.is("element") && (yield* this._getValidRangesForRange(b._createIn(o), t)), this.checkAttribute(o, t) || (i.isEqual(n) || (yield new b(i, n)), i = y._createAfter(o)), n = y._createAfter(o);
        i.isEqual(n) || (yield new b(i, n))
    }

    findOptimalInsertionRange(e, t) {
        const i = e.getSelectedElement();
        if (i && this.isObject(i) && !this.isInline(i)) return t == "before" || t == "after" ? new b(y._createAt(i, t)) : b._createOn(i);
        const n = re(e.getSelectedBlocks());
        if (!n) return new b(e.focus);
        if (n.isEmpty) return new b(y._createAt(n, 0));
        const o = y._createAfter(n);
        return e.focus.isTouching(o) ? new b(o) : new b(y._createBefore(n))
    }
}

class Lt {
    _items;

    constructor(e) {
        if (e instanceof Lt) return e;
        let t;
        typeof e == "string" ? t = [e] : Array.isArray(e) ? t = e : t = e.getAncestors({includeSelf: !0}), this._items = t.map(W_)
    }

    get length() {
        return this._items.length
    }

    get last() {
        return this._items[this._items.length - 1]
    }

    [Symbol.iterator]() {
        return this._items[Symbol.iterator]()
    }

    push(e) {
        const t = new Lt([e]);
        return t._items = [...this._items, ...t._items], t
    }

    trimLast() {
        const e = new Lt([]);
        return e._items = this._items.slice(0, -1), e
    }

    getItem(e) {
        return this._items[e]
    }

    * getNames() {
        yield* this._items.map(e => e.name)
    }

    endsWith(e) {
        return Array.from(this.getNames()).join(" ").endsWith(e)
    }

    startsWith(e) {
        return Array.from(this.getNames()).join(" ").startsWith(e)
    }
}

function R_(s, e) {
    const t = {
        name: e,
        allowIn: new Set,
        allowChildren: new Set,
        disallowIn: new Set,
        disallowChildren: new Set,
        allowContentOf: new Set,
        allowWhere: new Set,
        allowAttributes: new Set,
        disallowAttributes: new Set,
        allowAttributesOf: new Set,
        inheritTypesFrom: new Set
    };
    return U_(s, t), rt(s, t, "allowIn"), rt(s, t, "allowChildren"), rt(s, t, "disallowIn"), rt(s, t, "disallowChildren"), rt(s, t, "allowContentOf"), rt(s, t, "allowWhere"), rt(s, t, "allowAttributes"), rt(s, t, "disallowAttributes"), rt(s, t, "allowAttributesOf"), rt(s, t, "inheritTypesFrom"), $_(s, t), t
}

function V_(s, e) {
    for (const t of e.allowIn) {
        const i = s[t];
        i ? i.allowChildren.add(e.name) : e.allowIn.delete(t)
    }
}

function O_(s, e) {
    for (const t of e.allowChildren) {
        const i = s[t];
        i ? i.allowIn.add(e.name) : e.allowChildren.delete(t)
    }
}

function M_(s, e) {
    for (const t of e.disallowIn) {
        const i = s[t];
        i ? i.disallowChildren.add(e.name) : e.disallowIn.delete(t)
    }
}

function B_(s, e) {
    for (const t of e.disallowChildren) {
        const i = s[t];
        i ? i.disallowIn.add(e.name) : e.disallowChildren.delete(t)
    }
}

function F_(s, e) {
    for (const t of e.disallowChildren) e.allowChildren.delete(t);
    for (const t of e.disallowIn) e.allowIn.delete(t);
    for (const t of e.disallowAttributes) e.allowAttributes.delete(t)
}

function L_(s, e) {
    for (const t of e.allowContentOf) {
        const i = s[t];
        i && (i.disallowChildren.forEach(n => {
            e.allowChildren.has(n) || (e.disallowChildren.add(n), s[n].disallowIn.add(e.name))
        }), i.allowChildren.forEach(n => {
            e.disallowChildren.has(n) || (e.allowChildren.add(n), s[n].allowIn.add(e.name))
        }))
    }
}

function D_(s, e) {
    for (const t of e.allowWhere) {
        const i = s[t];
        i && (i.disallowIn.forEach(n => {
            e.allowIn.has(n) || (e.disallowIn.add(n), s[n].disallowChildren.add(e.name))
        }), i.allowIn.forEach(n => {
            e.disallowIn.has(n) || (e.allowIn.add(n), s[n].allowChildren.add(e.name))
        }))
    }
}

function N_(s) {
    const e = {};
    for (const t of Object.values(s)) e[t.name] = {
        name: t.name,
        isBlock: !!t.isBlock,
        isContent: !!t.isContent,
        isInline: !!t.isInline,
        isLimit: !!t.isLimit,
        isObject: !!t.isObject,
        isSelectable: !!t.isSelectable,
        allowIn: Array.from(t.allowIn).filter(i => !!s[i]),
        allowChildren: Array.from(t.allowChildren).filter(i => !!s[i]),
        allowAttributes: Array.from(t.allowAttributes)
    };
    return e
}

function z_(s, e) {
    for (const t of e.allowAttributesOf) {
        const i = s[t];
        if (!i) return;
        i.allowAttributes.forEach(n => {
            e.disallowAttributes.has(n) || e.allowAttributes.add(n)
        })
    }
}

function H_(s, e) {
    for (const t of e.inheritTypesFrom) {
        const i = s[t];
        if (i) {
            const n = Object.keys(i).filter(o => o.startsWith("is"));
            for (const o of n) o in e || (e[o] = i[o])
        }
    }
}

function U_(s, e) {
    for (const t of s) {
        const i = Object.keys(t).filter(n => n.startsWith("is"));
        for (const n of i) e[n] = !!t[n]
    }
}

function rt(s, e, t) {
    for (const i of s) {
        let n = i[t];
        typeof n == "string" && (n = [n]), Array.isArray(n) && n.forEach(o => e[t].add(o))
    }
}

function $_(s, e) {
    for (const t of s) {
        const i = t.inheritAllFrom;
        i && (e.allowContentOf.add(i), e.allowWhere.add(i), e.allowAttributesOf.add(i), e.inheritTypesFrom.add(i))
    }
}

function W_(s) {
    return typeof s == "string" || s.is("documentFragment") ? {
        name: typeof s == "string" ? s : "$documentFragment",
        * getAttributeKeys() {
        },
        getAttribute() {
        }
    } : {
        name: s.is("element") ? s.name : "$text", * getAttributeKeys() {
            yield* s.getAttributeKeys()
        }, getAttribute(e) {
            return s.getAttribute(e)
        }
    }
}

function* q_(s, e) {
    let t = !1;
    for (; !t;) {
        if (t = !0, s) {
            const i = s.next();
            i.done || (t = !1, yield{walker: s, value: i.value})
        }
        if (e) {
            const i = e.next();
            i.done || (t = !1, yield{walker: e, value: i.value})
        }
    }
}

function* j_(s) {
    for (const e of s) yield* e.getMinimalFlatRanges()
}

function Sl(s, e, t) {
    for (const i of e.getAttributeKeys()) s.checkAttribute(e, i) || t.removeAttribute(i, e)
}

class G_ extends W() {
    conversionApi;
    _splitParts = new Map;
    _cursorParents = new Map;
    _modelCursor = null;
    _emptyElementsToKeep = new Set;

    constructor(e) {
        super(), this.conversionApi = {
            ...e,
            consumable: null,
            writer: null,
            store: null,
            convertItem: (t, i) => this._convertItem(t, i),
            convertChildren: (t, i) => this._convertChildren(t, i),
            safeInsert: (t, i) => this._safeInsert(t, i),
            updateConversionResult: (t, i) => this._updateConversionResult(t, i),
            splitToAllowedParent: (t, i) => this._splitToAllowedParent(t, i),
            getSplitParts: t => this._getSplitParts(t),
            keepEmptyElement: t => this._keepEmptyElement(t)
        }
    }

    convert(e, t, i = ["$root"]) {
        this.fire("viewCleanup", e), this._modelCursor = Z_(i, t), this.conversionApi.writer = t, this.conversionApi.consumable = Bs.createFrom(e), this.conversionApi.store = {};
        const {modelRange: n} = this._convertItem(e, this._modelCursor), o = t.createDocumentFragment();
        if (n) {
            this._removeEmptyElements();
            const r = this._modelCursor.parent, a = r._removeChildren(0, r.childCount);
            o._insertChild(0, a), o.markers = K_(o, t)
        }
        return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, o
    }

    _convertItem(e, t) {
        const i = {viewItem: e, modelCursor: t, modelRange: null};
        if (e.is("element") ? this.fire(`element:${e.name}`, i, this.conversionApi) : e.is("$text") ? this.fire("text", i, this.conversionApi) : this.fire("documentFragment", i, this.conversionApi), i.modelRange && !(i.modelRange instanceof b)) throw new p("view-conversion-dispatcher-incorrect-result", this);
        return {modelRange: i.modelRange, modelCursor: i.modelCursor}
    }

    _convertChildren(e, t) {
        let i = t.is("position") ? t : y._createAt(t, 0);
        const n = new b(i);
        for (const o of Array.from(e.getChildren())) {
            const r = this._convertItem(o, i);
            r.modelRange instanceof b && (n.end = r.modelRange.end, i = r.modelCursor)
        }
        return {modelRange: n, modelCursor: i}
    }

    _safeInsert(e, t) {
        const i = this._splitToAllowedParent(e, t);
        return i ? (this.conversionApi.writer.insert(e, i.position), !0) : !1
    }

    _updateConversionResult(e, t) {
        const i = this._getSplitParts(e), n = this.conversionApi.writer;
        t.modelRange || (t.modelRange = n.createRange(n.createPositionBefore(e), n.createPositionAfter(i[i.length - 1])));
        const o = this._cursorParents.get(e);
        o ? t.modelCursor = n.createPositionAt(o, 0) : t.modelCursor = t.modelRange.end
    }

    _splitToAllowedParent(e, t) {
        const {schema: i, writer: n} = this.conversionApi;
        let o = i.findAllowedParent(t, e);
        if (o) {
            if (o === t.parent) return {position: t};
            this._modelCursor.parent.getAncestors().includes(o) && (o = null)
        }
        if (!o) return qh(t, e, i) ? {position: jh(t, n)} : null;
        const r = this.conversionApi.writer.split(t, o), a = [];
        for (const c of r.range.getWalker()) if (c.type == "elementEnd") a.push(c.item); else {
            const u = a.pop(), d = c.item;
            this._registerSplitPair(u, d)
        }
        const l = r.range.end.parent;
        return this._cursorParents.set(e, l), {position: r.position, cursorParent: l}
    }

    _registerSplitPair(e, t) {
        this._splitParts.has(e) || this._splitParts.set(e, [e]);
        const i = this._splitParts.get(e);
        this._splitParts.set(t, i), i.push(t)
    }

    _getSplitParts(e) {
        let t;
        return this._splitParts.has(e) ? t = this._splitParts.get(e) : t = [e], t
    }

    _keepEmptyElement(e) {
        this._emptyElementsToKeep.add(e)
    }

    _removeEmptyElements() {
        const e = new Map;
        for (const t of this._splitParts.keys()) if (t.isEmpty && !this._emptyElementsToKeep.has(t)) {
            const i = e.get(t.parent) || [];
            i.push(t), this._splitParts.delete(t), e.set(t.parent, i)
        }
        for (const [t, i] of e) t._removeChildrenArray(i);
        e.size && this._removeEmptyElements()
    }
}

function K_(s, e) {
    const t = new Set, i = new Map, n = b._createIn(s).getItems();
    for (const o of n) o.is("element", "$marker") && t.add(o);
    for (const o of t) {
        const r = o.getAttribute("data-name"), a = e.createPositionBefore(o);
        i.has(r) ? i.get(r).end = a.clone() : i.set(r, new b(a.clone())), e.remove(o)
    }
    return i
}

function Z_(s, e) {
    let t;
    for (const i of new Lt(s)) {
        const n = {};
        for (const r of i.getAttributeKeys()) n[r] = i.getAttribute(r);
        const o = e.createElement(i.name, n);
        t && e.insert(o, t), t = y._createAt(o, 0)
    }
    return t
}

class J_ {
    getHtml(e) {
        const i = C.document.implementation.createHTMLDocument("").createElement("div");
        return i.appendChild(e), i.innerHTML
    }
}

class Q_ {
    domParser;
    domConverter;
    htmlWriter;
    skipComments = !0;

    constructor(e) {
        this.domParser = new DOMParser, this.domConverter = new eo(e, {renderingMode: "data"}), this.htmlWriter = new J_
    }

    toData(e) {
        const t = this.domConverter.viewToDom(e);
        return this.htmlWriter.getHtml(t)
    }

    toView(e) {
        const t = this._toDom(e);
        return this.domConverter.domToView(t, {skipComments: this.skipComments})
    }

    registerRawContentMatcher(e) {
        this.domConverter.registerRawContentMatcher(e)
    }

    useFillerType(e) {
        this.domConverter.blockFillerMode = e == "marked" ? "markedNbsp" : "nbsp"
    }

    _toDom(e) {
        /<(?:html|body|head|meta)(?:\s[^>]*)?>/i.test(e.trim().slice(0, 1e4)) || (e = `<body>${e}</body>`);
        const t = this.domParser.parseFromString(e, "text/html"), i = t.createDocumentFragment(), n = t.body.childNodes;
        for (; n.length > 0;) i.appendChild(n[0]);
        return i
    }
}

class Y_ extends W() {
    model;
    mapper;
    downcastDispatcher;
    upcastDispatcher;
    viewDocument;
    stylesProcessor;
    htmlProcessor;
    processor;
    _viewWriter;

    constructor(e, t) {
        super(), this.model = e, this.mapper = new Vh, this.downcastDispatcher = new Oh({
            mapper: this.mapper,
            schema: e.schema
        }), this.downcastDispatcher.on("insert:$text", Fh(), {priority: "lowest"}), this.downcastDispatcher.on("insert", Lh(), {priority: "lowest"}), this.upcastDispatcher = new G_({schema: e.schema}), this.viewDocument = new Ys(t), this.stylesProcessor = t, this.htmlProcessor = new Q_(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new kh(this.viewDocument), this.upcastDispatcher.on("text", w_(), {priority: "lowest"}), this.upcastDispatcher.on("element", xl(), {priority: "lowest"}), this.upcastDispatcher.on("documentFragment", xl(), {priority: "lowest"}), H().prototype.decorate.call(this, "init"), H().prototype.decorate.call(this, "set"), H().prototype.decorate.call(this, "get"), H().prototype.decorate.call(this, "toView"), H().prototype.decorate.call(this, "toModel"), this.on("init", () => {
            this.fire("ready")
        }, {priority: "lowest"}), this.on("ready", () => {
            this.model.enqueueChange({isUndoable: !1}, Wh)
        }, {priority: "lowest"})
    }

    get(e = {}) {
        const {rootName: t = "main", trim: i = "empty"} = e;
        if (!this._checkIfRootsExists([t])) throw new p("datacontroller-get-non-existent-root", this);
        const n = this.model.document.getRoot(t);
        return n.isAttached() || L("datacontroller-get-detached-root", this), i === "empty" && !this.model.hasContent(n, {ignoreWhitespaces: !0}) ? "" : this.stringify(n, e)
    }

    stringify(e, t = {}) {
        const i = this.toView(e, t);
        return this.processor.toData(i)
    }

    toView(e, t = {}) {
        const i = this.viewDocument, n = this._viewWriter;
        this.mapper.clearBindings();
        const o = b._createIn(e), r = new Xt(i);
        this.mapper.bindElements(e, r);
        const a = e.is("documentFragment") ? e.markers : X_(e);
        return this.downcastDispatcher.convert(o, a, n, t), r
    }

    init(e) {
        if (this.model.document.version) throw new p("datacontroller-init-document-not-empty", this);
        let t = {};
        if (typeof e == "string" ? t.main = e : t = e, !this._checkIfRootsExists(Object.keys(t))) throw new p("datacontroller-init-non-existent-root", this);
        return this.model.enqueueChange({isUndoable: !1}, i => {
            for (const n of Object.keys(t)) {
                const o = this.model.document.getRoot(n);
                i.insert(this.parse(t[n], o), o, 0)
            }
        }), Promise.resolve()
    }

    set(e, t = {}) {
        let i = {};
        if (typeof e == "string" ? i.main = e : i = e, !this._checkIfRootsExists(Object.keys(i))) throw new p("datacontroller-set-non-existent-root", this);
        this.model.enqueueChange(t.batchType || {}, n => {
            n.setSelection(null), n.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
            for (const o of Object.keys(i)) {
                const r = this.model.document.getRoot(o);
                n.remove(n.createRangeIn(r)), n.insert(this.parse(i[o], r), r, 0)
            }
        })
    }

    parse(e, t = "$root") {
        const i = this.processor.toView(e);
        return this.toModel(i, t)
    }

    toModel(e, t = "$root") {
        return this.model.change(i => this.upcastDispatcher.convert(e, i, t))
    }

    addStyleProcessorRules(e) {
        e(this.stylesProcessor)
    }

    registerRawContentMatcher(e) {
        this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(e), this.htmlProcessor.registerRawContentMatcher(e)
    }

    destroy() {
        this.stopListening()
    }

    _checkIfRootsExists(e) {
        for (const t of e) if (!this.model.document.getRoot(t)) return !1;
        return !0
    }
}

function X_(s) {
    const e = [], t = s.root.document;
    if (!t) return new Map;
    const i = b._createIn(s);
    for (const n of t.model.markers) {
        const o = n.getRange(), r = o.isCollapsed, a = o.start.isEqual(i.start) || o.end.isEqual(i.end);
        if (r && a) e.push([n.name, o]); else {
            const l = i.getIntersection(o);
            l && e.push([n.name, l])
        }
    }
    return e.sort(([n, o], [r, a]) => {
        if (o.end.compareWith(a.start) !== "after") return 1;
        if (o.start.compareWith(a.end) !== "before") return -1;
        switch (o.start.compareWith(a.start)) {
            case"before":
                return 1;
            case"after":
                return -1;
            default:
                switch (o.end.compareWith(a.end)) {
                    case"before":
                        return 1;
                    case"after":
                        return -1;
                    default:
                        return r.localeCompare(n)
                }
        }
    }), new Map(e)
}

class e0 {
    _helpers = new Map;
    _downcast;
    _upcast;

    constructor(e, t) {
        this._downcast = U(e), this._createConversionHelpers({
            name: "downcast",
            dispatchers: this._downcast,
            isDowncast: !0
        }), this._upcast = U(t), this._createConversionHelpers({
            name: "upcast",
            dispatchers: this._upcast,
            isDowncast: !1
        })
    }

    addAlias(e, t) {
        const i = this._downcast.includes(t);
        if (!this._upcast.includes(t) && !i) throw new p("conversion-add-alias-dispatcher-not-registered", this);
        this._createConversionHelpers({name: e, dispatchers: [t], isDowncast: i})
    }

    for(e) {
        if (!this._helpers.has(e)) throw new p("conversion-for-unknown-group", this);
        return this._helpers.get(e)
    }

    elementToElement(e) {
        this.for("downcast").elementToElement(e);
        for (const {model: t, view: i} of Ao(e)) this.for("upcast").elementToElement({
            model: t,
            view: i,
            converterPriority: e.converterPriority
        })
    }

    attributeToElement(e) {
        this.for("downcast").attributeToElement(e);
        for (const {model: t, view: i} of Ao(e)) this.for("upcast").elementToAttribute({
            view: i,
            model: t,
            converterPriority: e.converterPriority
        })
    }

    attributeToAttribute(e) {
        this.for("downcast").attributeToAttribute(e);
        for (const {model: t, view: i} of Ao(e)) this.for("upcast").attributeToAttribute({view: i, model: t})
    }

    _createConversionHelpers({name: e, dispatchers: t, isDowncast: i}) {
        if (this._helpers.has(e)) throw new p("conversion-group-exists", this);
        const n = i ? new Db(t) : new p_(t);
        this._helpers.set(e, n)
    }
}

function* Ao(s) {
    if (s.model.values) for (const e of s.model.values) {
        const t = {key: s.model.key, value: e}, i = s.view[e], n = s.upcastAlso ? s.upcastAlso[e] : void 0;
        yield* Pl(t, i, n)
    } else yield* Pl(s.model, s.view, s.upcastAlso)
}

function* Pl(s, e, t) {
    if (yield{model: s, view: e}, t) for (const i of U(t)) yield{model: s, view: i}
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class Ue {
    baseVersion;
    isDocumentOperation;
    batch;

    constructor(e) {
        this.baseVersion = e, this.isDocumentOperation = this.baseVersion !== null, this.batch = null
    }

    _validate() {
    }

    toJSON() {
        const e = Object.assign({}, this);
        return e.__className = this.constructor.className, delete e.batch, delete e.isDocumentOperation, e
    }

    static get className() {
        return "Operation"
    }

    static fromJSON(e, t) {
        return new this(e.baseVersion)
    }
}

function ua(s, e) {
    const t = Qh(e), i = t.reduce((r, a) => r + a.offsetSize, 0), n = s.parent;
    Vn(s);
    const o = s.index;
    return n._insertChild(o, t), Rn(n, o + t.length), Rn(n, o), new b(s, s.getShiftedBy(i))
}

function Jh(s) {
    if (!s.isFlat) throw new p("operation-utils-remove-range-not-flat", this);
    const e = s.start.parent;
    Vn(s.start), Vn(s.end);
    const t = e._removeChildren(s.start.index, s.end.index - s.start.index);
    return Rn(e, s.start.index), t
}

function Pn(s, e) {
    if (!s.isFlat) throw new p("operation-utils-move-range-not-flat", this);
    const t = Jh(s);
    return e = e._getTransformedByDeletion(s.start, s.end.offset - s.start.offset), ua(e, t)
}

function t0(s, e, t) {
    Vn(s.start), Vn(s.end);
    for (const i of s.getItems({shallow: !0})) {
        const n = i.is("$textProxy") ? i.textNode : i;
        t !== null ? n._setAttribute(e, t) : n._removeAttribute(e), Rn(n.parent, n.index)
    }
    Rn(s.end.parent, s.end.index)
}

function Qh(s) {
    const e = [];

    function t(i) {
        if (typeof i == "string") e.push(new G(i)); else if (i instanceof et) e.push(new G(i.data, i.getAttributes())); else if (i instanceof ai) e.push(i); else if (ze(i)) for (const n of i) t(n)
    }

    t(s);
    for (let i = 1; i < e.length; i++) {
        const n = e[i], o = e[i - 1];
        n instanceof G && o instanceof G && Yh(n, o) && (e.splice(i - 1, 2, new G(o.data + n.data, o.getAttributes())), i--)
    }
    return e
}

function Rn(s, e) {
    const t = s.getChild(e - 1), i = s.getChild(e);
    if (t && i && t.is("$text") && i.is("$text") && Yh(t, i)) {
        const n = new G(t.data + i.data, t.getAttributes());
        s._removeChildren(e - 1, 2), s._insertChild(e - 1, n)
    }
}

function Vn(s) {
    const e = s.textNode, t = s.parent;
    if (e) {
        const i = s.offset - e.startOffset, n = e.index;
        t._removeChildren(n, 1);
        const o = new G(e.data.substr(0, i), e.getAttributes()), r = new G(e.data.substr(i), e.getAttributes());
        t._insertChild(n, [o, r])
    }
}

function Yh(s, e) {
    const t = s.getAttributes(), i = e.getAttributes();
    for (const n of t) {
        if (n[1] !== e.getAttribute(n[0])) return !1;
        i.next()
    }
    return i.next().done
}

class z extends Ue {
    sourcePosition;
    howMany;
    targetPosition;

    constructor(e, t, i, n) {
        super(n), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = t, this.targetPosition = i.clone(), this.targetPosition.stickiness = "toNone"
    }

    get type() {
        return this.targetPosition.root.rootName == "$graveyard" ? "remove" : this.sourcePosition.root.rootName == "$graveyard" ? "reinsert" : "move"
    }

    get affectedSelectable() {
        return [b._createFromPositionAndShift(this.sourcePosition, this.howMany), b._createFromPositionAndShift(this.targetPosition, 0)]
    }

    clone() {
        return new z(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion)
    }

    getMovedRangeStart() {
        return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany)
    }

    getReversed() {
        const e = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
        return new z(this.getMovedRangeStart(), this.howMany, e, this.baseVersion + 1)
    }

    _validate() {
        const e = this.sourcePosition.parent, t = this.targetPosition.parent, i = this.sourcePosition.offset,
            n = this.targetPosition.offset;
        if (i + this.howMany > e.maxOffset) throw new p("move-operation-nodes-do-not-exist", this);
        if (e === t && i < n && n < i + this.howMany) throw new p("move-operation-range-into-itself", this);
        if (this.sourcePosition.root == this.targetPosition.root && _e(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
            const o = this.sourcePosition.path.length - 1;
            if (this.targetPosition.path[o] >= i && this.targetPosition.path[o] < i + this.howMany) throw new p("move-operation-node-into-itself", this)
        }
    }

    _execute() {
        Pn(b._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition)
    }

    toJSON() {
        const e = super.toJSON();
        return e.sourcePosition = this.sourcePosition.toJSON(), e.targetPosition = this.targetPosition.toJSON(), e
    }

    static get className() {
        return "MoveOperation"
    }

    static fromJSON(e, t) {
        const i = y.fromJSON(e.sourcePosition, t), n = y.fromJSON(e.targetPosition, t);
        return new this(i, e.howMany, n, e.baseVersion)
    }
}

class he extends Ue {
    position;
    nodes;
    shouldReceiveAttributes;

    constructor(e, t, i) {
        super(i), this.position = e.clone(), this.position.stickiness = "toNone", this.nodes = new kn(Qh(t)), this.shouldReceiveAttributes = !1
    }

    get type() {
        return "insert"
    }

    get howMany() {
        return this.nodes.maxOffset
    }

    get affectedSelectable() {
        return this.position.clone()
    }

    clone() {
        const e = new kn([...this.nodes].map(i => i._clone(!0))), t = new he(this.position, e, this.baseVersion);
        return t.shouldReceiveAttributes = this.shouldReceiveAttributes, t
    }

    getReversed() {
        const e = this.position.root.document.graveyard, t = new y(e, [0]);
        return new z(this.position, this.nodes.maxOffset, t, this.baseVersion + 1)
    }

    _validate() {
        const e = this.position.parent;
        if (!e || e.maxOffset < this.position.offset) throw new p("insert-operation-position-invalid", this)
    }

    _execute() {
        const e = this.nodes;
        this.nodes = new kn([...e].map(t => t._clone(!0))), ua(this.position, e)
    }

    toJSON() {
        const e = super.toJSON();
        return e.position = this.position.toJSON(), e.nodes = this.nodes.toJSON(), e
    }

    static get className() {
        return "InsertOperation"
    }

    static fromJSON(e, t) {
        const i = [];
        for (const o of e.nodes) o.name ? i.push(j.fromJSON(o)) : i.push(G.fromJSON(o));
        const n = new he(y.fromJSON(e.position, t), i, e.baseVersion);
        return n.shouldReceiveAttributes = e.shouldReceiveAttributes, n
    }
}

class q extends Ue {
    splitPosition;
    howMany;
    insertionPosition;
    graveyardPosition;

    constructor(e, t, i, n, o) {
        super(o), this.splitPosition = e.clone(), this.splitPosition.stickiness = "toNext", this.howMany = t, this.insertionPosition = i, this.graveyardPosition = n ? n.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext")
    }

    get type() {
        return "split"
    }

    get moveTargetPosition() {
        const e = this.insertionPosition.path.slice();
        return e.push(0), new y(this.insertionPosition.root, e)
    }

    get movedRange() {
        const e = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
        return new b(this.splitPosition, e)
    }

    get affectedSelectable() {
        const e = [b._createFromPositionAndShift(this.splitPosition, 0), b._createFromPositionAndShift(this.insertionPosition, 0)];
        return this.graveyardPosition && e.push(b._createFromPositionAndShift(this.graveyardPosition, 0)), e
    }

    clone() {
        return new q(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion)
    }

    getReversed() {
        const e = this.splitPosition.root.document.graveyard, t = new y(e, [0]);
        return new ne(this.moveTargetPosition, this.howMany, this.splitPosition, t, this.baseVersion + 1)
    }

    _validate() {
        const e = this.splitPosition.parent, t = this.splitPosition.offset;
        if (!e || e.maxOffset < t) throw new p("split-operation-position-invalid", this);
        if (e.parent) {
            if (this.howMany != e.maxOffset - this.splitPosition.offset) throw new p("split-operation-how-many-invalid", this);
            if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) throw new p("split-operation-graveyard-position-invalid", this)
        } else throw new p("split-operation-split-in-root", this)
    }

    _execute() {
        const e = this.splitPosition.parent;
        if (this.graveyardPosition) Pn(b._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition); else {
            const i = e._clone();
            ua(this.insertionPosition, i)
        }
        const t = new b(y._createAt(e, this.splitPosition.offset), y._createAt(e, e.maxOffset));
        Pn(t, this.moveTargetPosition)
    }

    toJSON() {
        const e = super.toJSON();
        return e.splitPosition = this.splitPosition.toJSON(), e.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (e.graveyardPosition = this.graveyardPosition.toJSON()), e
    }

    static get className() {
        return "SplitOperation"
    }

    static getInsertionPosition(e) {
        const t = e.path.slice(0, -1);
        return t[t.length - 1]++, new y(e.root, t, "toPrevious")
    }

    static fromJSON(e, t) {
        const i = y.fromJSON(e.splitPosition, t), n = y.fromJSON(e.insertionPosition, t),
            o = e.graveyardPosition ? y.fromJSON(e.graveyardPosition, t) : null;
        return new this(i, e.howMany, n, o, e.baseVersion)
    }
}

class ne extends Ue {
    sourcePosition;
    howMany;
    targetPosition;
    graveyardPosition;

    constructor(e, t, i, n, o) {
        super(o), this.sourcePosition = e.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = t, this.targetPosition = i.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = n.clone()
    }

    get type() {
        return "merge"
    }

    get deletionPosition() {
        return new y(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1))
    }

    get movedRange() {
        const e = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
        return new b(this.sourcePosition, e)
    }

    get affectedSelectable() {
        const e = this.sourcePosition.parent;
        return [b._createOn(e), b._createFromPositionAndShift(this.targetPosition, 0), b._createFromPositionAndShift(this.graveyardPosition, 0)]
    }

    clone() {
        return new ne(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion)
    }

    getReversed() {
        const e = this.targetPosition._getTransformedByMergeOperation(this), t = this.sourcePosition.path.slice(0, -1),
            i = new y(this.sourcePosition.root, t)._getTransformedByMergeOperation(this);
        return new q(e, this.howMany, i, this.graveyardPosition, this.baseVersion + 1)
    }

    _validate() {
        const e = this.sourcePosition.parent, t = this.targetPosition.parent;
        if (e.parent) if (t.parent) {
            if (this.howMany != e.maxOffset) throw new p("merge-operation-how-many-invalid", this)
        } else throw new p("merge-operation-target-position-invalid", this); else throw new p("merge-operation-source-position-invalid", this)
    }

    _execute() {
        const e = this.sourcePosition.parent, t = b._createIn(e);
        Pn(t, this.targetPosition), Pn(b._createOn(e), this.graveyardPosition)
    }

    toJSON() {
        const e = super.toJSON();
        return e.sourcePosition = e.sourcePosition.toJSON(), e.targetPosition = e.targetPosition.toJSON(), e.graveyardPosition = e.graveyardPosition.toJSON(), e
    }

    static get className() {
        return "MergeOperation"
    }

    static fromJSON(e, t) {
        const i = y.fromJSON(e.sourcePosition, t), n = y.fromJSON(e.targetPosition, t),
            o = y.fromJSON(e.graveyardPosition, t);
        return new this(i, e.howMany, n, o, e.baseVersion)
    }
}

class Ee extends Ue {
    name;
    oldRange;
    newRange;
    affectsData;
    _markers;

    constructor(e, t, i, n, o, r) {
        super(r), this.name = e, this.oldRange = t ? t.clone() : null, this.newRange = i ? i.clone() : null, this.affectsData = o, this._markers = n
    }

    get type() {
        return "marker"
    }

    get affectedSelectable() {
        const e = [];
        return this.oldRange && e.push(this.oldRange.clone()), this.newRange && (this.oldRange ? e.push(...this.newRange.getDifference(this.oldRange)) : e.push(this.newRange.clone())), e
    }

    clone() {
        return new Ee(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion)
    }

    getReversed() {
        return new Ee(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1)
    }

    _execute() {
        this.newRange ? this._markers._set(this.name, this.newRange, !0, this.affectsData) : this._markers._remove(this.name)
    }

    toJSON() {
        const e = super.toJSON();
        return this.oldRange && (e.oldRange = this.oldRange.toJSON()), this.newRange && (e.newRange = this.newRange.toJSON()), delete e._markers, e
    }

    static get className() {
        return "MarkerOperation"
    }

    static fromJSON(e, t) {
        return new Ee(e.name, e.oldRange ? b.fromJSON(e.oldRange, t) : null, e.newRange ? b.fromJSON(e.newRange, t) : null, t.model.markers, e.affectsData, e.baseVersion)
    }
}

class oe extends Ue {
    range;
    key;
    oldValue;
    newValue;

    constructor(e, t, i, n, o) {
        super(o), this.range = e.clone(), this.key = t, this.oldValue = i === void 0 ? null : i, this.newValue = n === void 0 ? null : n
    }

    get type() {
        return this.oldValue === null ? "addAttribute" : this.newValue === null ? "removeAttribute" : "changeAttribute"
    }

    get affectedSelectable() {
        return this.range.clone()
    }

    clone() {
        return new oe(this.range, this.key, this.oldValue, this.newValue, this.baseVersion)
    }

    getReversed() {
        return new oe(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
    }

    toJSON() {
        const e = super.toJSON();
        return e.range = this.range.toJSON(), e
    }

    _validate() {
        if (!this.range.isFlat) throw new p("attribute-operation-range-not-flat", this);
        for (const e of this.range.getItems({shallow: !0})) {
            if (this.oldValue !== null && !Ps(e.getAttribute(this.key), this.oldValue)) throw new p("attribute-operation-wrong-old-value", this, {
                item: e,
                key: this.key,
                value: this.oldValue
            });
            if (this.oldValue === null && this.newValue !== null && e.hasAttribute(this.key)) throw new p("attribute-operation-attribute-exists", this, {
                node: e,
                key: this.key
            })
        }
    }

    _execute() {
        Ps(this.oldValue, this.newValue) || t0(this.range, this.key, this.newValue)
    }

    static get className() {
        return "AttributeOperation"
    }

    static fromJSON(e, t) {
        return new oe(b.fromJSON(e.range, t), e.key, e.oldValue, e.newValue, e.baseVersion)
    }
}

class de extends Ue {
    get type() {
        return "noop"
    }

    get affectedSelectable() {
        return null
    }

    clone() {
        return new de(this.baseVersion)
    }

    getReversed() {
        return new de(this.baseVersion + 1)
    }

    _execute() {
    }

    static get className() {
        return "NoOperation"
    }
}

class Re extends Ue {
    position;
    oldName;
    newName;

    constructor(e, t, i, n) {
        super(n), this.position = e, this.position.stickiness = "toNext", this.oldName = t, this.newName = i
    }

    get type() {
        return "rename"
    }

    get affectedSelectable() {
        return this.position.nodeAfter
    }

    clone() {
        return new Re(this.position.clone(), this.oldName, this.newName, this.baseVersion)
    }

    getReversed() {
        return new Re(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1)
    }

    _validate() {
        const e = this.position.nodeAfter;
        if (e instanceof j) {
            if (e.name !== this.oldName) throw new p("rename-operation-wrong-name", this)
        } else throw new p("rename-operation-wrong-position", this)
    }

    _execute() {
        const e = this.position.nodeAfter;
        e.name = this.newName
    }

    toJSON() {
        const e = super.toJSON();
        return e.position = this.position.toJSON(), e
    }

    static get className() {
        return "RenameOperation"
    }

    static fromJSON(e, t) {
        return new Re(y.fromJSON(e.position, t), e.oldName, e.newName, e.baseVersion)
    }
}

class Tt extends Ue {
    root;
    key;
    oldValue;
    newValue;

    constructor(e, t, i, n, o) {
        super(o), this.root = e, this.key = t, this.oldValue = i === void 0 ? null : i, this.newValue = n === void 0 ? null : n
    }

    get type() {
        return this.oldValue === null ? "addRootAttribute" : this.newValue === null ? "removeRootAttribute" : "changeRootAttribute"
    }

    get affectedSelectable() {
        return this.root
    }

    clone() {
        return new Tt(this.root, this.key, this.oldValue, this.newValue, this.baseVersion)
    }

    getReversed() {
        return new Tt(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1)
    }

    _validate() {
        if (this.root != this.root.root || this.root.is("documentFragment")) throw new p("rootattribute-operation-not-a-root", this, {
            root: this.root,
            key: this.key
        });
        if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) throw new p("rootattribute-operation-wrong-old-value", this, {
            root: this.root,
            key: this.key
        });
        if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) throw new p("rootattribute-operation-attribute-exists", this, {
            root: this.root,
            key: this.key
        })
    }

    _execute() {
        this.newValue !== null ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key)
    }

    toJSON() {
        const e = super.toJSON();
        return e.root = this.root.toJSON(), e
    }

    static get className() {
        return "RootAttributeOperation"
    }

    static fromJSON(e, t) {
        if (!t.getRoot(e.root)) throw new p("rootattribute-operation-fromjson-no-root", this, {rootName: e.root});
        return new Tt(t.getRoot(e.root), e.key, e.oldValue, e.newValue, e.baseVersion)
    }
}

class ut extends Ue {
    rootName;
    elementName;
    isAdd;
    _document;

    constructor(e, t, i, n, o) {
        if (super(o), this.rootName = e, this.elementName = t, this.isAdd = i, this._document = n, !this._document.getRoot(this.rootName)) {
            const r = this._document.createRoot(this.elementName, this.rootName);
            r._isAttached = !1
        }
    }

    get type() {
        return this.isAdd ? "addRoot" : "detachRoot"
    }

    get affectedSelectable() {
        return this._document.getRoot(this.rootName)
    }

    clone() {
        return new ut(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion)
    }

    getReversed() {
        return new ut(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1)
    }

    _execute() {
        this._document.getRoot(this.rootName)._isAttached = this.isAdd
    }

    toJSON() {
        const e = super.toJSON();
        return delete e._document, e
    }

    static get className() {
        return "RootOperation"
    }

    static fromJSON(e, t) {
        return new ut(e.rootName, e.elementName, e.isAdd, t, e.baseVersion)
    }
}

const Je = {};
Je[oe.className] = oe;
Je[he.className] = he;
Je[Ee.className] = Ee;
Je[z.className] = z;
Je[de.className] = de;
Je[Ue.className] = Ue;
Je[Re.className] = Re;
Je[Tt.className] = Tt;
Je[ut.className] = ut;
Je[q.className] = q;
Je[ne.className] = ne;

class i0 {
    static fromJSON(e, t) {
        return Je[e.__className].fromJSON(e, t)
    }
}

const wr = new Map;

function D(s, e, t) {
    let i = wr.get(s);
    i || (i = new Map, wr.set(s, i)), i.set(e, t)
}

function n0(s, e) {
    const t = wr.get(s);
    return t && t.has(e) ? t.get(e) : s0
}

function s0(s) {
    return [s]
}

function Rl(s, e, t = {}) {
    const i = n0(s.constructor, e.constructor);
    try {
        return s = s.clone(), i(s, e, t)
    } catch (n) {
        throw n
    }
}

function o0(s, e, t) {
    s = s.slice(), e = e.slice();
    const i = new r0(t.document, t.useRelations, t.forceWeakRemove);
    i.setOriginalOperations(s), i.setOriginalOperations(e);
    const n = i.originalOperations;
    if (s.length == 0 || e.length == 0) return {operationsA: s, operationsB: e, originalOperations: n};
    const o = new WeakMap;
    for (const l of s) o.set(l, 0);
    const r = {
        nextBaseVersionA: s[s.length - 1].baseVersion + 1,
        nextBaseVersionB: e[e.length - 1].baseVersion + 1,
        originalOperationsACount: s.length,
        originalOperationsBCount: e.length
    };
    let a = 0;
    for (; a < s.length;) {
        const l = s[a], c = o.get(l);
        if (c == e.length) {
            a++;
            continue
        }
        const u = e[c], d = Rl(l, u, i.getContext(l, u, !0)), h = Rl(u, l, i.getContext(u, l, !1));
        i.updateRelation(l, u), i.setOriginalOperations(d, l), i.setOriginalOperations(h, u);
        for (const f of d) o.set(f, c + h.length);
        s.splice(a, 1, ...d), e.splice(c, 1, ...h)
    }
    return Ol(s), Ol(e), Vl(s, r.nextBaseVersionB), Vl(e, r.nextBaseVersionA), {
        operationsA: s,
        operationsB: e,
        originalOperations: n
    }
}

class r0 {
    originalOperations;
    _history;
    _useRelations;
    _forceWeakRemove;
    _relations;

    constructor(e, t, i = !1) {
        this.originalOperations = new Map, this._history = e.history, this._useRelations = t, this._forceWeakRemove = !!i, this._relations = new Map
    }

    setOriginalOperations(e, t = null) {
        const i = t ? this.originalOperations.get(t) : null;
        for (const n of e) this.originalOperations.set(n, i || n)
    }

    updateRelation(e, t) {
        if (e instanceof z) t instanceof ne ? e.targetPosition.isEqual(t.sourcePosition) || t.movedRange.containsPosition(e.targetPosition) ? this._setRelation(e, t, "insertAtSource") : e.targetPosition.isEqual(t.deletionPosition) ? this._setRelation(e, t, "insertBetween") : e.targetPosition.isAfter(t.sourcePosition) && this._setRelation(e, t, "moveTargetAfter") : t instanceof z && (e.targetPosition.isEqual(t.sourcePosition) || e.targetPosition.isBefore(t.sourcePosition) ? this._setRelation(e, t, "insertBefore") : this._setRelation(e, t, "insertAfter")); else if (e instanceof q) {
            if (t instanceof ne) e.splitPosition.isBefore(t.sourcePosition) && this._setRelation(e, t, "splitBefore"); else if (t instanceof z) if (e.splitPosition.isEqual(t.sourcePosition) || e.splitPosition.isBefore(t.sourcePosition)) this._setRelation(e, t, "splitBefore"); else {
                const i = b._createFromPositionAndShift(t.sourcePosition, t.howMany);
                if (e.splitPosition.hasSameParentAs(t.sourcePosition) && i.containsPosition(e.splitPosition)) {
                    const n = i.end.offset - e.splitPosition.offset, o = e.splitPosition.offset - i.start.offset;
                    this._setRelation(e, t, {howMany: n, offset: o})
                }
            }
        } else if (e instanceof ne) t instanceof ne ? (e.targetPosition.isEqual(t.sourcePosition) || this._setRelation(e, t, "mergeTargetNotMoved"), e.sourcePosition.isEqual(t.targetPosition) && this._setRelation(e, t, "mergeSourceNotMoved"), e.sourcePosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeSameElement")) : t instanceof q ? e.sourcePosition.isEqual(t.splitPosition) && this._setRelation(e, t, "splitAtSource") : t instanceof z && t.howMany > 0 && (e.sourcePosition.isEqual(t.sourcePosition.getShiftedBy(t.howMany)) && this._setRelation(e, t, "mergeSourceAffected"), e.targetPosition.isEqual(t.sourcePosition) && this._setRelation(e, t, "mergeTargetWasBefore")); else if (e instanceof Ee) {
            const i = e.newRange;
            if (!i) return;
            if (t instanceof ne) {
                const n = i.start.isEqual(t.targetPosition), o = i.start.isEqual(t.deletionPosition),
                    r = i.end.isEqual(t.deletionPosition), a = i.end.isEqual(t.sourcePosition);
                (n || o || r || a) && this._setRelation(e, t, {
                    wasInLeftElement: n,
                    wasStartBeforeMergedElement: o,
                    wasEndBeforeMergedElement: r,
                    wasInRightElement: a
                })
            }
        }
    }

    getContext(e, t, i) {
        return {
            aIsStrong: i,
            aWasUndone: this._wasUndone(e),
            bWasUndone: this._wasUndone(t),
            abRelation: this._useRelations ? this._getRelation(e, t) : null,
            baRelation: this._useRelations ? this._getRelation(t, e) : null,
            forceWeakRemove: this._forceWeakRemove
        }
    }

    _wasUndone(e) {
        const t = this.originalOperations.get(e);
        return t.wasUndone || this._history.isUndoneOperation(t)
    }

    _getRelation(e, t) {
        const i = this.originalOperations.get(t), n = this._history.getUndoneOperation(i);
        if (!n) return null;
        const o = this.originalOperations.get(e), r = this._relations.get(o);
        return r && r.get(n) || null
    }

    _setRelation(e, t, i) {
        const n = this.originalOperations.get(e), o = this.originalOperations.get(t);
        let r = this._relations.get(n);
        r || (r = new Map, this._relations.set(n, r)), r.set(o, i)
    }
}

function Vl(s, e) {
    for (const t of s) t.baseVersion = e++
}

function Ol(s) {
    const e = new Map;
    for (let t = 0; t < s.length; t++) {
        const i = s[t];
        i instanceof Ee && (i.baseVersion !== -1 ? e.set(i.name, {
            op: i,
            ranges: i.newRange ? [i.newRange] : []
        }) : (i.newRange && e.get(i.name).ranges.push(i.newRange), s.splice(t, 1), t--))
    }
    for (const {op: t, ranges: i} of e.values()) i.length ? t.newRange = b._createFromRanges(i) : t.newRange = null
}

D(oe, oe, (s, e, t) => {
    if (s.key === e.key && s.range.start.hasSameParentAs(e.range.start)) {
        const i = s.range.getDifference(e.range).map(o => new oe(o, s.key, s.oldValue, s.newValue, 0)),
            n = s.range.getIntersection(e.range);
        return n && t.aIsStrong && i.push(new oe(n, e.key, e.newValue, s.newValue, 0)), i.length == 0 ? [new de(0)] : i
    } else return [s]
});
D(oe, he, (s, e) => {
    if (s.range.start.hasSameParentAs(e.position) && s.range.containsPosition(e.position)) {
        const i = s.range._getTransformedByInsertion(e.position, e.howMany, !e.shouldReceiveAttributes).map(n => new oe(n, s.key, s.oldValue, s.newValue, s.baseVersion));
        if (e.shouldReceiveAttributes) {
            const n = Xh(e, s.key, s.oldValue);
            n && i.unshift(n)
        }
        return i
    }
    return s.range = s.range._getTransformedByInsertion(e.position, e.howMany, !1)[0], [s]
});

function Xh(s, e, t) {
    const n = s.nodes.getNode(0).getAttribute(e);
    if (n == t) return null;
    const o = new b(s.position, s.position.getShiftedBy(s.howMany));
    return new oe(o, e, n, t, 0)
}

D(oe, ne, (s, e) => {
    const t = [];
    s.range.start.hasSameParentAs(e.deletionPosition) && (s.range.containsPosition(e.deletionPosition) || s.range.start.isEqual(e.deletionPosition)) && t.push(b._createFromPositionAndShift(e.graveyardPosition, 1));
    const i = s.range._getTransformedByMergeOperation(e);
    return i.isCollapsed || t.push(i), t.map(n => new oe(n, s.key, s.oldValue, s.newValue, s.baseVersion))
});
D(oe, z, (s, e) => a0(s.range, e).map(i => new oe(i, s.key, s.oldValue, s.newValue, s.baseVersion)));

function a0(s, e) {
    const t = b._createFromPositionAndShift(e.sourcePosition, e.howMany);
    let i = null, n = [];
    t.containsRange(s, !0) ? i = s : s.start.hasSameParentAs(t.start) ? (n = s.getDifference(t), i = s.getIntersection(t)) : n = [s];
    const o = [];
    for (let r of n) {
        r = r._getTransformedByDeletion(e.sourcePosition, e.howMany);
        const a = e.getMovedRangeStart(), l = r.start.hasSameParentAs(a),
            c = r._getTransformedByInsertion(a, e.howMany, l);
        o.push(...c)
    }
    return i && o.push(i._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany, !1)[0]), o
}

D(oe, q, (s, e) => {
    if (s.range.end.isEqual(e.insertionPosition)) return e.graveyardPosition || s.range.end.offset++, [s];
    if (s.range.start.hasSameParentAs(e.splitPosition) && s.range.containsPosition(e.splitPosition)) {
        const t = s.clone();
        return t.range = new b(e.moveTargetPosition.clone(), s.range.end._getCombined(e.splitPosition, e.moveTargetPosition)), s.range.end = e.splitPosition.clone(), s.range.end.stickiness = "toPrevious", [s, t]
    }
    return s.range = s.range._getTransformedBySplitOperation(e), [s]
});
D(he, oe, (s, e) => {
    const t = [s];
    if (s.shouldReceiveAttributes && s.position.hasSameParentAs(e.range.start) && e.range.containsPosition(s.position)) {
        const i = Xh(s, e.key, e.newValue);
        i && t.push(i)
    }
    return t
});
D(he, he, (s, e, t) => s.position.isEqual(e.position) && t.aIsStrong ? [s] : (s.position = s.position._getTransformedByInsertOperation(e), [s]));
D(he, z, (s, e) => (s.position = s.position._getTransformedByMoveOperation(e), [s]));
D(he, q, (s, e) => (s.position = s.position._getTransformedBySplitOperation(e), [s]));
D(he, ne, (s, e) => (s.position = s.position._getTransformedByMergeOperation(e), [s]));
D(Ee, he, (s, e) => (s.oldRange && (s.oldRange = s.oldRange._getTransformedByInsertOperation(e)[0]), s.newRange && (s.newRange = s.newRange._getTransformedByInsertOperation(e)[0]), [s]));
D(Ee, Ee, (s, e, t) => {
    if (s.name == e.name) if (t.aIsStrong) s.oldRange = e.newRange ? e.newRange.clone() : null; else return [new de(0)];
    return [s]
});
D(Ee, ne, (s, e) => (s.oldRange && (s.oldRange = s.oldRange._getTransformedByMergeOperation(e)), s.newRange && (s.newRange = s.newRange._getTransformedByMergeOperation(e)), [s]));
D(Ee, z, (s, e) => {
    const t = [s];
    if (s.oldRange && (s.oldRange = b._createFromRanges(s.oldRange._getTransformedByMoveOperation(e))), s.newRange) {
        const i = s.newRange._getTransformedByMoveOperation(e);
        s.newRange = i[0];
        for (let n = 1; n < i.length; n++) {
            const o = s.clone();
            o.oldRange = null, o.newRange = i[n], o.baseVersion = -1, t.push(o)
        }
    }
    return t
});
D(Ee, q, (s, e, t) => {
    if (s.oldRange && (s.oldRange = s.oldRange._getTransformedBySplitOperation(e)), s.newRange) {
        if (t.abRelation) {
            const i = s.newRange._getTransformedBySplitOperation(e);
            return s.newRange.start.isEqual(e.splitPosition) ? t.abRelation.wasStartBeforeMergedElement ? s.newRange.start = y._createAt(e.insertionPosition) : t.abRelation.wasInLeftElement ? s.newRange.start = y._createAt(s.newRange.start) : s.newRange.start = y._createAt(e.moveTargetPosition) : s.newRange.start = i.start, s.newRange.end.isEqual(e.splitPosition) ? s.newRange.end.isEqual(e.splitPosition) && t.abRelation.wasEndBeforeMergedElement ? s.newRange.end = y._createAt(e.insertionPosition) : t.abRelation.wasInRightElement ? s.newRange.end = y._createAt(e.moveTargetPosition) : s.newRange.end = y._createAt(s.newRange.end) : s.newRange.end = i.end, [s]
        }
        s.newRange = s.newRange._getTransformedBySplitOperation(e)
    }
    return [s]
});
D(ne, he, (s, e) => (s.sourcePosition.hasSameParentAs(e.position) && (s.howMany += e.howMany), s.sourcePosition = s.sourcePosition._getTransformedByInsertOperation(e), s.targetPosition = s.targetPosition._getTransformedByInsertOperation(e), [s]));
D(ne, ne, (s, e, t) => {
    if (s.sourcePosition.isEqual(e.sourcePosition) && s.targetPosition.isEqual(e.targetPosition)) if (t.bWasUndone) {
        const i = e.graveyardPosition.path.slice();
        return i.push(0), s.sourcePosition = new y(e.graveyardPosition.root, i), s.howMany = 0, [s]
    } else return [new de(0)];
    if (s.sourcePosition.isEqual(e.sourcePosition) && !s.targetPosition.isEqual(e.targetPosition) && !t.bWasUndone && t.abRelation != "splitAtSource") {
        const i = s.targetPosition.root.rootName == "$graveyard", n = e.targetPosition.root.rootName == "$graveyard";
        if (n && !i || !(i && !n) && t.aIsStrong) {
            const l = e.targetPosition._getTransformedByMergeOperation(e),
                c = s.targetPosition._getTransformedByMergeOperation(e);
            return [new z(l, s.howMany, c, 0)]
        } else return [new de(0)]
    }
    return s.sourcePosition.hasSameParentAs(e.targetPosition) && (s.howMany += e.howMany), s.sourcePosition = s.sourcePosition._getTransformedByMergeOperation(e), s.targetPosition = s.targetPosition._getTransformedByMergeOperation(e), (!s.graveyardPosition.isEqual(e.graveyardPosition) || !t.aIsStrong) && (s.graveyardPosition = s.graveyardPosition._getTransformedByMergeOperation(e)), [s]
});
D(ne, z, (s, e, t) => {
    const i = b._createFromPositionAndShift(e.sourcePosition, e.howMany);
    return e.type == "remove" && !t.bWasUndone && s.deletionPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(s.sourcePosition) ? [new de(0)] : (e.sourcePosition.getShiftedBy(e.howMany).isEqual(s.sourcePosition) ? s.sourcePosition.stickiness = "toNone" : e.targetPosition.isEqual(s.sourcePosition) && t.abRelation == "mergeSourceAffected" ? s.sourcePosition.stickiness = "toNext" : e.sourcePosition.isEqual(s.targetPosition) ? (s.targetPosition.stickiness = "toNone", s.howMany -= e.howMany) : e.targetPosition.isEqual(s.targetPosition) && t.abRelation == "mergeTargetWasBefore" ? (s.targetPosition.stickiness = "toPrevious", s.howMany += e.howMany) : (s.sourcePosition.hasSameParentAs(e.targetPosition) && (s.howMany += e.howMany), s.sourcePosition.hasSameParentAs(e.sourcePosition) && (s.howMany -= e.howMany)), s.sourcePosition = s.sourcePosition._getTransformedByMoveOperation(e), s.targetPosition = s.targetPosition._getTransformedByMoveOperation(e), s.sourcePosition.stickiness = "toPrevious", s.targetPosition.stickiness = "toNext", s.graveyardPosition.isEqual(e.targetPosition) || (s.graveyardPosition = s.graveyardPosition._getTransformedByMoveOperation(e)), [s])
});
D(ne, q, (s, e, t) => {
    if (e.graveyardPosition && (s.graveyardPosition = s.graveyardPosition._getTransformedByDeletion(e.graveyardPosition, 1), s.deletionPosition.isEqual(e.graveyardPosition) && (s.howMany = e.howMany)), s.targetPosition.isEqual(e.splitPosition) && (e.graveyardPosition && s.deletionPosition.isEqual(e.graveyardPosition) || t.abRelation == "mergeTargetNotMoved")) return s.sourcePosition = s.sourcePosition._getTransformedBySplitOperation(e), [s];
    if (s.sourcePosition.isEqual(e.splitPosition)) {
        if (t.abRelation == "mergeSourceNotMoved") return s.howMany = 0, s.targetPosition = s.targetPosition._getTransformedBySplitOperation(e), [s];
        if (t.abRelation == "mergeSameElement" || s.sourcePosition.offset > 0) return s.sourcePosition = e.moveTargetPosition.clone(), s.targetPosition = s.targetPosition._getTransformedBySplitOperation(e), [s]
    }
    return s.sourcePosition.hasSameParentAs(e.splitPosition) && (s.howMany = e.splitPosition.offset), s.sourcePosition = s.sourcePosition._getTransformedBySplitOperation(e), s.targetPosition = s.targetPosition._getTransformedBySplitOperation(e), [s]
});
D(z, he, (s, e) => {
    const i = b._createFromPositionAndShift(s.sourcePosition, s.howMany)._getTransformedByInsertOperation(e, !1)[0];
    return s.sourcePosition = i.start, s.howMany = i.end.offset - i.start.offset, s.targetPosition.isEqual(e.position) || (s.targetPosition = s.targetPosition._getTransformedByInsertOperation(e)), [s]
});
D(z, z, (s, e, t) => {
    const i = b._createFromPositionAndShift(s.sourcePosition, s.howMany),
        n = b._createFromPositionAndShift(e.sourcePosition, e.howMany);
    let o = t.aIsStrong, r = !t.aIsStrong;
    t.abRelation == "insertBefore" || t.baRelation == "insertAfter" ? r = !0 : (t.abRelation == "insertAfter" || t.baRelation == "insertBefore") && (r = !1);
    let a;
    if (s.targetPosition.isEqual(e.targetPosition) && r ? a = s.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) : a = s.targetPosition._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Ml(s, e) && Ml(e, s)) return [e.getReversed()];
    if (i.containsPosition(e.targetPosition) && i.containsRange(n, !0)) return i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Mi([i], a);
    if (n.containsPosition(s.targetPosition) && n.containsRange(i, !0)) return i.start = i.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), i.end = i.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), Mi([i], a);
    const u = _e(s.sourcePosition.getParentPath(), e.sourcePosition.getParentPath());
    if (u == "prefix" || u == "extension") return i.start = i.start._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), i.end = i.end._getTransformedByMove(e.sourcePosition, e.targetPosition, e.howMany), Mi([i], a);
    s.type == "remove" && e.type != "remove" && !t.aWasUndone && !t.forceWeakRemove ? o = !0 : s.type != "remove" && e.type == "remove" && !t.bWasUndone && !t.forceWeakRemove && (o = !1);
    const d = [], h = i.getDifference(n);
    for (const m of h) {
        m.start = m.start._getTransformedByDeletion(e.sourcePosition, e.howMany), m.end = m.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
        const g = _e(m.start.getParentPath(), e.getMovedRangeStart().getParentPath()) == "same",
            _ = m._getTransformedByInsertion(e.getMovedRangeStart(), e.howMany, g);
        d.push(..._)
    }
    const f = i.getIntersection(n);
    return f !== null && o && (f.start = f.start._getCombined(e.sourcePosition, e.getMovedRangeStart()), f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart()), d.length === 0 ? d.push(f) : d.length == 1 ? n.start.isBefore(i.start) || n.start.isEqual(i.start) ? d.unshift(f) : d.push(f) : d.splice(1, 0, f)), d.length === 0 ? [new de(s.baseVersion)] : Mi(d, a)
});
D(z, q, (s, e, t) => {
    let i = s.targetPosition.clone();
    (!s.targetPosition.isEqual(e.insertionPosition) || !e.graveyardPosition || t.abRelation == "moveTargetAfter") && (i = s.targetPosition._getTransformedBySplitOperation(e));
    const n = b._createFromPositionAndShift(s.sourcePosition, s.howMany);
    if (n.end.isEqual(e.insertionPosition)) return e.graveyardPosition || s.howMany++, s.targetPosition = i, [s];
    if (n.start.hasSameParentAs(e.splitPosition) && n.containsPosition(e.splitPosition)) {
        let a = new b(e.splitPosition, n.end);
        a = a._getTransformedBySplitOperation(e);
        const l = [new b(n.start, e.splitPosition), a];
        return Mi(l, i)
    }
    s.targetPosition.isEqual(e.splitPosition) && t.abRelation == "insertAtSource" && (i = e.moveTargetPosition), s.targetPosition.isEqual(e.insertionPosition) && t.abRelation == "insertBetween" && (i = s.targetPosition);
    const r = [n._getTransformedBySplitOperation(e)];
    if (e.graveyardPosition) {
        const a = n.start.isEqual(e.graveyardPosition) || n.containsPosition(e.graveyardPosition);
        s.howMany > 1 && a && !t.aWasUndone && r.push(b._createFromPositionAndShift(e.insertionPosition, 1))
    }
    return Mi(r, i)
});
D(z, ne, (s, e, t) => {
    const i = b._createFromPositionAndShift(s.sourcePosition, s.howMany);
    if (e.deletionPosition.hasSameParentAs(s.sourcePosition) && i.containsPosition(e.sourcePosition)) {
        if (s.type == "remove" && !t.forceWeakRemove) {
            if (!t.aWasUndone) {
                const r = [];
                let a = e.graveyardPosition.clone(), l = e.targetPosition._getTransformedByMergeOperation(e);
                const c = s.targetPosition.getTransformedByOperation(e);
                s.howMany > 1 && (r.push(new z(s.sourcePosition, s.howMany - 1, c, 0)), a = a._getTransformedByMove(s.sourcePosition, c, s.howMany - 1), l = l._getTransformedByMove(s.sourcePosition, c, s.howMany - 1));
                const u = e.deletionPosition._getCombined(s.sourcePosition, c), d = new z(a, 1, u, 0),
                    h = d.getMovedRangeStart().path.slice();
                h.push(0);
                const f = new y(d.targetPosition.root, h);
                l = l._getTransformedByMove(a, u, 1);
                const m = new z(l, e.howMany, f, 0);
                return r.push(d), r.push(m), r
            }
        } else if (s.howMany == 1) return t.bWasUndone ? (s.sourcePosition = e.graveyardPosition.clone(), s.targetPosition = s.targetPosition._getTransformedByMergeOperation(e), [s]) : [new de(0)]
    }
    const o = b._createFromPositionAndShift(s.sourcePosition, s.howMany)._getTransformedByMergeOperation(e);
    return s.sourcePosition = o.start, s.howMany = o.end.offset - o.start.offset, s.targetPosition = s.targetPosition._getTransformedByMergeOperation(e), [s]
});
D(Re, he, (s, e) => (s.position = s.position._getTransformedByInsertOperation(e), [s]));
D(Re, ne, (s, e) => s.position.isEqual(e.deletionPosition) ? (s.position = e.graveyardPosition.clone(), s.position.stickiness = "toNext", [s]) : (s.position = s.position._getTransformedByMergeOperation(e), [s]));
D(Re, z, (s, e) => (s.position = s.position._getTransformedByMoveOperation(e), [s]));
D(Re, Re, (s, e, t) => {
    if (s.position.isEqual(e.position)) if (t.aIsStrong) s.oldName = e.newName; else return [new de(0)];
    return [s]
});
D(Re, q, (s, e) => {
    const t = s.position.path, i = e.splitPosition.getParentPath();
    if (_e(t, i) == "same" && !e.graveyardPosition) {
        const n = new Re(s.position.getShiftedBy(1), s.oldName, s.newName, 0);
        return [s, n]
    }
    return s.position = s.position._getTransformedBySplitOperation(e), [s]
});
D(Tt, Tt, (s, e, t) => {
    if (s.root === e.root && s.key === e.key) {
        if (!t.aIsStrong || s.newValue === e.newValue) return [new de(0)];
        s.oldValue = e.newValue
    }
    return [s]
});
D(ut, ut, (s, e) => s.rootName === e.rootName && s.isAdd === e.isAdd ? [new de(0)] : [s]);
D(q, he, (s, e) => (s.splitPosition.hasSameParentAs(e.position) && s.splitPosition.offset < e.position.offset && (s.howMany += e.howMany), s.splitPosition = s.splitPosition._getTransformedByInsertOperation(e), s.insertionPosition = s.insertionPosition._getTransformedByInsertOperation(e), [s]));
D(q, ne, (s, e, t) => {
    if (!s.graveyardPosition && !t.bWasUndone && s.splitPosition.hasSameParentAs(e.sourcePosition)) {
        const i = e.graveyardPosition.path.slice();
        i.push(0);
        const n = new y(e.graveyardPosition.root, i), o = q.getInsertionPosition(new y(e.graveyardPosition.root, i)),
            r = new q(n, 0, o, null, 0);
        return s.splitPosition = s.splitPosition._getTransformedByMergeOperation(e), s.insertionPosition = q.getInsertionPosition(s.splitPosition), s.graveyardPosition = r.insertionPosition.clone(), s.graveyardPosition.stickiness = "toNext", [r, s]
    }
    return s.splitPosition.hasSameParentAs(e.deletionPosition) && !s.splitPosition.isAfter(e.deletionPosition) && s.howMany--, s.splitPosition.hasSameParentAs(e.targetPosition) && (s.howMany += e.howMany), s.splitPosition = s.splitPosition._getTransformedByMergeOperation(e), s.insertionPosition = q.getInsertionPosition(s.splitPosition), s.graveyardPosition && (s.graveyardPosition = s.graveyardPosition._getTransformedByMergeOperation(e)), [s]
});
D(q, z, (s, e, t) => {
    const i = b._createFromPositionAndShift(e.sourcePosition, e.howMany);
    if (s.graveyardPosition) {
        const o = i.start.isEqual(s.graveyardPosition) || i.containsPosition(s.graveyardPosition);
        if (!t.bWasUndone && o) {
            const r = s.splitPosition._getTransformedByMoveOperation(e),
                a = s.graveyardPosition._getTransformedByMoveOperation(e), l = a.path.slice();
            l.push(0);
            const c = new y(a.root, l);
            return [new z(r, s.howMany, c, 0)]
        }
        s.graveyardPosition = s.graveyardPosition._getTransformedByMoveOperation(e)
    }
    const n = s.splitPosition.isEqual(e.targetPosition);
    if (n && (t.baRelation == "insertAtSource" || t.abRelation == "splitBefore")) return s.howMany += e.howMany, s.splitPosition = s.splitPosition._getTransformedByDeletion(e.sourcePosition, e.howMany), s.insertionPosition = q.getInsertionPosition(s.splitPosition), [s];
    if (n && t.abRelation && t.abRelation.howMany) {
        const {howMany: o, offset: r} = t.abRelation;
        return s.howMany += o, s.splitPosition = s.splitPosition.getShiftedBy(r), [s]
    }
    if (s.splitPosition.hasSameParentAs(e.sourcePosition) && i.containsPosition(s.splitPosition)) {
        const o = e.howMany - (s.splitPosition.offset - e.sourcePosition.offset);
        return s.howMany -= o, s.splitPosition.hasSameParentAs(e.targetPosition) && s.splitPosition.offset < e.targetPosition.offset && (s.howMany += e.howMany), s.splitPosition = e.sourcePosition.clone(), s.insertionPosition = q.getInsertionPosition(s.splitPosition), [s]
    }
    return e.sourcePosition.isEqual(e.targetPosition) || (s.splitPosition.hasSameParentAs(e.sourcePosition) && s.splitPosition.offset <= e.sourcePosition.offset && (s.howMany -= e.howMany), s.splitPosition.hasSameParentAs(e.targetPosition) && s.splitPosition.offset < e.targetPosition.offset && (s.howMany += e.howMany)), s.splitPosition.stickiness = "toNone", s.splitPosition = s.splitPosition._getTransformedByMoveOperation(e), s.splitPosition.stickiness = "toNext", s.graveyardPosition ? s.insertionPosition = s.insertionPosition._getTransformedByMoveOperation(e) : s.insertionPosition = q.getInsertionPosition(s.splitPosition), [s]
});
D(q, q, (s, e, t) => {
    if (s.splitPosition.isEqual(e.splitPosition)) {
        if (!s.graveyardPosition && !e.graveyardPosition) return [new de(0)];
        if (s.graveyardPosition && e.graveyardPosition && s.graveyardPosition.isEqual(e.graveyardPosition)) return [new de(0)];
        if (t.abRelation == "splitBefore") return s.howMany = 0, s.graveyardPosition = s.graveyardPosition._getTransformedBySplitOperation(e), [s]
    }
    if (s.graveyardPosition && e.graveyardPosition && s.graveyardPosition.isEqual(e.graveyardPosition)) {
        const i = s.splitPosition.root.rootName == "$graveyard", n = e.splitPosition.root.rootName == "$graveyard";
        if (n && !i || !(i && !n) && t.aIsStrong) {
            const l = [];
            return e.howMany && l.push(new z(e.moveTargetPosition, e.howMany, e.splitPosition, 0)), s.howMany && l.push(new z(s.splitPosition, s.howMany, s.moveTargetPosition, 0)), l
        } else return [new de(0)]
    }
    if (s.graveyardPosition && (s.graveyardPosition = s.graveyardPosition._getTransformedBySplitOperation(e)), s.splitPosition.isEqual(e.insertionPosition) && t.abRelation == "splitBefore") return s.howMany++, [s];
    if (e.splitPosition.isEqual(s.insertionPosition) && t.baRelation == "splitBefore") {
        const i = e.insertionPosition.path.slice();
        i.push(0);
        const n = new y(e.insertionPosition.root, i), o = new z(s.insertionPosition, 1, n, 0);
        return [s, o]
    }
    return s.splitPosition.hasSameParentAs(e.splitPosition) && s.splitPosition.offset < e.splitPosition.offset && (s.howMany -= e.howMany), s.splitPosition = s.splitPosition._getTransformedBySplitOperation(e), s.insertionPosition = q.getInsertionPosition(s.splitPosition), [s]
});

function Ml(s, e) {
    return s.targetPosition._getTransformedByDeletion(e.sourcePosition, e.howMany) === null
}

function Mi(s, e) {
    const t = [];
    for (let i = 0; i < s.length; i++) {
        const n = s[i], o = new z(n.start, n.end.offset - n.start.offset, e, 0);
        t.push(o);
        for (let r = i + 1; r < s.length; r++) s[r] = s[r]._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany)[0];
        e = e._getTransformedByMove(o.sourcePosition, o.targetPosition, o.howMany)
    }
    return t
}

class Y extends W(y) {
    constructor(e, t, i = "toNone") {
        if (super(e, t, i), !this.root.is("rootElement")) throw new p("model-liveposition-root-not-rootelement", e);
        l0.call(this)
    }

    detach() {
        this.stopListening()
    }

    toPosition() {
        return new y(this.root, this.path.slice(), this.stickiness)
    }

    static fromPosition(e, t) {
        return new this(e.root, e.path.slice(), t || e.stickiness)
    }
}

Y.prototype.is = function (s) {
    return s === "livePosition" || s === "model:livePosition" || s == "position" || s === "model:position"
};

function l0() {
    this.listenTo(this.root.document.model, "applyOperation", (s, e) => {
        const t = e[0];
        t.isDocumentOperation && c0.call(this, t)
    }, {priority: "low"})
}

function c0(s) {
    const e = this.getTransformedByOperation(s);
    if (!this.isEqual(e)) {
        const t = this.toPosition();
        this.path = e.path, this.root = e.root, this.fire("change", t)
    }
}

class pi {
    operations;
    isUndoable;
    isLocal;
    isUndo;
    isTyping;

    constructor(e = {}) {
        typeof e == "string" && (e = e === "transparent" ? {isUndoable: !1} : {}, L("batch-constructor-deprecated-string-type"));
        const {isUndoable: t = !0, isLocal: i = !0, isUndo: n = !1, isTyping: o = !1} = e;
        this.operations = [], this.isUndoable = t, this.isLocal = i, this.isUndo = n, this.isTyping = o
    }

    get type() {
        return L("batch-type-deprecated"), "default"
    }

    get baseVersion() {
        for (const e of this.operations) if (e.baseVersion !== null) return e.baseVersion;
        return null
    }

    addOperation(e) {
        return e.isDocumentOperation && (e.batch = this, this.operations.push(e)), e
    }
}

class Ds {
    static _statesPriority = [void 0, "refresh", "rename", "move"];
    _markerCollection;
    _changesInElement = new Map;
    _elementsSnapshots = new Map;
    _elementChildrenSnapshots = new Map;
    _elementState = new Map;
    _changedMarkers = new Map;
    _changedRoots = new Map;
    _changeCount = 0;
    _cachedChanges = null;
    _cachedChangesWithGraveyard = null;
    _refreshedItems = new Set;

    constructor(e) {
        this._markerCollection = e
    }

    get isEmpty() {
        return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0
    }

    bufferOperation(e) {
        const t = e;
        switch (t.type) {
            case"insert": {
                if (this._isInInsertedElement(t.position.parent)) return;
                this._markInsert(t.position.parent, t.position.offset, t.nodes.maxOffset);
                break
            }
            case"addAttribute":
            case"removeAttribute":
            case"changeAttribute": {
                for (const i of t.range.getItems({shallow: !0})) this._isInInsertedElement(i.parent) || this._markAttribute(i);
                break
            }
            case"remove":
            case"move":
            case"reinsert": {
                if (t.sourcePosition.isEqual(t.targetPosition) || t.sourcePosition.getShiftedBy(t.howMany).isEqual(t.targetPosition)) return;
                const i = this._isInInsertedElement(t.sourcePosition.parent),
                    n = this._isInInsertedElement(t.targetPosition.parent);
                i || this._markRemove(t.sourcePosition.parent, t.sourcePosition.offset, t.howMany), n || this._markInsert(t.targetPosition.parent, t.getMovedRangeStart().offset, t.howMany);
                const o = b._createFromPositionAndShift(t.sourcePosition, t.howMany);
                for (const r of o.getItems({shallow: !0})) this._setElementState(r, "move");
                break
            }
            case"rename": {
                if (this._isInInsertedElement(t.position.parent)) return;
                this._markRemove(t.position.parent, t.position.offset, 1), this._markInsert(t.position.parent, t.position.offset, 1);
                const i = b._createFromPositionAndShift(t.position, 1);
                for (const n of this._markerCollection.getMarkersIntersectingRange(i)) {
                    const o = n.getData();
                    this.bufferMarkerChange(n.name, o, o)
                }
                this._setElementState(t.position.nodeAfter, "rename");
                break
            }
            case"split": {
                const i = t.splitPosition.parent;
                if (!this._isInInsertedElement(i)) {
                    this._markRemove(i, t.splitPosition.offset, t.howMany);
                    const n = b._createFromPositionAndShift(t.splitPosition, t.howMany);
                    for (const o of n.getItems({shallow: !0})) this._setElementState(o, "move")
                }
                this._isInInsertedElement(t.insertionPosition.parent) || this._markInsert(t.insertionPosition.parent, t.insertionPosition.offset, 1), t.graveyardPosition && (this._markRemove(t.graveyardPosition.parent, t.graveyardPosition.offset, 1), this._setElementState(t.graveyardPosition.nodeAfter, "move"));
                break
            }
            case"merge": {
                const i = t.sourcePosition.parent;
                this._isInInsertedElement(i.parent) || this._markRemove(i.parent, i.startOffset, 1);
                const n = t.graveyardPosition.parent;
                this._markInsert(n, t.graveyardPosition.offset, 1), this._setElementState(i, "move");
                const o = t.targetPosition.parent;
                if (!this._isInInsertedElement(o)) {
                    this._markInsert(o, t.targetPosition.offset, i.maxOffset);
                    const r = b._createFromPositionAndShift(t.sourcePosition, t.howMany);
                    for (const a of r.getItems({shallow: !0})) this._setElementState(a, "move")
                }
                break
            }
            case"detachRoot":
            case"addRoot": {
                const i = t.affectedSelectable;
                if (!i._isLoaded || i.isAttached() == t.isAdd) return;
                this._bufferRootStateChange(t.rootName, t.isAdd);
                break
            }
            case"addRootAttribute":
            case"removeRootAttribute":
            case"changeRootAttribute": {
                if (!t.root._isLoaded) return;
                const i = t.root.rootName;
                this._bufferRootAttributeChange(i, t.key, t.oldValue, t.newValue);
                break
            }
        }
        this._cachedChanges = null
    }

    bufferMarkerChange(e, t, i) {
        t.range && t.range.root.is("rootElement") && !t.range.root._isLoaded && (t.range = null), i.range && i.range.root.is("rootElement") && !i.range.root._isLoaded && (i.range = null);
        let n = this._changedMarkers.get(e);
        n ? n.newMarkerData = i : (n = {
            newMarkerData: i,
            oldMarkerData: t
        }, this._changedMarkers.set(e, n)), n.oldMarkerData.range == null && i.range == null && this._changedMarkers.delete(e)
    }

    getMarkersToRemove() {
        const e = [];
        for (const [t, i] of this._changedMarkers) i.oldMarkerData.range != null && e.push({
            name: t,
            range: i.oldMarkerData.range
        });
        return e
    }

    getMarkersToAdd() {
        const e = [];
        for (const [t, i] of this._changedMarkers) i.newMarkerData.range != null && e.push({
            name: t,
            range: i.newMarkerData.range
        });
        return e
    }

    getChangedMarkers() {
        return Array.from(this._changedMarkers).map(([e, t]) => ({
            name: e,
            data: {oldRange: t.oldMarkerData.range, newRange: t.newMarkerData.range}
        }))
    }

    hasDataChanges() {
        if (this.getChanges().length || this._changedRoots.size > 0) return !0;
        for (const {newMarkerData: e, oldMarkerData: t} of this._changedMarkers.values()) {
            if (e.affectsData !== t.affectsData) return !0;
            if (e.affectsData) {
                const i = e.range && !t.range, n = !e.range && t.range,
                    o = e.range && t.range && !e.range.isEqual(t.range);
                if (i || n || o) return !0
            }
        }
        return !1
    }

    getChanges(e = {}) {
        if (this._cachedChanges) return e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
        let t = [];
        for (const i of this._changesInElement.keys()) {
            const n = this._changesInElement.get(i).sort((u, d) => u.offset === d.offset ? u.type != d.type ? u.type == "remove" ? -1 : 1 : 0 : u.offset < d.offset ? -1 : 1),
                o = this._elementChildrenSnapshots.get(i), r = Fl(i.getChildren()), a = u0(o.length, n);
            let l = 0, c = 0;
            for (const u of a) if (u === "i") {
                const d = this._getDiffActionForNode(r[l].node, "insert"), h = this._elementsSnapshots.get(r[l].node),
                    f = this._getInsertDiff(i, l, d, r[l], h);
                t.push(f), l++
            } else if (u === "r") {
                const d = this._getDiffActionForNode(o[c].node, "remove"), h = this._getRemoveDiff(i, l, d, o[c]);
                t.push(h), c++
            } else if (u === "a") {
                const d = o[c].attributes, h = r[l].attributes;
                let f;
                if (r[l].name == "$text") f = new b(y._createAt(i, l), y._createAt(i, l + 1)); else {
                    const g = i.offsetToIndex(l);
                    f = new b(y._createAt(i, l), y._createAt(i.getChild(g), 0))
                }
                const m = this._getAttributesDiff(f, d, h);
                t.push(...m), l++, c++
            } else l++, c++
        }
        t.sort((i, n) => i.position.root != n.position.root ? i.position.root.rootName < n.position.root.rootName ? -1 : 1 : i.position.isEqual(n.position) ? i.changeCount - n.changeCount : i.position.isBefore(n.position) ? -1 : 1);
        for (let i = 1, n = 0; i < t.length; i++) {
            const o = t[n], r = t[i],
                a = o.type == "remove" && r.type == "remove" && o.name == "$text" && r.name == "$text" && o.position.isEqual(r.position),
                l = o.type == "insert" && r.type == "insert" && o.name == "$text" && r.name == "$text" && o.position.parent == r.position.parent && o.position.offset + o.length == r.position.offset,
                c = o.type == "attribute" && r.type == "attribute" && o.position.parent == r.position.parent && o.range.isFlat && r.range.isFlat && o.position.offset + o.length == r.position.offset && o.attributeKey == r.attributeKey && o.attributeOldValue == r.attributeOldValue && o.attributeNewValue == r.attributeNewValue;
            a || l || c ? (o.length++, c && (o.range.end = o.range.end.getShiftedBy(1)), t[i] = null) : n = i
        }
        t = t.filter(i => i);
        for (const i of t) delete i.changeCount, i.type == "attribute" && (delete i.position, delete i.length);
        return this._changeCount = 0, this._cachedChangesWithGraveyard = t, this._cachedChanges = t.filter(d0), e.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice()
    }

    getChangedRoots() {
        return Array.from(this._changedRoots.values()).map(e => {
            const t = {...e};
            return t.state !== void 0 && delete t.attributes, t
        })
    }

    getRefreshedItems() {
        return new Set(this._refreshedItems)
    }

    reset() {
        this._changesInElement.clear(), this._elementChildrenSnapshots.clear(), this._elementsSnapshots.clear(), this._elementState.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems.clear(), this._cachedChanges = null
    }

    _refreshItem(e) {
        if (this._isInInsertedElement(e.parent)) return;
        this._markRemove(e.parent, e.startOffset, e.offsetSize), this._markInsert(e.parent, e.startOffset, e.offsetSize), this._refreshedItems.add(e), this._setElementState(e, "refresh");
        const t = b._createOn(e);
        for (const i of this._markerCollection.getMarkersIntersectingRange(t)) {
            const n = i.getData();
            this.bufferMarkerChange(i.name, n, n)
        }
        this._cachedChanges = null
    }

    _bufferRootLoad(e) {
        if (e.isAttached()) {
            this._bufferRootStateChange(e.rootName, !0), this._markInsert(e, 0, e.maxOffset);
            for (const t of e.getAttributeKeys()) this._bufferRootAttributeChange(e.rootName, t, null, e.getAttribute(t));
            for (const t of this._markerCollection) if (t.getRange().root == e) {
                const i = t.getData();
                this.bufferMarkerChange(t.name, {...i, range: null}, i)
            }
        }
    }

    _bufferRootStateChange(e, t) {
        if (!this._changedRoots.has(e)) {
            this._changedRoots.set(e, {name: e, state: t ? "attached" : "detached"});
            return
        }
        const i = this._changedRoots.get(e);
        i.state !== void 0 ? (delete i.state, i.attributes === void 0 && this._changedRoots.delete(e)) : i.state = t ? "attached" : "detached"
    }

    _bufferRootAttributeChange(e, t, i, n) {
        const o = this._changedRoots.get(e) || {name: e}, r = o.attributes || {};
        if (r[t]) {
            const a = r[t];
            n === a.oldValue ? delete r[t] : a.newValue = n
        } else r[t] = {oldValue: i, newValue: n};
        Object.entries(r).length === 0 ? (delete o.attributes, o.state === void 0 && this._changedRoots.delete(e)) : (o.attributes = r, this._changedRoots.set(e, o))
    }

    _markInsert(e, t, i) {
        if (e.root.is("rootElement") && !e.root._isLoaded) return;
        const n = {type: "insert", offset: t, howMany: i, count: this._changeCount++};
        this._markChange(e, n)
    }

    _markRemove(e, t, i) {
        if (e.root.is("rootElement") && !e.root._isLoaded) return;
        const n = {type: "remove", offset: t, howMany: i, count: this._changeCount++};
        this._markChange(e, n), this._removeAllNestedChanges(e, t, i)
    }

    _markAttribute(e) {
        if (e.root.is("rootElement") && !e.root._isLoaded) return;
        const t = {type: "attribute", offset: e.startOffset, howMany: e.offsetSize, count: this._changeCount++};
        this._markChange(e.parent, t)
    }

    _markChange(e, t) {
        this._makeSnapshots(e);
        const i = this._getChangesForElement(e);
        this._handleChange(t, i), i.push(t);
        for (let n = 0; n < i.length; n++) i[n].howMany < 1 && (i.splice(n, 1), n--)
    }

    _setElementState(e, t) {
        if (!e.is("element")) return;
        const i = Ds._statesPriority.indexOf(this._elementState.get(e));
        Ds._statesPriority.indexOf(t) > i && this._elementState.set(e, t)
    }

    _getDiffActionForNode(e, t) {
        if (!e.is("element") || !this._elementsSnapshots.has(e)) return t;
        const i = this._elementState.get(e);
        return !i || i == "move" ? t : i
    }

    _getChangesForElement(e) {
        let t;
        return this._changesInElement.has(e) ? t = this._changesInElement.get(e) : (t = [], this._changesInElement.set(e, t)), t
    }

    _makeSnapshots(e) {
        if (this._elementChildrenSnapshots.has(e)) return;
        const t = Fl(e.getChildren());
        this._elementChildrenSnapshots.set(e, t);
        for (const i of t) this._elementsSnapshots.set(i.node, i)
    }

    _handleChange(e, t) {
        e.nodesToHandle = e.howMany;
        for (const i of t) {
            const n = e.offset + e.howMany, o = i.offset + i.howMany;
            if (e.type == "insert" && (i.type == "insert" && (e.offset <= i.offset ? i.offset += e.howMany : e.offset < o && (i.howMany += e.nodesToHandle, e.nodesToHandle = 0)), i.type == "remove" && e.offset < i.offset && (i.offset += e.howMany), i.type == "attribute")) {
                if (e.offset <= i.offset) i.offset += e.howMany; else if (e.offset < o) {
                    const r = i.howMany;
                    i.howMany = e.offset - i.offset, t.unshift({
                        type: "attribute",
                        offset: n,
                        howMany: r - i.howMany,
                        count: this._changeCount++
                    })
                }
            }
            if (e.type == "remove") {
                if (i.type == "insert") {
                    if (n <= i.offset) i.offset -= e.howMany; else if (n <= o) if (e.offset < i.offset) {
                        const r = n - i.offset;
                        i.offset = e.offset, i.howMany -= r, e.nodesToHandle -= r
                    } else i.howMany -= e.nodesToHandle, e.nodesToHandle = 0; else if (e.offset <= i.offset) e.nodesToHandle -= i.howMany, i.howMany = 0; else if (e.offset < o) {
                        const r = o - e.offset;
                        i.howMany -= r, e.nodesToHandle -= r
                    }
                }
                if (i.type == "remove" && (n <= i.offset ? i.offset -= e.howMany : e.offset < i.offset && (e.nodesToHandle += i.howMany, i.howMany = 0)), i.type == "attribute") {
                    if (n <= i.offset) i.offset -= e.howMany; else if (e.offset < i.offset) {
                        const r = n - i.offset;
                        i.offset = e.offset, i.howMany -= r
                    } else if (e.offset < o) if (n <= o) {
                        const r = i.howMany;
                        i.howMany = e.offset - i.offset;
                        const a = r - i.howMany - e.nodesToHandle;
                        t.unshift({type: "attribute", offset: e.offset, howMany: a, count: this._changeCount++})
                    } else i.howMany -= o - e.offset
                }
            }
            if (e.type == "attribute") {
                if (i.type == "insert") if (e.offset < i.offset && n > i.offset) {
                    if (n > o) {
                        const r = {type: "attribute", offset: o, howMany: n - o, count: this._changeCount++};
                        this._handleChange(r, t), t.push(r)
                    }
                    e.nodesToHandle = i.offset - e.offset, e.howMany = e.nodesToHandle
                } else e.offset >= i.offset && e.offset < o && (n > o ? (e.nodesToHandle = n - o, e.offset = o) : e.nodesToHandle = 0);
                if (i.type == "remove" && e.offset < i.offset && n > i.offset) {
                    const r = {type: "attribute", offset: i.offset, howMany: n - i.offset, count: this._changeCount++};
                    this._handleChange(r, t), t.push(r), e.nodesToHandle = i.offset - e.offset, e.howMany = e.nodesToHandle
                }
                i.type == "attribute" && (e.offset >= i.offset && n <= o ? (e.nodesToHandle = 0, e.howMany = 0, e.offset = 0) : e.offset <= i.offset && n >= o && (i.howMany = 0))
            }
        }
        e.howMany = e.nodesToHandle, delete e.nodesToHandle
    }

    _getInsertDiff(e, t, i, n, o) {
        const r = {
            type: "insert",
            position: y._createAt(e, t),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++,
            action: i
        };
        return i != "insert" && o && (r.before = {name: o.name, attributes: new Map(o.attributes)}), r
    }

    _getRemoveDiff(e, t, i, n) {
        return {
            type: "remove",
            action: i,
            position: y._createAt(e, t),
            name: n.name,
            attributes: new Map(n.attributes),
            length: 1,
            changeCount: this._changeCount++
        }
    }

    _getAttributesDiff(e, t, i) {
        const n = [];
        i = new Map(i);
        for (const [o, r] of t) {
            const a = i.has(o) ? i.get(o) : null;
            a !== r && n.push({
                type: "attribute",
                position: e.start,
                range: e.clone(),
                length: 1,
                attributeKey: o,
                attributeOldValue: r,
                attributeNewValue: a,
                changeCount: this._changeCount++
            }), i.delete(o)
        }
        for (const [o, r] of i) n.push({
            type: "attribute",
            position: e.start,
            range: e.clone(),
            length: 1,
            attributeKey: o,
            attributeOldValue: null,
            attributeNewValue: r,
            changeCount: this._changeCount++
        });
        return n
    }

    _isInInsertedElement(e) {
        const t = e.parent;
        if (!t) return !1;
        const i = this._changesInElement.get(t), n = e.startOffset;
        if (i) {
            for (const o of i) if (o.type == "insert" && n >= o.offset && n < o.offset + o.howMany) return !0
        }
        return this._isInInsertedElement(t)
    }

    _removeAllNestedChanges(e, t, i) {
        const n = new b(y._createAt(e, t), y._createAt(e, t + i));
        for (const o of n.getItems({shallow: !0})) o.is("element") && (this._changesInElement.delete(o), this._removeAllNestedChanges(o, 0, o.maxOffset))
    }
}

function Bl(s) {
    return {node: s, name: s.is("$text") ? "$text" : s.name, attributes: new Map(s.getAttributes())}
}

function Fl(s) {
    const e = [];
    for (const t of s) if (t.is("$text")) for (let i = 0; i < t.data.length; ++i) e.push(Bl(t)); else e.push(Bl(t));
    return e
}

function u0(s, e) {
    const t = [];
    let i = 0, n = 0;
    for (const o of e) {
        if (o.offset > i) {
            for (let r = 0; r < o.offset - i; r++) t.push("e");
            n += o.offset - i
        }
        if (o.type == "insert") {
            for (let r = 0; r < o.howMany; r++) t.push("i");
            i = o.offset + o.howMany
        } else if (o.type == "remove") {
            for (let r = 0; r < o.howMany; r++) t.push("r");
            i = o.offset, n += o.howMany
        } else {
            if (o.howMany > 1500) for (let r = 0; r < o.howMany; r++) t.push("a"); else t.push(..."a".repeat(o.howMany).split(""));
            i = o.offset + o.howMany, n += o.howMany
        }
    }
    if (n < s) for (let o = 0; o < s - n - i; o++) t.push("e");
    return t
}

function d0(s) {
    const e = "position" in s && s.position.root.rootName == "$graveyard",
        t = "range" in s && s.range.root.rootName == "$graveyard";
    return !e && !t
}

class h0 {
    _operations = [];
    _undoPairs = new Map;
    _undoneOperations = new Set;
    _baseVersionToOperationIndex = new Map;
    _version = 0;
    _gaps = new Map;

    get version() {
        return this._version
    }

    set version(e) {
        this._operations.length && e > this._version + 1 && this._gaps.set(this._version, e), this._version = e
    }

    get lastOperation() {
        return this._operations[this._operations.length - 1]
    }

    addOperation(e) {
        if (e.baseVersion !== this.version) throw new p("model-document-history-addoperation-incorrect-version", this, {
            operation: e,
            historyVersion: this.version
        });
        this._operations.push(e), this._version++, this._baseVersionToOperationIndex.set(e.baseVersion, this._operations.length - 1)
    }

    getOperations(e, t = this.version) {
        if (!this._operations.length) return [];
        const i = this._operations[0];
        e === void 0 && (e = i.baseVersion);
        let n = t - 1;
        for (const [a, l] of this._gaps) e > a && e < l && (e = l), n > a && n < l && (n = a - 1);
        if (n < i.baseVersion || e > this.lastOperation.baseVersion) return [];
        let o = this._baseVersionToOperationIndex.get(e);
        o === void 0 && (o = 0);
        let r = this._baseVersionToOperationIndex.get(n);
        return r === void 0 && (r = this._operations.length - 1), this._operations.slice(o, r + 1)
    }

    getOperation(e) {
        const t = this._baseVersionToOperationIndex.get(e);
        if (t !== void 0) return this._operations[t]
    }

    setOperationAsUndone(e, t) {
        this._undoPairs.set(t, e), this._undoneOperations.add(e)
    }

    isUndoingOperation(e) {
        return this._undoPairs.has(e)
    }

    isUndoneOperation(e) {
        return this._undoneOperations.has(e)
    }

    getUndoneOperation(e) {
        return this._undoPairs.get(e)
    }

    reset() {
        this._version = 0, this._undoPairs = new Map, this._operations = [], this._undoneOperations = new Set, this._gaps = new Map, this._baseVersionToOperationIndex = new Map
    }
}

class Ns extends j {
    rootName;
    _document;
    _isAttached = !0;
    _isLoaded = !0;

    constructor(e, t, i = "main") {
        super(t), this._document = e, this.rootName = i
    }

    get document() {
        return this._document
    }

    isAttached() {
        return this._isAttached
    }

    toJSON() {
        return this.rootName
    }
}

Ns.prototype.is = function (s, e) {
    return e ? e === this.name && (s === "rootElement" || s === "model:rootElement" || s === "element" || s === "model:element") : s === "rootElement" || s === "model:rootElement" || s === "element" || s === "model:element" || s === "node" || s === "model:node"
};
const Ll = "$graveyard";

class f0 extends W() {
    model;
    history;
    selection;
    roots;
    differ;
    isReadOnly;
    _postFixers;
    _hasSelectionChangedFromTheLastChangeBlock;

    constructor(e) {
        super(), this.model = e, this.history = new h0, this.selection = new st(this), this.roots = new ce({idProperty: "rootName"}), this.differ = new Ds(e.markers), this.isReadOnly = !1, this._postFixers = new Set, this._hasSelectionChangedFromTheLastChangeBlock = !1, this.createRoot("$root", Ll), this.listenTo(e, "applyOperation", (t, i) => {
            const n = i[0];
            n.isDocumentOperation && this.differ.bufferOperation(n)
        }, {priority: "high"}), this.listenTo(e, "applyOperation", (t, i) => {
            const n = i[0];
            n.isDocumentOperation && this.history.addOperation(n)
        }, {priority: "low"}), this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = !0
        }), this.listenTo(e.markers, "update", (t, i, n, o, r) => {
            const a = {...i.getData(), range: o};
            this.differ.bufferMarkerChange(i.name, r, a), n === null && i.on("change", (l, c) => {
                const u = i.getData();
                this.differ.bufferMarkerChange(i.name, {...u, range: c}, u)
            })
        }), this.registerPostFixer(t => {
            let i = !1;
            for (const n of this.roots) !n.isAttached() && !n.isEmpty && (t.remove(t.createRangeIn(n)), i = !0);
            for (const n of this.model.markers) n.getRange().root.isAttached() || (t.removeMarker(n), i = !0);
            return i
        })
    }

    get version() {
        return this.history.version
    }

    set version(e) {
        this.history.version = e
    }

    get graveyard() {
        return this.getRoot(Ll)
    }

    createRoot(e = "$root", t = "main") {
        if (this.roots.get(t)) throw new p("model-document-createroot-name-exists", this, {name: t});
        const i = new Ns(this, e, t);
        return this.roots.add(i), i
    }

    destroy() {
        this.selection.destroy(), this.stopListening()
    }

    getRoot(e = "main") {
        return this.roots.get(e)
    }

    getRootNames(e = !1) {
        return this.getRoots(e).map(t => t.rootName)
    }

    getRoots(e = !1) {
        return this.roots.filter(t => t != this.graveyard && (e || t.isAttached()) && t._isLoaded)
    }

    registerPostFixer(e) {
        this._postFixers.add(e)
    }

    toJSON() {
        const e = $r(this);
        return e.selection = "[engine.model.DocumentSelection]", e.model = "[engine.model.Model]", e
    }

    _handleChangeBlock(e) {
        this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(e), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", e.batch) : this.fire("change", e.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = !1
    }

    _hasDocumentChangedFromTheLastChangeBlock() {
        return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock
    }

    _getDefaultRoot() {
        const e = this.getRoots();
        return e.length ? e[0] : this.graveyard
    }

    _getDefaultRange() {
        const e = this._getDefaultRoot(), t = this.model, i = t.schema, n = t.createPositionFromPath(e, [0]);
        return i.getNearestSelectionRange(n) || t.createRange(n)
    }

    _validateSelectionRange(e) {
        return e.start.isValid() && e.end.isValid() && Dl(e.start) && Dl(e.end)
    }

    _callPostFixers(e) {
        let t = !1;
        do for (const i of this._postFixers) if (this.selection.refresh(), t = i(e), t) break; while (t)
    }
}

function Dl(s) {
    const e = s.textNode;
    if (e) {
        const t = e.data, i = s.offset - e.startOffset;
        return !ta(t, i) && !ia(t, i)
    }
    return !0
}

class m0 extends W() {
    _markers = new Map;

    [Symbol.iterator]() {
        return this._markers.values()
    }

    has(e) {
        const t = e instanceof xi ? e.name : e;
        return this._markers.has(t)
    }

    get(e) {
        return this._markers.get(e) || null
    }

    _set(e, t, i = !1, n = !1) {
        const o = e instanceof xi ? e.name : e;
        if (o.includes(",")) throw new p("markercollection-incorrect-marker-name", this);
        const r = this._markers.get(o);
        if (r) {
            const c = r.getData(), u = r.getRange();
            let d = !1;
            return u.isEqual(t) || (r._attachLiveRange(Ce.fromRange(t)), d = !0), i != r.managedUsingOperations && (r._managedUsingOperations = i, d = !0), typeof n == "boolean" && n != r.affectsData && (r._affectsData = n, d = !0), d && this.fire(`update:${o}`, r, u, t, c), r
        }
        const a = Ce.fromRange(t), l = new xi(o, a, i, n);
        return this._markers.set(o, l), this.fire(`update:${o}`, l, null, t, {...l.getData(), range: null}), l
    }

    _remove(e) {
        const t = e instanceof xi ? e.name : e, i = this._markers.get(t);
        return i ? (this._markers.delete(t), this.fire(`update:${t}`, i, i.getRange(), null, i.getData()), this._destroyMarker(i), !0) : !1
    }

    _refresh(e) {
        const t = e instanceof xi ? e.name : e, i = this._markers.get(t);
        if (!i) throw new p("markercollection-refresh-marker-not-exists", this);
        const n = i.getRange();
        this.fire(`update:${t}`, i, n, n, i.getData())
    }

    * getMarkersAtPosition(e) {
        for (const t of this) t.getRange().containsPosition(e) && (yield t)
    }

    * getMarkersIntersectingRange(e) {
        for (const t of this) t.getRange().getIntersection(e) !== null && (yield t)
    }

    destroy() {
        for (const e of this._markers.values()) this._destroyMarker(e);
        this._markers = null, this.stopListening()
    }

    * getMarkersGroup(e) {
        for (const t of this._markers.values()) t.name.startsWith(e + ":") && (yield t)
    }

    _destroyMarker(e) {
        e.stopListening(), e._detachLiveRange()
    }
}

class xi extends W(qt) {
    name;
    _managedUsingOperations;
    _affectsData;
    _liveRange;

    constructor(e, t, i, n) {
        super(), this.name = e, this._liveRange = this._attachLiveRange(t), this._managedUsingOperations = i, this._affectsData = n
    }

    get managedUsingOperations() {
        if (!this._liveRange) throw new p("marker-destroyed", this);
        return this._managedUsingOperations
    }

    get affectsData() {
        if (!this._liveRange) throw new p("marker-destroyed", this);
        return this._affectsData
    }

    getData() {
        return {
            range: this.getRange(),
            affectsData: this.affectsData,
            managedUsingOperations: this.managedUsingOperations
        }
    }

    getStart() {
        if (!this._liveRange) throw new p("marker-destroyed", this);
        return this._liveRange.start.clone()
    }

    getEnd() {
        if (!this._liveRange) throw new p("marker-destroyed", this);
        return this._liveRange.end.clone()
    }

    getRange() {
        if (!this._liveRange) throw new p("marker-destroyed", this);
        return this._liveRange.toRange()
    }

    _attachLiveRange(e) {
        return this._liveRange && this._detachLiveRange(), e.delegate("change:range").to(this), e.delegate("change:content").to(this), this._liveRange = e, e
    }

    _detachLiveRange() {
        this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null
    }
}

xi.prototype.is = function (s) {
    return s === "marker" || s === "model:marker"
};

class g0 extends Ue {
    sourcePosition;
    howMany;

    constructor(e, t) {
        super(null), this.sourcePosition = e.clone(), this.howMany = t
    }

    get type() {
        return "detach"
    }

    get affectedSelectable() {
        return null
    }

    toJSON() {
        const e = super.toJSON();
        return e.sourcePosition = this.sourcePosition.toJSON(), e
    }

    _validate() {
        if (this.sourcePosition.root.document) throw new p("detach-operation-on-document-node", this)
    }

    _execute() {
        Jh(b._createFromPositionAndShift(this.sourcePosition, this.howMany))
    }

    static get className() {
        return "DetachOperation"
    }
}

class lt extends qt {
    markers = new Map;
    _children = new kn;

    constructor(e) {
        super(), e && this._insertChild(0, e)
    }

    [Symbol.iterator]() {
        return this.getChildren()
    }

    get childCount() {
        return this._children.length
    }

    get maxOffset() {
        return this._children.maxOffset
    }

    get isEmpty() {
        return this.childCount === 0
    }

    get nextSibling() {
        return null
    }

    get previousSibling() {
        return null
    }

    get root() {
        return this
    }

    get parent() {
        return null
    }

    get document() {
        return null
    }

    isAttached() {
        return !1
    }

    getAncestors() {
        return []
    }

    getChild(e) {
        return this._children.getNode(e)
    }

    getChildAtOffset(e) {
        return this._children.getNodeAtOffset(e)
    }

    getChildren() {
        return this._children[Symbol.iterator]()
    }

    getChildIndex(e) {
        return this._children.getNodeIndex(e)
    }

    getChildStartOffset(e) {
        return this._children.getNodeStartOffset(e)
    }

    getPath() {
        return []
    }

    getNodeByPath(e) {
        let t = this;
        for (const i of e) t = t.getChildAtOffset(i);
        return t
    }

    offsetToIndex(e) {
        return this._children.offsetToIndex(e)
    }

    toJSON() {
        const e = [];
        for (const t of this._children) e.push(t.toJSON());
        return e
    }

    static fromJSON(e) {
        const t = [];
        for (const i of e) i.name ? t.push(j.fromJSON(i)) : t.push(G.fromJSON(i));
        return new lt(t)
    }

    _appendChild(e) {
        this._insertChild(this.childCount, e)
    }

    _insertChild(e, t) {
        const i = p0(t);
        for (const n of i) n.parent !== null && n._remove(), n.parent = this;
        this._children._insertNodes(e, i)
    }

    _removeChildren(e, t = 1) {
        const i = this._children._removeNodes(e, t);
        for (const n of i) n.parent = null;
        return i
    }

    _removeChildrenArray(e) {
        this._children._removeNodesArray(e);
        for (const t of e) t.parent = null
    }
}

lt.prototype.is = function (s) {
    return s === "documentFragment" || s === "model:documentFragment"
};

function p0(s) {
    return typeof s == "string" ? [new G(s)] : (ze(s) || (s = [s]), Array.from(s).map(e => typeof e == "string" ? new G(e) : e instanceof et ? new G(e.data, e.getAttributes()) : e))
}

class w0 {
    model;
    batch;

    constructor(e, t) {
        this.model = e, this.batch = t
    }

    createText(e, t) {
        return new G(e, t)
    }

    createElement(e, t) {
        return new j(e, t)
    }

    createDocumentFragment() {
        return new lt
    }

    cloneElement(e, t = !0) {
        return e._clone(t)
    }

    insert(e, t, i = 0) {
        if (this._assertWriterUsedCorrectly(), e instanceof G && e.data == "") return;
        const n = y._createAt(t, i);
        if (e.parent) if (Hl(e.root, n.root)) {
            this.move(b._createOn(e), n);
            return
        } else {
            if (e.root.document) throw new p("model-writer-insert-forbidden-move", this);
            this.remove(e)
        }
        const o = n.root.document ? n.root.document.version : null,
            r = e instanceof lt ? e._removeChildren(0, e.childCount) : e, a = new he(n, r, o);
        if (e instanceof G && (a.shouldReceiveAttributes = !0), this.batch.addOperation(a), this.model.applyOperation(a), e instanceof lt) for (const [l, c] of e.markers) {
            const u = y._createAt(c.root, 0), h = {
                range: new b(c.start._getCombined(u, n), c.end._getCombined(u, n)),
                usingOperation: !0,
                affectsData: !0
            };
            this.model.markers.has(l) ? this.updateMarker(l, h) : this.addMarker(l, h)
        }
    }

    insertText(e, t, i, n) {
        t instanceof lt || t instanceof j || t instanceof y ? this.insert(this.createText(e), t, i) : this.insert(this.createText(e, t), i, n)
    }

    insertElement(e, t, i, n) {
        t instanceof lt || t instanceof j || t instanceof y ? this.insert(this.createElement(e), t, i) : this.insert(this.createElement(e, t), i, n)
    }

    append(e, t) {
        this.insert(e, t, "end")
    }

    appendText(e, t, i) {
        t instanceof lt || t instanceof j ? this.insert(this.createText(e), t, "end") : this.insert(this.createText(e, t), i, "end")
    }

    appendElement(e, t, i) {
        t instanceof lt || t instanceof j ? this.insert(this.createElement(e), t, "end") : this.insert(this.createElement(e, t), i, "end")
    }

    setAttribute(e, t, i) {
        if (this._assertWriterUsedCorrectly(), i instanceof b) {
            const n = i.getMinimalFlatRanges();
            for (const o of n) Nl(this, e, t, o)
        } else zl(this, e, t, i)
    }

    setAttributes(e, t) {
        for (const [i, n] of nt(e)) this.setAttribute(i, n, t)
    }

    removeAttribute(e, t) {
        if (this._assertWriterUsedCorrectly(), t instanceof b) {
            const i = t.getMinimalFlatRanges();
            for (const n of i) Nl(this, e, null, n)
        } else zl(this, e, null, t)
    }

    clearAttributes(e) {
        this._assertWriterUsedCorrectly();
        const t = i => {
            for (const n of i.getAttributeKeys()) this.removeAttribute(n, i)
        };
        if (!(e instanceof b)) t(e); else for (const i of e.getItems()) t(i)
    }

    move(e, t, i) {
        if (this._assertWriterUsedCorrectly(), !(e instanceof b)) throw new p("writer-move-invalid-range", this);
        if (!e.isFlat) throw new p("writer-move-range-not-flat", this);
        const n = y._createAt(t, i);
        if (n.isEqual(e.start)) return;
        if (this._addOperationForAffectedMarkers("move", e), !Hl(e.root, n.root)) throw new p("writer-move-different-document", this);
        const o = e.root.document ? e.root.document.version : null,
            r = new z(e.start, e.end.offset - e.start.offset, n, o);
        this.batch.addOperation(r), this.model.applyOperation(r)
    }

    remove(e) {
        this._assertWriterUsedCorrectly();
        const i = (e instanceof b ? e : b._createOn(e)).getMinimalFlatRanges().reverse();
        for (const n of i) this._addOperationForAffectedMarkers("move", n), b0(n.start, n.end.offset - n.start.offset, this.batch, this.model)
    }

    merge(e) {
        this._assertWriterUsedCorrectly();
        const t = e.nodeBefore, i = e.nodeAfter;
        if (this._addOperationForAffectedMarkers("merge", e), !(t instanceof j)) throw new p("writer-merge-no-element-before", this);
        if (!(i instanceof j)) throw new p("writer-merge-no-element-after", this);
        e.root.document ? this._merge(e) : this._mergeDetached(e)
    }

    createPositionFromPath(e, t, i) {
        return this.model.createPositionFromPath(e, t, i)
    }

    createPositionAt(e, t) {
        return this.model.createPositionAt(e, t)
    }

    createPositionAfter(e) {
        return this.model.createPositionAfter(e)
    }

    createPositionBefore(e) {
        return this.model.createPositionBefore(e)
    }

    createRange(e, t) {
        return this.model.createRange(e, t)
    }

    createRangeIn(e) {
        return this.model.createRangeIn(e)
    }

    createRangeOn(e) {
        return this.model.createRangeOn(e)
    }

    createSelection(...e) {
        return this.model.createSelection(...e)
    }

    _mergeDetached(e) {
        const t = e.nodeBefore, i = e.nodeAfter;
        this.move(b._createIn(i), y._createAt(t, "end")), this.remove(i)
    }

    _merge(e) {
        const t = y._createAt(e.nodeBefore, "end"), i = y._createAt(e.nodeAfter, 0), n = e.root.document.graveyard,
            o = new y(n, [0]), r = e.root.document.version, a = new ne(i, e.nodeAfter.maxOffset, t, o, r);
        this.batch.addOperation(a), this.model.applyOperation(a)
    }

    rename(e, t) {
        if (this._assertWriterUsedCorrectly(), !(e instanceof j)) throw new p("writer-rename-not-element-instance", this);
        const i = e.root.document ? e.root.document.version : null, n = new Re(y._createBefore(e), e.name, t, i);
        this.batch.addOperation(n), this.model.applyOperation(n)
    }

    split(e, t) {
        this._assertWriterUsedCorrectly();
        let i = e.parent;
        if (!i.parent) throw new p("writer-split-element-no-parent", this);
        if (t || (t = i.parent), !e.parent.getAncestors({includeSelf: !0}).includes(t)) throw new p("writer-split-invalid-limit-element", this);
        let n, o;
        do {
            const r = i.root.document ? i.root.document.version : null, a = i.maxOffset - e.offset,
                l = q.getInsertionPosition(e), c = new q(e, a, l, null, r);
            this.batch.addOperation(c), this.model.applyOperation(c), !n && !o && (n = i, o = e.parent.nextSibling), e = this.createPositionAfter(e.parent), i = e.parent
        } while (i !== t);
        return {position: e, range: new b(y._createAt(n, "end"), y._createAt(o, 0))}
    }

    wrap(e, t) {
        if (this._assertWriterUsedCorrectly(), !e.isFlat) throw new p("writer-wrap-range-not-flat", this);
        const i = t instanceof j ? t : new j(t);
        if (i.childCount > 0) throw new p("writer-wrap-element-not-empty", this);
        if (i.parent !== null) throw new p("writer-wrap-element-attached", this);
        this.insert(i, e.start);
        const n = new b(e.start.getShiftedBy(1), e.end.getShiftedBy(1));
        this.move(n, y._createAt(i, 0))
    }

    unwrap(e) {
        if (this._assertWriterUsedCorrectly(), e.parent === null) throw new p("writer-unwrap-element-no-parent", this);
        this.move(b._createIn(e), this.createPositionAfter(e)), this.remove(e)
    }

    addMarker(e, t) {
        if (this._assertWriterUsedCorrectly(), !t || typeof t.usingOperation != "boolean") throw new p("writer-addmarker-no-usingoperation", this);
        const i = t.usingOperation, n = t.range, o = t.affectsData === void 0 ? !1 : t.affectsData;
        if (this.model.markers.has(e)) throw new p("writer-addmarker-marker-exists", this);
        if (!n) throw new p("writer-addmarker-no-range", this);
        return i ? (rn(this, e, null, n, o), this.model.markers.get(e)) : this.model.markers._set(e, n, i, o)
    }

    updateMarker(e, t) {
        this._assertWriterUsedCorrectly();
        const i = typeof e == "string" ? e : e.name, n = this.model.markers.get(i);
        if (!n) throw new p("writer-updatemarker-marker-not-exists", this);
        if (!t) {
            L("writer-updatemarker-reconvert-using-editingcontroller", {markerName: i}), this.model.markers._refresh(n);
            return
        }
        const o = typeof t.usingOperation == "boolean", r = typeof t.affectsData == "boolean",
            a = r ? t.affectsData : n.affectsData;
        if (!o && !t.range && !r) throw new p("writer-updatemarker-wrong-options", this);
        const l = n.getRange(), c = t.range ? t.range : l;
        if (o && t.usingOperation !== n.managedUsingOperations) {
            t.usingOperation ? rn(this, i, null, c, a) : (rn(this, i, l, null, a), this.model.markers._set(i, c, void 0, a));
            return
        }
        n.managedUsingOperations ? rn(this, i, l, c, a) : this.model.markers._set(i, c, void 0, a)
    }

    removeMarker(e) {
        this._assertWriterUsedCorrectly();
        const t = typeof e == "string" ? e : e.name;
        if (!this.model.markers.has(t)) throw new p("writer-removemarker-no-marker", this);
        const i = this.model.markers.get(t);
        if (!i.managedUsingOperations) {
            this.model.markers._remove(t);
            return
        }
        const n = i.getRange();
        rn(this, t, n, null, i.affectsData)
    }

    addRoot(e, t = "$root") {
        this._assertWriterUsedCorrectly();
        const i = this.model.document.getRoot(e);
        if (i && i.isAttached()) throw new p("writer-addroot-root-exists", this);
        const n = this.model.document, o = new ut(e, t, !0, n, n.version);
        return this.batch.addOperation(o), this.model.applyOperation(o), this.model.document.getRoot(e)
    }

    detachRoot(e) {
        this._assertWriterUsedCorrectly();
        const t = typeof e == "string" ? this.model.document.getRoot(e) : e;
        if (!t || !t.isAttached()) throw new p("writer-detachroot-no-root", this);
        for (const o of this.model.markers) o.getRange().root === t && this.removeMarker(o);
        for (const o of t.getAttributeKeys()) this.removeAttribute(o, t);
        this.remove(this.createRangeIn(t));
        const i = this.model.document, n = new ut(t.rootName, t.name, !1, i, i.version);
        this.batch.addOperation(n), this.model.applyOperation(n)
    }

    setSelection(...e) {
        this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...e)
    }

    setSelectionFocus(e, t) {
        this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(e, t)
    }

    setSelectionAttribute(e, t) {
        if (this._assertWriterUsedCorrectly(), typeof e == "string") this._setSelectionAttribute(e, t); else for (const [i, n] of nt(e)) this._setSelectionAttribute(i, n)
    }

    removeSelectionAttribute(e) {
        if (this._assertWriterUsedCorrectly(), typeof e == "string") this._removeSelectionAttribute(e); else for (const t of e) this._removeSelectionAttribute(t)
    }

    overrideSelectionGravity() {
        return this.model.document.selection._overrideGravity()
    }

    restoreSelectionGravity(e) {
        this.model.document.selection._restoreGravity(e)
    }

    _setSelectionAttribute(e, t) {
        const i = this.model.document.selection;
        if (i.isCollapsed && i.anchor.parent.isEmpty) {
            const n = st._getStoreAttributeKey(e);
            this.setAttribute(n, t, i.anchor.parent)
        }
        i._setAttribute(e, t)
    }

    _removeSelectionAttribute(e) {
        const t = this.model.document.selection;
        if (t.isCollapsed && t.anchor.parent.isEmpty) {
            const i = st._getStoreAttributeKey(e);
            this.removeAttribute(i, t.anchor.parent)
        }
        t._removeAttribute(e)
    }

    _assertWriterUsedCorrectly() {
        if (this.model._currentWriter !== this) throw new p("writer-incorrect-use", this)
    }

    _addOperationForAffectedMarkers(e, t) {
        for (const i of this.model.markers) {
            if (!i.managedUsingOperations) continue;
            const n = i.getRange();
            let o = !1;
            if (e === "move") {
                const r = t;
                o = r.containsPosition(n.start) || r.start.isEqual(n.start) || r.containsPosition(n.end) || r.end.isEqual(n.end)
            } else {
                const r = t, a = r.nodeBefore, l = r.nodeAfter, c = n.start.parent == a && n.start.isAtEnd,
                    u = n.end.parent == l && n.end.offset == 0, d = n.end.nodeAfter == l, h = n.start.nodeAfter == l;
                o = c || u || d || h
            }
            o && this.updateMarker(i.name, {range: n})
        }
    }
}

function Nl(s, e, t, i) {
    const n = s.model, o = n.document;
    let r = i.start, a, l, c;
    for (const d of i.getWalker({shallow: !0})) c = d.item.getAttribute(e), a && l != c && (l != t && u(), r = a), a = d.nextPosition, l = c;
    a instanceof y && a != r && l != t && u();

    function u() {
        const d = new b(r, a), h = d.root.document ? o.version : null, f = new oe(d, e, l, t, h);
        s.batch.addOperation(f), n.applyOperation(f)
    }
}

function zl(s, e, t, i) {
    const n = s.model, o = n.document, r = i.getAttribute(e);
    let a, l;
    if (r != t) {
        if (i.root === i) {
            const u = i.document ? o.version : null;
            l = new Tt(i, e, r, t, u)
        } else {
            a = new b(y._createBefore(i), s.createPositionAfter(i));
            const u = a.root.document ? o.version : null;
            l = new oe(a, e, r, t, u)
        }
        s.batch.addOperation(l), n.applyOperation(l)
    }
}

function rn(s, e, t, i, n) {
    const o = s.model, r = o.document, a = new Ee(e, t, i, o.markers, !!n, r.version);
    s.batch.addOperation(a), o.applyOperation(a)
}

function b0(s, e, t, i) {
    let n;
    if (s.root.document) {
        const o = i.document, r = new y(o.graveyard, [0]);
        n = new z(s, e, r, o.version)
    } else n = new g0(s, e);
    t.addOperation(n), i.applyOperation(n)
}

function Hl(s, e) {
    return s === e || s instanceof Ns && e instanceof Ns
}

function _0(s) {
    s.document.registerPostFixer(e => v0(e, s))
}

function v0(s, e) {
    const t = e.document.selection, i = e.schema, n = [];
    let o = !1;
    for (const r of t.getRanges()) {
        const a = da(r, i);
        a && !a.isEqual(r) ? (n.push(a), o = !0) : n.push(r)
    }
    return o && s.setSelection(E0(n), {backward: t.isBackward}), !1
}

function da(s, e) {
    return s.isCollapsed ? y0(s, e) : k0(s, e)
}

function y0(s, e) {
    const t = s.start, i = e.getNearestSelectionRange(t);
    if (!i) {
        const o = t.getAncestors().reverse().find(r => e.isObject(r));
        return o ? b._createOn(o) : null
    }
    if (!i.isCollapsed) return i;
    const n = i.start;
    return t.isEqual(n) ? null : new b(n)
}

function k0(s, e) {
    const {start: t, end: i} = s, n = e.checkChild(t, "$text"), o = e.checkChild(i, "$text"), r = e.getLimitElement(t),
        a = e.getLimitElement(i);
    if (r === a) {
        if (n && o) return null;
        if (C0(t, i, e)) {
            const d = t.nodeAfter && e.isSelectable(t.nodeAfter) ? null : e.getNearestSelectionRange(t, "forward"),
                f = i.nodeBefore && e.isSelectable(i.nodeBefore) ? null : e.getNearestSelectionRange(i, "backward"),
                m = d ? d.start : t, g = f ? f.end : i;
            return new b(m, g)
        }
    }
    const l = r && !r.is("rootElement"), c = a && !a.is("rootElement");
    if (l || c) {
        const u = t.nodeAfter && i.nodeBefore && t.nodeAfter.parent === i.nodeBefore.parent,
            d = l && (!u || !$l(t.nodeAfter, e)), h = c && (!u || !$l(i.nodeBefore, e));
        let f = t, m = i;
        return d && (f = y._createBefore(Ul(r, e))), h && (m = y._createAfter(Ul(a, e))), new b(f, m)
    }
    return null
}

function Ul(s, e) {
    let t = s, i = t;
    for (; e.isLimit(i) && i.parent;) t = i, i = i.parent;
    return t
}

function C0(s, e, t) {
    const i = s.nodeAfter && !t.isLimit(s.nodeAfter) || t.checkChild(s, "$text"),
        n = e.nodeBefore && !t.isLimit(e.nodeBefore) || t.checkChild(e, "$text");
    return i || n
}

function E0(s) {
    const e = [...s], t = new Set;
    let i = 1;
    for (; i < e.length;) {
        const o = e[i], r = e.slice(0, i);
        for (const [a, l] of r.entries()) if (!t.has(a)) {
            if (o.isEqual(l)) t.add(a); else if (o.isIntersecting(l)) {
                t.add(a), t.add(i);
                const c = o.getJoined(l);
                e.push(c)
            }
        }
        i++
    }
    return e.filter((o, r) => !t.has(r))
}

function $l(s, e) {
    return s && e.isSelectable(s)
}

function T0(s, e, t = {}) {
    if (e.isCollapsed) return;
    const i = e.getFirstRange();
    if (i.root.rootName == "$graveyard") return;
    const n = s.schema;
    s.change(o => {
        if (!t.doNotResetEntireContent && M0(n, e)) {
            O0(o, e);
            return
        }
        const r = {};
        if (!t.doNotAutoparagraph) {
            const c = e.getSelectedElement();
            c && Object.assign(r, n.getAttributesWithProperty(c, "copyOnReplace", !0))
        }
        let a, l;
        t.doNotFixSelection ? (a = Y.fromPosition(i.start, "toPrevious"), l = Y.fromPosition(i.end, "toNext")) : [a, l] = A0(i), a.isTouching(l) || o.remove(o.createRange(a, l)), t.leaveUnmerged || (I0(o, a, l), n.removeDisallowedAttributes(a.parent.getChildren(), o)), sf(o, e, a), !t.doNotAutoparagraph && R0(n, a) && nf(o, a, e, r), a.detach(), l.detach()
    })
}

function A0(s) {
    const e = s.root.document.model, t = s.start;
    let i = s.end;
    if (e.hasContent(s, {ignoreMarkers: !0})) {
        const n = x0(i);
        if (n && i.isTouching(e.createPositionAt(n, 0))) {
            const o = e.createSelection(s);
            e.modifySelection(o, {direction: "backward"});
            const r = o.getLastPosition(), a = e.createRange(r, i);
            e.hasContent(a, {ignoreMarkers: !0}) || (i = r)
        }
    }
    return [Y.fromPosition(t, "toPrevious"), Y.fromPosition(i, "toNext")]
}

function x0(s) {
    const e = s.parent, t = e.root.document.model.schema, i = e.getAncestors({parentFirst: !0, includeSelf: !0});
    for (const n of i) {
        if (t.isLimit(n)) return null;
        if (t.isBlock(n)) return n
    }
}

function I0(s, e, t) {
    const i = s.model;
    if (!ha(s.model.schema, e, t)) return;
    const [n, o] = P0(e, t);
    !n || !o || (!i.hasContent(n, {ignoreMarkers: !0}) && i.hasContent(o, {ignoreMarkers: !0}) ? tf(s, e, t, n.parent) : ef(s, e, t, n.parent))
}

function ef(s, e, t, i) {
    const n = e.parent, o = t.parent;
    if (!(n == i || o == i)) {
        for (e = s.createPositionAfter(n), t = s.createPositionBefore(o), t.isEqual(e) || s.insert(o, e), s.merge(e); t.parent.isEmpty;) {
            const r = t.parent;
            t = s.createPositionBefore(r), s.remove(r)
        }
        ha(s.model.schema, e, t) && ef(s, e, t, i)
    }
}

function tf(s, e, t, i) {
    const n = e.parent, o = t.parent;
    if (!(n == i || o == i)) {
        for (e = s.createPositionAfter(n), t = s.createPositionBefore(o), t.isEqual(e) || s.insert(n, t); e.parent.isEmpty;) {
            const r = e.parent;
            e = s.createPositionBefore(r), s.remove(r)
        }
        t = s.createPositionBefore(o), S0(s, t), ha(s.model.schema, e, t) && tf(s, e, t, i)
    }
}

function S0(s, e) {
    const t = e.nodeBefore, i = e.nodeAfter;
    t.name != i.name && s.rename(t, i.name), s.clearAttributes(t), s.setAttributes(Object.fromEntries(i.getAttributes()), t), s.merge(e)
}

function ha(s, e, t) {
    const i = e.parent, n = t.parent;
    return i == n || s.isLimit(i) || s.isLimit(n) ? !1 : V0(e, t, s)
}

function P0(s, e) {
    const t = s.getAncestors(), i = e.getAncestors();
    let n = 0;
    for (; t[n] && t[n] == i[n];) n++;
    return [t[n], i[n]]
}

function R0(s, e) {
    const t = s.checkChild(e, "$text"), i = s.checkChild(e, "paragraph");
    return !t && i
}

function V0(s, e, t) {
    const i = new b(s, e);
    for (const n of i.getWalker()) if (t.isLimit(n.item)) return !1;
    return !0
}

function nf(s, e, t, i = {}) {
    const n = s.createElement("paragraph");
    s.model.schema.setAllowedAttributes(n, i, s), s.insert(n, e), sf(s, t, s.createPositionAt(n, 0))
}

function O0(s, e) {
    const t = s.model.schema.getLimitElement(e);
    s.remove(s.createRangeIn(t)), nf(s, s.createPositionAt(t, 0), e)
}

function M0(s, e) {
    const t = s.getLimitElement(e);
    if (!e.containsEntireContent(t)) return !1;
    const i = e.getFirstRange();
    return i.start.parent == i.end.parent ? !1 : s.checkChild(t, "paragraph")
}

function sf(s, e, t) {
    e instanceof st ? s.setSelection(t) : e.setTo(t)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function B0(s, e) {
    return s.change(t => {
        const i = t.createDocumentFragment(), n = e.getFirstRange();
        if (!n || n.isCollapsed) return i;
        const o = n.start.root, r = n.start.getCommonPath(n.end), a = o.getNodeByPath(r);
        let l;
        n.start.parent == n.end.parent ? l = n : l = t.createRange(t.createPositionAt(a, n.start.path[r.length]), t.createPositionAt(a, n.end.path[r.length] + 1));
        const c = l.end.offset - l.start.offset;
        for (const u of l.getItems({shallow: !0})) u.is("$textProxy") ? t.appendText(u.data, u.getAttributes(), i) : t.append(t.cloneElement(u, !0), i);
        if (l != n) {
            const u = n._getTransformedByMove(l.start, t.createPositionAt(i, 0), c)[0],
                d = t.createRange(t.createPositionAt(i, 0), u.start),
                h = t.createRange(u.end, t.createPositionAt(i, "end"));
            Wl(h, t), Wl(d, t)
        }
        return i
    })
}

function Wl(s, e) {
    const t = [];
    Array.from(s.getItems({direction: "backward"})).map(i => e.createRangeOn(i)).filter(i => (i.start.isAfter(s.start) || i.start.isEqual(s.start)) && (i.end.isBefore(s.end) || i.end.isEqual(s.end))).forEach(i => {
        t.push(i.start.parent), e.remove(i)
    }), t.forEach(i => {
        let n = i;
        for (; n.parent && n.isEmpty;) {
            const o = e.createRangeOn(n);
            n = n.parent, e.remove(o)
        }
    })
}

function F0(s, e, t) {
    return s.change(i => {
        const n = t || s.document.selection;
        n.isCollapsed || s.deleteContent(n, {doNotAutoparagraph: !0});
        const o = new L0(s, i, n.anchor), r = [];
        let a;
        if (e.is("documentFragment")) {
            if (e.markers.size) {
                const u = [];
                for (const [d, h] of e.markers) {
                    const {start: f, end: m} = h, g = f.isEqual(m);
                    u.push({position: f, name: d, isCollapsed: g}, {position: m, name: d, isCollapsed: g})
                }
                u.sort(({position: d}, {position: h}) => d.isBefore(h) ? 1 : -1);
                for (const {position: d, name: h, isCollapsed: f} of u) {
                    let m = null, g = null;
                    const _ = d.parent === e && d.isAtStart, v = d.parent === e && d.isAtEnd;
                    !_ && !v ? (m = i.createElement("$marker"), i.insert(m, d)) : f && (g = _ ? "start" : "end"), r.push({
                        name: h,
                        element: m,
                        collapsed: g
                    })
                }
            }
            a = e.getChildren()
        } else a = [e];
        o.handleNodes(a);
        let l = o.getSelectionRange();
        if (e.is("documentFragment") && r.length) {
            const u = l ? Ce.fromRange(l) : null, d = {};
            for (let h = r.length - 1; h >= 0; h--) {
                const {name: f, element: m, collapsed: g} = r[h], _ = !d[f];
                if (_ && (d[f] = []), m) {
                    const v = i.createPositionAt(m, "before");
                    d[f].push(v), i.remove(m)
                } else {
                    const v = o.getAffectedRange();
                    if (!v) {
                        g && d[f].push(o.position);
                        continue
                    }
                    g ? d[f].push(v[g]) : d[f].push(_ ? v.start : v.end)
                }
            }
            for (const [h, [f, m]] of Object.entries(d)) f && m && f.root === m.root && f.root.document && !i.model.markers.has(h) && i.addMarker(h, {
                usingOperation: !0,
                affectsData: !0,
                range: new b(f, m)
            });
            u && (l = u.toRange(), u.detach())
        }/* istanbul ignore else -- @preserve */
        l && (n instanceof st ? i.setSelection(l) : n.setTo(l));
        const c = o.getAffectedRange() || s.createRange(n.anchor);
        return o.destroy(), c
    })
}

class L0 {
    model;
    writer;
    position;
    canMergeWith;
    schema;
    _documentFragment;
    _documentFragmentPosition;
    _firstNode = null;
    _lastNode = null;
    _lastAutoParagraph = null;
    _filterAttributesOf = [];
    _affectedStart = null;
    _affectedEnd = null;
    _nodeToSelect = null;

    constructor(e, t, i) {
        this.model = e, this.writer = t, this.position = i, this.canMergeWith = new Set([this.position.parent]), this.schema = e.schema, this._documentFragment = t.createDocumentFragment(), this._documentFragmentPosition = t.createPositionAt(this._documentFragment, 0)
    }

    handleNodes(e) {
        for (const t of Array.from(e)) this._handleNode(t);
        this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = []
    }

    _updateLastNodeFromAutoParagraph(e) {
        const t = this.writer.createPositionAfter(this._lastNode), i = this.writer.createPositionAfter(e);
        if (i.isAfter(t)) {
            this._lastNode = e;/* istanbul ignore if -- @preserve */
            if (this.position.parent != e || !this.position.isAtEnd) throw new p("insertcontent-invalid-insertion-position", this);
            this.position = i, this._setAffectedBoundaries(this.position)
        }
    }

    getSelectionRange() {
        return this._nodeToSelect ? b._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position)
    }

    getAffectedRange() {
        return this._affectedStart ? new b(this._affectedStart, this._affectedEnd) : null
    }

    destroy() {
        this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach()
    }

    _handleNode(e) {
        if (!this._checkAndSplitToAllowedPosition(e)) {
            this.schema.isObject(e) || this._handleDisallowedNode(e);
            return
        }
        this._appendToFragment(e), this._firstNode || (this._firstNode = e), this._lastNode = e
    }

    _insertPartialFragment() {
        if (this._documentFragment.isEmpty) return;
        const e = Y.fromPosition(this.position, "toNext");
        this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = e.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = e.toPosition(), e.detach()
    }

    _handleDisallowedNode(e) {
        e.is("element") && this.handleNodes(e.getChildren())
    }

    _appendToFragment(e) {/* istanbul ignore if -- @preserve */
        if (!this.schema.checkChild(this.position, e)) throw new p("insertcontent-wrong-position", this, {
            node: e,
            position: this.position
        });
        this.writer.insert(e, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(e.offsetSize), this.schema.isObject(e) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = e : this._nodeToSelect = null, this._filterAttributesOf.push(e)
    }

    _setAffectedBoundaries(e) {
        this._affectedStart || (this._affectedStart = Y.fromPosition(e, "toPrevious")), (!this._affectedEnd || this._affectedEnd.isBefore(e)) && (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = Y.fromPosition(e, "toNext"))
    }

    _mergeOnLeft() {
        const e = this._firstNode;
        if (!(e instanceof j) || !this._canMergeLeft(e)) return;
        const t = Y._createBefore(e);
        t.stickiness = "toNext";
        const i = Y.fromPosition(this.position, "toNext");
        this._affectedStart.isEqual(t) && (this._affectedStart.detach(), this._affectedStart = Y._createAt(t.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = Y._createAt(t.nodeBefore, "end", "toNext")), this.position = i.toPosition(), i.detach(), this._filterAttributesOf.push(this.position.parent), t.detach()
    }

    _mergeOnRight() {
        const e = this._lastNode;
        if (!(e instanceof j) || !this._canMergeRight(e)) return;
        const t = Y._createAfter(e);
        t.stickiness = "toNext";/* istanbul ignore if -- @preserve */
        if (!this.position.isEqual(t)) throw new p("insertcontent-invalid-insertion-position", this);
        this.position = y._createAt(t.nodeBefore, "end");
        const i = Y.fromPosition(this.position, "toPrevious");
        this._affectedEnd.isEqual(t) && (this._affectedEnd.detach(), this._affectedEnd = Y._createAt(t.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = t.nodeBefore, this._lastNode = t.nodeBefore), this.writer.merge(t), t.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = Y._createAt(t.nodeBefore, 0, "toPrevious")), this.position = i.toPosition(), i.detach(), this._filterAttributesOf.push(this.position.parent), t.detach()
    }

    _canMergeLeft(e) {
        const t = e.previousSibling;
        return t instanceof j && this.canMergeWith.has(t) && this.model.schema.checkMerge(t, e)
    }

    _canMergeRight(e) {
        const t = e.nextSibling;
        return t instanceof j && this.canMergeWith.has(t) && this.model.schema.checkMerge(e, t)
    }

    _insertAutoParagraph() {
        this._insertPartialFragment();
        const e = this.writer.createElement("paragraph");
        this.writer.insert(e, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = e, this.position = this.writer.createPositionAt(e, 0)
    }

    _checkAndSplitToAllowedPosition(e) {
        const t = this._getAllowedIn(this.position.parent, e);
        if (!t) return !1;
        for (t != this.position.parent && this._insertPartialFragment(); t != this.position.parent;) if (this.position.isAtStart) {
            const i = this.position.parent;
            this.position = this.writer.createPositionBefore(i), i.isEmpty && i.parent === t && this.writer.remove(i)
        } else if (this.position.isAtEnd) this.position = this.writer.createPositionAfter(this.position.parent); else {
            const i = this.writer.createPositionAfter(this.position.parent);
            this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = i, this.canMergeWith.add(this.position.nodeAfter)
        }
        return this.schema.checkChild(this.position.parent, e) || this._insertAutoParagraph(), !0
    }

    _getAllowedIn(e, t) {
        return this.schema.checkChild(e, t) || this.schema.checkChild(e, "paragraph") && this.schema.checkChild("paragraph", t) ? e : this.schema.isLimit(e) ? null : this._getAllowedIn(e.parent, t)
    }
}

function D0(s, e, t, i = {}) {
    if (!s.schema.isObject(e)) throw new p("insertobject-element-not-an-object", s, {object: e});
    const n = t || s.document.selection;
    let o = n;
    i.findOptimalPosition && s.schema.isBlock(e) && (o = s.createSelection(s.schema.findOptimalInsertionRange(n, i.findOptimalPosition)));
    const r = re(n.getSelectedBlocks()), a = {};
    return r && Object.assign(a, s.schema.getAttributesWithProperty(r, "copyOnReplace", !0)), s.change(l => {
        o.isCollapsed || s.deleteContent(o, {doNotAutoparagraph: !0});
        let c = e;
        const u = o.anchor.parent;
        !s.schema.checkChild(u, e) && s.schema.checkChild(u, "paragraph") && s.schema.checkChild("paragraph", e) && (c = l.createElement("paragraph"), l.insert(e, c)), s.schema.setAllowedAttributes(c, a, l);
        const d = s.insertContent(c, o);
        return d.isCollapsed || i.setSelection && N0(l, e, i.setSelection, a), d
    })
}

function N0(s, e, t, i) {
    const n = s.model;
    if (t == "on") {
        s.setSelection(e, "on");
        return
    }
    if (t != "after") throw new p("insertobject-invalid-place-parameter-value", n);
    let o = e.nextSibling;
    if (n.schema.isInline(e)) {
        s.setSelection(e, "after");
        return
    }
    !(o && n.schema.checkChild(o, "$text")) && n.schema.checkChild(e.parent, "paragraph") && (o = s.createElement("paragraph"), n.schema.setAllowedAttributes(o, i, s), n.insertContent(o, s.createPositionAfter(e))), o && s.setSelection(o, 0)
}

const z0 = ' ,.?!:;"-()';

function H0(s, e, t = {}) {
    const i = s.schema, n = t.direction != "backward", o = t.unit ? t.unit : "character",
        r = !!t.treatEmojiAsSingleUnit, a = e.focus,
        l = new Ct({boundaries: q0(a, n), singleCharacters: !0, direction: n ? "forward" : "backward"}),
        c = {walker: l, schema: i, isForward: n, unit: o, treatEmojiAsSingleUnit: r};
    let u;
    for (; u = l.next();) {
        if (u.done) return;
        const d = U0(c, u.value);
        if (d) {
            e instanceof st ? s.change(h => {
                h.setSelectionFocus(d)
            }) : e.setFocus(d);
            return
        }
    }
}

function U0(s, e) {
    const {isForward: t, walker: i, unit: n, schema: o, treatEmojiAsSingleUnit: r} = s, {
        type: a,
        item: l,
        nextPosition: c
    } = e;
    if (a == "text") return s.unit === "word" ? W0(i, t) : $0(i, n, r);
    if (a == (t ? "elementStart" : "elementEnd")) {
        if (o.isSelectable(l)) return y._createAt(l, t ? "after" : "before");
        if (o.checkChild(c, "$text")) return c
    } else {
        if (o.isLimit(l)) {
            i.skip(() => !0);
            return
        }
        if (o.checkChild(c, "$text")) return c
    }
}

function $0(s, e, t) {
    const i = s.position.textNode;
    if (i) {
        const n = i.data;
        let o = s.position.offset - i.startOffset;
        for (; ta(n, o) || e == "character" && ia(n, o) || t && ph(n, o);) s.next(), o = s.position.offset - i.startOffset
    }
    return s.position
}

function W0(s, e) {
    let t = s.position.textNode;
    for (t || (t = e ? s.position.nodeAfter : s.position.nodeBefore); t && t.is("$text");) {
        const i = s.position.offset - t.startOffset;
        if (G0(t, i, e)) t = e ? s.position.nodeAfter : s.position.nodeBefore; else {
            if (j0(t.data, i, e)) break;
            s.next()
        }
    }
    return s.position
}

function q0(s, e) {
    const t = s.root, i = y._createAt(t, e ? "end" : 0);
    return e ? new b(s, i) : new b(i, s)
}

function j0(s, e, t) {
    const i = e + (t ? 0 : -1);
    return z0.includes(s.charAt(i))
}

function G0(s, e, t) {
    return e === (t ? s.offsetSize : 0)
}

let K0 = class extends H() {
    markers;
    document;
    schema;
    _pendingChanges;
    _currentWriter;

    constructor() {
        super(), this.markers = new m0, this.document = new f0(this), this.schema = new P_, this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach(e => this.decorate(e)), this.on("applyOperation", (e, t) => {
            t[0]._validate()
        }, {priority: "highest"}), this.schema.register("$root", {isLimit: !0}), this.schema.register("$container", {allowIn: ["$root", "$container"]}), this.schema.register("$block", {
            allowIn: ["$root", "$container"],
            isBlock: !0
        }), this.schema.register("$blockObject", {
            allowWhere: "$block",
            isBlock: !0,
            isObject: !0
        }), this.schema.register("$inlineObject", {
            allowWhere: "$text",
            allowAttributesOf: "$text",
            isInline: !0,
            isObject: !0
        }), this.schema.register("$text", {
            allowIn: "$block",
            isInline: !0,
            isContent: !0
        }), this.schema.register("$clipboardHolder", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: !0
        }), this.schema.register("$documentFragment", {
            allowContentOf: "$root",
            allowChildren: "$text",
            isLimit: !0
        }), this.schema.register("$marker"), this.schema.addChildCheck(() => !0, "$marker"), _0(this), this.document.registerPostFixer(Wh), this.on("insertContent", (e, [t, i]) => {
            e.return = F0(this, t, i)
        }), this.on("insertObject", (e, [t, i, n]) => {
            e.return = D0(this, t, i, n)
        }), this.on("canEditAt", e => {
            const t = !this.document.isReadOnly;
            e.return = t, t || e.stop()
        })
    }

    change(e) {
        try {
            return this._pendingChanges.length === 0 ? (this._pendingChanges.push({
                batch: new pi,
                callback: e
            }), this._runPendingChanges()[0]) : e(this._currentWriter)
        } catch (t) {/* istanbul ignore next -- @preserve */
            p.rethrowUnexpectedError(t, this)
        }
    }

    enqueueChange(e, t) {
        try {
            e ? typeof e == "function" ? (t = e, e = new pi) : e instanceof pi || (e = new pi(e)) : e = new pi, this._pendingChanges.push({
                batch: e,
                callback: t
            }), this._pendingChanges.length == 1 && this._runPendingChanges()
        } catch (i) {/* istanbul ignore next -- @preserve */
            p.rethrowUnexpectedError(i, this)
        }
    }

    applyOperation(e) {
        e._execute()
    }

    insertContent(e, t, i, ...n) {
        const o = xo(t, i);
        return this.fire("insertContent", [e, o, i, ...n])
    }

    insertObject(e, t, i, n, ...o) {
        const r = xo(t, i);
        return this.fire("insertObject", [e, r, n, n, ...o])
    }

    deleteContent(e, t) {
        T0(this, e, t)
    }

    modifySelection(e, t) {
        H0(this, e, t)
    }

    getSelectedContent(e) {
        return B0(this, e)
    }

    hasContent(e, t = {}) {
        const i = e instanceof b ? e : b._createIn(e);
        if (i.isCollapsed) return !1;
        const {ignoreWhitespaces: n = !1, ignoreMarkers: o = !1} = t;
        if (!o) {
            for (const r of this.markers.getMarkersIntersectingRange(i)) if (r.affectsData) return !0
        }
        for (const r of i.getItems()) if (this.schema.isContent(r)) if (r.is("$textProxy")) if (n) {
            if (r.data.search(/\S/) !== -1) return !0
        } else return !0; else return !0;
        return !1
    }

    canEditAt(e) {
        const t = xo(e);
        return this.fire("canEditAt", [t])
    }

    createPositionFromPath(e, t, i) {
        return new y(e, t, i)
    }

    createPositionAt(e, t) {
        return y._createAt(e, t)
    }

    createPositionAfter(e) {
        return y._createAfter(e)
    }

    createPositionBefore(e) {
        return y._createBefore(e)
    }

    createRange(e, t) {
        return new b(e, t)
    }

    createRangeIn(e) {
        return b._createIn(e)
    }

    createRangeOn(e) {
        return b._createOn(e)
    }

    createSelection(...e) {
        return new Fe(...e)
    }

    createBatch(e) {
        return new pi(e)
    }

    createOperationFromJSON(e) {
        return i0.fromJSON(e, this.document)
    }

    destroy() {
        this.document.destroy(), this.stopListening()
    }

    _runPendingChanges() {
        const e = [];
        this.fire("_beforeChanges");
        try {
            for (; this._pendingChanges.length;) {
                const t = this._pendingChanges[0].batch;
                this._currentWriter = new w0(this, t);
                const i = this._pendingChanges[0].callback(this._currentWriter);
                e.push(i), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null
            }
        } finally {
            this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges")
        }
        return e
    }
};

function xo(s, e) {
    if (s) return s instanceof Fe || s instanceof st ? s : s instanceof ai ? e || e === 0 ? new Fe(s, e) : s.is("rootElement") ? new Fe(s, "in") : new Fe(s, "on") : new Fe(s)
}

class Z0 extends Pt {
    domEventType = "click";

    onDomEvent(e) {
        this.fire(e.type, e)
    }
}

class to extends Pt {
    domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];

    onDomEvent(e) {
        this.fire(e.type, e)
    }
}

class J0 extends Pt {
    domEventType = ["touchstart", "touchend", "touchmove"];

    onDomEvent(e) {
        this.fire(e.type, e)
    }
}

class pt {
    document;

    constructor(e) {
        this.document = e
    }

    createDocumentFragment(e) {
        return new Xt(this.document, e)
    }

    createElement(e, t, i) {
        return new It(this.document, e, t, i)
    }

    createText(e) {
        return new ge(this.document, e)
    }

    clone(e, t = !1) {
        return e._clone(t)
    }

    appendChild(e, t) {
        return t._appendChild(e)
    }

    insertChild(e, t, i) {
        return i._insertChild(e, t)
    }

    removeChildren(e, t, i) {
        return i._removeChildren(e, t)
    }

    remove(e) {
        const t = e.parent;
        return t ? this.removeChildren(t.getChildIndex(e), 1, t) : []
    }

    replace(e, t) {
        const i = e.parent;
        if (i) {
            const n = i.getChildIndex(e);
            return this.removeChildren(n, 1, i), this.insertChild(n, t, i), !0
        }
        return !1
    }

    unwrapElement(e) {
        const t = e.parent;
        if (t) {
            const i = t.getChildIndex(e);
            this.remove(e), this.insertChild(i, e.getChildren(), t)
        }
    }

    rename(e, t) {
        const i = new It(this.document, e, t.getAttributes(), t.getChildren());
        return this.replace(t, i) ? i : null
    }

    setAttribute(e, t, i) {
        i._setAttribute(e, t)
    }

    removeAttribute(e, t) {
        t._removeAttribute(e)
    }

    addClass(e, t) {
        t._addClass(e)
    }

    removeClass(e, t) {
        t._removeClass(e)
    }

    setStyle(e, t, i) {
        Xe(e) && i === void 0 ? t._setStyle(e) : i._setStyle(e, t)
    }

    removeStyle(e, t) {
        t._removeStyle(e)
    }

    setCustomProperty(e, t, i) {
        i._setCustomProperty(e, t)
    }

    removeCustomProperty(e, t) {
        return t._removeCustomProperty(e)
    }

    createPositionAt(e, t) {
        return k._createAt(e, t)
    }

    createPositionAfter(e) {
        return k._createAfter(e)
    }

    createPositionBefore(e) {
        return k._createBefore(e)
    }

    createRange(e, t) {
        return new B(e, t)
    }

    createRangeOn(e) {
        return B._createOn(e)
    }

    createRangeIn(e) {
        return B._createIn(e)
    }

    createSelection(...e) {
        return new Et(...e)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const Q0 = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i,
    Y0 = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i,
    X0 = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
    ev = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i,
    tv = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
    iv = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi,
    nv = new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "activeborder", "activecaption", "appworkspace", "background", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "captiontext", "graytext", "highlight", "highlighttext", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infobackground", "infotext", "menu", "menutext", "scrollbar", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "window", "windowframe", "windowtext", "rebeccapurple", "currentcolor", "transparent"]);

function sv(s) {
    return s.startsWith("#") ? Q0.test(s) : s.startsWith("rgb") ? Y0.test(s) || X0.test(s) : s.startsWith("hsl") ? ev.test(s) || tv.test(s) : nv.has(s.toLowerCase())
}

const ov = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;

function rv(s) {
    return ov.test(s)
}

const av = /^[+-]?[0-9]*([.][0-9]+)?%$/;

function lv(s) {
    return av.test(s)
}

const cv = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];

function uv(s) {
    return cv.includes(s)
}

const dv = ["center", "top", "bottom", "left", "right"];

function hv(s) {
    return dv.includes(s)
}

const fv = ["fixed", "scroll", "local"];

function mv(s) {
    return fv.includes(s)
}

const gv = /^url\(/;

function pv(s) {
    return gv.test(s)
}

function wv(s) {
    const e = s.trim().slice(0, 1500).matchAll(iv);
    return Array.from(e).map(t => t[0])
}

function bv(s) {
    s.setNormalizer("background", _v()), s.setNormalizer("background-color", vv()), s.setReducer("background", yv()), s.setStyleRelation("background", ["background-color"])
}

function _v() {
    return s => {
        const e = {}, t = wv(s);
        for (const i of t) uv(i) ? (e.repeat = e.repeat || [], e.repeat.push(i)) : hv(i) ? (e.position = e.position || [], e.position.push(i)) : mv(i) ? e.attachment = i : sv(i) ? e.color = i : pv(i) && (e.image = i);
        return {path: "background", value: e}
    }
}

function vv() {
    return s => ({path: "background.color", value: s})
}

function yv() {
    return s => {
        const e = [];
        return e.push(["background-color", s.color]), e
    }
}/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class of {
    crashes = [];
    state = "initializing";
    _crashNumberLimit;
    _now = Date.now;
    _minimumNonErrorTimePeriod;
    _boundErrorHandler;
    _listeners;

    constructor(e) {
        if (this.crashes = [], this._crashNumberLimit = typeof e.crashNumberLimit == "number" ? e.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = typeof e.minimumNonErrorTimePeriod == "number" ? e.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = t => {
            const i = "error" in t ? t.error : t.reason;
            i instanceof Error && this._handleError(i, t)
        }, this._listeners = {}, !this._restart) throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.")
    }

    destroy() {
        this._stopErrorHandling(), this._listeners = {}
    }

    on(e, t) {
        this._listeners[e] || (this._listeners[e] = []), this._listeners[e].push(t)
    }

    off(e, t) {
        this._listeners[e] = this._listeners[e].filter(i => i !== t)
    }

    _fire(e, ...t) {
        const i = this._listeners[e] || [];
        for (const n of i) n.apply(this, [null, ...t])
    }

    _startErrorHandling() {
        window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler)
    }

    _stopErrorHandling() {
        window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler)
    }

    _handleError(e, t) {
        if (this._shouldReactToError(e)) {
            this.crashes.push({
                message: e.message,
                stack: e.stack,
                filename: t instanceof ErrorEvent ? t.filename : void 0,
                lineno: t instanceof ErrorEvent ? t.lineno : void 0,
                colno: t instanceof ErrorEvent ? t.colno : void 0,
                date: this._now()
            });
            const i = this._shouldRestart();
            this.state = "crashed", this._fire("stateChange"), this._fire("error", {
                error: e,
                causesRestart: i
            }), i ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"))
        }
    }

    _shouldReactToError(e) {
        return e.is && e.is("CKEditorError") && e.context !== void 0 && e.context !== null && this.state === "ready" && this._isErrorComingFromThisItem(e)
    }

    _shouldRestart() {
        if (this.crashes.length <= this._crashNumberLimit) return !0;
        const e = this.crashes[this.crashes.length - 1].date,
            t = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
        return (e - t) / this._crashNumberLimit > this._minimumNonErrorTimePeriod
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function br(s, e = new Set) {
    const t = [s], i = new Set;
    let n = 0;
    for (; t.length > n;) {
        const o = t[n++];
        if (!(i.has(o) || !kv(o) || e.has(o))) if (i.add(o), Symbol.iterator in o) try {
            for (const r of o) t.push(r)
        } catch {
        } else for (const r in o) r !== "defaultValue" && t.push(o[r])
    }
    return i
}

function kv(s) {
    const e = Object.prototype.toString.call(s), t = typeof s;
    return !(t === "number" || t === "boolean" || t === "string" || t === "symbol" || t === "function" || e === "[object Date]" || e === "[object RegExp]" || e === "[object Module]" || s === void 0 || s === null || s._watchdogExcluded || s instanceof EventTarget || s instanceof Event)
}

function rf(s, e, t = new Set) {
    if (s === e && Cv(s)) return !0;
    const i = br(s, t), n = br(e, t);
    for (const o of i) if (n.has(o)) return !0;
    return !1
}

function Cv(s) {
    return typeof s == "object" && s !== null
}

class af extends of {
    _editor = null;
    _lifecyclePromise = null;
    _throttledSave;
    _data;
    _lastDocumentVersion;
    _elementOrData;
    _initUsingData = !0;
    _editables = {};
    _config;
    _excludedProps;

    constructor(e, t = {}) {
        super(t), this._throttledSave = Ni(this._save.bind(this), typeof t.saveInterval == "number" ? t.saveInterval : 5e3), e && (this._creator = (i, n) => e.create(i, n)), this._destructor = i => i.destroy()
    }

    get editor() {
        return this._editor
    }

    get _item() {
        return this._editor
    }

    setCreator(e) {
        this._creator = e
    }

    setDestructor(e) {
        this._destructor = e
    }

    _restart() {
        return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch(e => {
            console.error("An error happened during the editor destroying.", e)
        }).then(() => {
            const e = {}, t = [], i = this._config.rootsAttributes || {}, n = {};
            for (const [r, a] of Object.entries(this._data.roots)) a.isLoaded ? (e[r] = "", n[r] = i[r] || {}) : t.push(r);
            const o = {
                ...this._config,
                extraPlugins: this._config.extraPlugins || [],
                lazyRoots: t,
                rootsAttributes: n,
                _watchdogInitialData: this._data
            };
            return delete o.initialData, o.extraPlugins.push(Ev), this._initUsingData ? this.create(e, o, o.context) : At(this._elementOrData) ? this.create(this._elementOrData, o, o.context) : this.create(this._editables, o, o.context)
        }).then(() => {
            this._fire("restart")
        })
    }

    create(e = this._elementOrData, t = this._config, i) {
        return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => (super._startErrorHandling(), this._elementOrData = e, this._initUsingData = typeof e == "string" || Object.keys(e).length > 0 && typeof Object.values(e)[0] == "string", this._config = this._cloneEditorConfiguration(t) || {}, this._config.context = i, this._creator(e, this._config))).then(n => {
            this._editor = n, n.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = n.model.document.version, this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this.state = "ready", this._fire("stateChange")
        }).finally(() => {
            this._lifecyclePromise = null
        }), this._lifecyclePromise
    }

    destroy() {
        return this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy())).finally(() => {
            this._lifecyclePromise = null
        }), this._lifecyclePromise
    }

    _destroy() {
        return Promise.resolve().then(() => {
            this._stopErrorHandling(), this._throttledSave.cancel();
            const e = this._editor;
            return this._editor = null, e.model.document.off("change:data", this._throttledSave), this._destructor(e)
        })
    }

    _save() {
        const e = this._editor.model.document.version;
        try {
            this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this._lastDocumentVersion = e
        } catch (t) {
            console.error(t, "An error happened during restoring editor data. Editor will be restored from the previously saved data.")
        }
    }

    _setExcludedProperties(e) {
        this._excludedProps = e
    }

    _getData() {
        const e = this._editor,
            t = e.model.document.roots.filter(a => a.isAttached() && a.rootName != "$graveyard"), {plugins: i} = e,
            n = i.has("CommentsRepository") && i.get("CommentsRepository"),
            o = i.has("TrackChanges") && i.get("TrackChanges"),
            r = {roots: {}, markers: {}, commentThreads: JSON.stringify([]), suggestions: JSON.stringify([])};
        t.forEach(a => {
            r.roots[a.rootName] = {
                content: JSON.stringify(Array.from(a.getChildren())),
                attributes: JSON.stringify(Array.from(a.getAttributes())),
                isLoaded: a._isLoaded
            }
        });
        for (const a of e.model.markers) a._affectsData && (r.markers[a.name] = {
            rangeJSON: a.getRange().toJSON(),
            usingOperation: a._managedUsingOperations,
            affectsData: a._affectsData
        });
        return n && (r.commentThreads = JSON.stringify(n.getCommentThreads({
            toJSON: !0,
            skipNotAttached: !0
        }))), o && (r.suggestions = JSON.stringify(o.getSuggestions({toJSON: !0, skipNotAttached: !0}))), r
    }

    _getEditables() {
        const e = {};
        for (const t of this.editor.model.document.getRootNames()) {
            const i = this.editor.ui.getEditableElement(t);
            i && (e[t] = i)
        }
        return e
    }

    _isErrorComingFromThisItem(e) {
        return rf(this._editor, e.context, this._excludedProps)
    }

    _cloneEditorConfiguration(e) {
        return Ks(e, (t, i) => {
            if (At(t) || i === "context") return t
        })
    }
}

class Ev {
    editor;
    _data;

    constructor(e) {
        this.editor = e, this._data = e.config.get("_watchdogInitialData")
    }

    init() {
        this.editor.data.on("init", e => {
            e.stop(), this.editor.model.enqueueChange({isUndoable: !1}, t => {
                this._restoreCollaborationData(), this._restoreEditorData(t)
            }), this.editor.data.fire("ready")
        }, {priority: 999})
    }

    _createNode(e, t) {
        if ("name" in t) {
            const i = e.createElement(t.name, t.attributes);
            if (t.children) for (const n of t.children) i._appendChild(this._createNode(e, n));
            return i
        } else return e.createText(t.data, t.attributes)
    }

    _restoreEditorData(e) {
        const t = this.editor;
        Object.entries(this._data.roots).forEach(([i, {content: n, attributes: o}]) => {
            const r = JSON.parse(n), a = JSON.parse(o), l = t.model.document.getRoot(i);
            for (const [c, u] of a) e.setAttribute(c, u, l);
            for (const c of r) {
                const u = this._createNode(e, c);
                e.insert(u, l, "end")
            }
        }), Object.entries(this._data.markers).forEach(([i, n]) => {
            const {document: o} = t.model, {rangeJSON: {start: r, end: a}, ...l} = n, c = o.getRoot(r.root),
                u = e.createPositionFromPath(c, r.path, r.stickiness),
                d = e.createPositionFromPath(c, a.path, a.stickiness), h = e.createRange(u, d);
            e.addMarker(i, {range: h, ...l})
        })
    }

    _restoreCollaborationData() {
        const e = JSON.parse(this._data.commentThreads), t = JSON.parse(this._data.suggestions);
        e.forEach(i => {
            const n = this.editor.config.get("collaboration.channelId"),
                o = this.editor.plugins.get("CommentsRepository");
            o.hasCommentThread(i.threadId) && o.getCommentThread(i.threadId).remove(), o.addCommentThread({channelId: n, ...i})
        }), t.forEach(i => {
            const n = this.editor.plugins.get("TrackChangesEditing");
            if (n.hasSuggestion(i.id)) {
                const o = n.getSuggestion(i.id);
                o.attributes = i.attributes
            } else n.addSuggestionData(i)
        })
    }
}

const Cn = Symbol("MainQueueId");

class Tv extends of {
    _watchdogs = new Map;
    _watchdogConfig;
    _context = null;
    _contextProps = new Set;
    _actionQueues = new Av;
    _contextConfig;
    _item;

    constructor(e, t = {}) {
        super(t), this._watchdogConfig = t, this._creator = i => e.create(i), this._destructor = i => i.destroy(), this._actionQueues.onEmpty(() => {
            this.state === "initializing" && (this.state = "ready", this._fire("stateChange"))
        })
    }

    setCreator(e) {
        this._creator = e
    }

    setDestructor(e) {
        this._destructor = e
    }

    get context() {
        return this._context
    }

    create(e = {}) {
        return this._actionQueues.enqueue(Cn, () => (this._contextConfig = e, this._create()))
    }

    getItem(e) {
        return this._getWatchdog(e)._item
    }

    getItemState(e) {
        return this._getWatchdog(e).state
    }

    add(e) {
        const t = ql(e);
        return Promise.all(t.map(i => this._actionQueues.enqueue(i.id, () => {
            if (this.state === "destroyed") throw new Error("Cannot add items to destroyed watchdog.");
            if (!this._context) throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            let n;
            if (this._watchdogs.has(i.id)) throw new Error(`Item with the given id is already added: '${i.id}'.`);
            if (i.type === "editor") return n = new af(null, this._watchdogConfig), n.setCreator(i.creator), n._setExcludedProperties(this._contextProps), i.destructor && n.setDestructor(i.destructor), this._watchdogs.set(i.id, n), n.on("error", (o, {
                error: r,
                causesRestart: a
            }) => {
                this._fire("itemError", {
                    itemId: i.id,
                    error: r
                }), a && this._actionQueues.enqueue(i.id, () => new Promise(l => {
                    const c = () => {
                        n.off("restart", c), this._fire("itemRestart", {itemId: i.id}), l()
                    };
                    n.on("restart", c)
                }))
            }), n.create(i.sourceElementOrData, i.config, this._context);
            throw new Error(`Not supported item type: '${i.type}'.`)
        })))
    }

    remove(e) {
        const t = ql(e);
        return Promise.all(t.map(i => this._actionQueues.enqueue(i, () => {
            const n = this._getWatchdog(i);
            return this._watchdogs.delete(i), n.destroy()
        })))
    }

    destroy() {
        return this._actionQueues.enqueue(Cn, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()))
    }

    _restart() {
        return this._actionQueues.enqueue(Cn, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch(e => {
            console.error("An error happened during destroying the context or items.", e)
        }).then(() => this._create()).then(() => this._fire("restart"))))
    }

    _create() {
        return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then(e => (this._context = e, this._contextProps = br(this._context), Promise.all(Array.from(this._watchdogs.values()).map(t => (t._setExcludedProperties(this._contextProps), t.create(void 0, void 0, this._context))))))
    }

    _destroy() {
        return Promise.resolve().then(() => {
            this._stopErrorHandling();
            const e = this._context;
            return this._context = null, this._contextProps = new Set, Promise.all(Array.from(this._watchdogs.values()).map(t => t.destroy())).then(() => this._destructor(e))
        })
    }

    _getWatchdog(e) {
        const t = this._watchdogs.get(e);
        if (!t) throw new Error(`Item with the given id was not registered: ${e}.`);
        return t
    }

    _isErrorComingFromThisItem(e) {
        for (const t of this._watchdogs.values()) if (t._isErrorComingFromThisItem(e)) return !1;
        return rf(this._context, e.context)
    }
}

class Av {
    _onEmptyCallbacks = [];
    _queues = new Map;
    _activeActions = 0;

    onEmpty(e) {
        this._onEmptyCallbacks.push(e)
    }

    enqueue(e, t) {
        const i = e === Cn;
        this._activeActions++, this._queues.get(e) || this._queues.set(e, Promise.resolve());
        const o = (i ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Cn), this._queues.get(e)])).then(t),
            r = o.catch(() => {
            });
        return this._queues.set(e, r), o.finally(() => {
            this._activeActions--, this._queues.get(e) === r && this._activeActions === 0 && this._onEmptyCallbacks.forEach(a => a())
        })
    }
}

function ql(s) {
    return Array.isArray(s) ? s : [s]
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class w extends H() {
    editor;
    _disableStack = new Set;

    constructor(e) {
        super(), this.editor = e, this.set("isEnabled", !0)
    }

    forceDisabled(e) {
        this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", jl, {priority: "highest"}), this.isEnabled = !1)
    }

    clearForceDisabled(e) {
        this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", jl), this.isEnabled = !0)
    }

    destroy() {
        this.stopListening()
    }

    static get isContextPlugin() {
        return !1
    }

    static get isOfficialPlugin() {
        return !1
    }

    static get isPremiumPlugin() {
        return !1
    }
}

function jl(s) {
    s.return = !1, s.stop()
}

class O extends H() {
    editor;
    _isEnabledBasedOnSelection;
    _affectsData;
    _disableStack;

    constructor(e) {
        super(), this.editor = e, this.set("value", void 0), this.set("isEnabled", !1), this._affectsData = !0, this._isEnabledBasedOnSelection = !0, this._disableStack = new Set, this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
            this.refresh()
        }), this.listenTo(e, "change:isReadOnly", () => {
            this.refresh()
        }), this.on("set:isEnabled", t => {
            if (!this.affectsData) return;
            const i = e.model.document.selection,
                o = !(i.getFirstPosition().root.rootName == "$graveyard") && e.model.canEditAt(i);
            (e.isReadOnly || this._isEnabledBasedOnSelection && !o) && (t.return = !1, t.stop())
        }, {priority: "highest"}), this.on("execute", t => {
            this.isEnabled || t.stop()
        }, {priority: "high"})
    }

    get affectsData() {
        return this._affectsData
    }

    set affectsData(e) {
        this._affectsData = e
    }

    refresh() {
        this.isEnabled = !0
    }

    forceDisabled(e) {
        this._disableStack.add(e), this._disableStack.size == 1 && (this.on("set:isEnabled", Gl, {priority: "highest"}), this.isEnabled = !1)
    }

    clearForceDisabled(e) {
        this._disableStack.delete(e), this._disableStack.size == 0 && (this.off("set:isEnabled", Gl), this.refresh())
    }

    execute(...e) {
    }

    destroy() {
        this.stopListening()
    }
}

function Gl(s) {
    s.return = !1, s.stop()
}

class Kl extends O {
    _childCommandsDefinitions = [];

    refresh() {
    }

    execute(...e) {
        const t = this._getFirstEnabledCommand();
        return !!t && t.execute(e)
    }

    registerChildCommand(e, t = {}) {
        jd(this._childCommandsDefinitions, {
            command: e,
            priority: t.priority || "normal"
        }), e.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled()
    }

    _checkEnabled() {
        this.isEnabled = !!this._getFirstEnabledCommand()
    }

    _getFirstEnabledCommand() {
        const e = this._childCommandsDefinitions.find(({command: t}) => t.isEnabled);
        return e && e.command
    }
}

class lf extends W() {
    _context;
    _plugins = new Map;
    _availablePlugins;
    _contextPlugins;

    constructor(e, t = [], i = []) {
        super(), this._context = e, this._availablePlugins = new Map;
        for (const n of t) n.pluginName && this._availablePlugins.set(n.pluginName, n);
        this._contextPlugins = new Map;
        for (const [n, o] of i) this._contextPlugins.set(n, o), this._contextPlugins.set(o, n), n.pluginName && this._availablePlugins.set(n.pluginName, n)
    }

    * [Symbol.iterator]() {
        for (const e of this._plugins) typeof e[0] == "function" && (yield e)
    }

    get(e) {
        const t = this._plugins.get(e);
        if (!t) {
            let i = e;
            throw typeof e == "function" && (i = e.pluginName || e.name), new p("plugincollection-plugin-not-loaded", this._context, {plugin: i})
        }
        return t
    }

    has(e) {
        return this._plugins.has(e)
    }

    init(e, t = [], i = []) {
        const n = this, o = this._context;
        f(e), g(e);
        const r = e.filter(A => !d(A, t)), a = [...m(r)];
        Z(a, i);
        const l = V(a);
        return N(l, "init").then(() => N(l, "afterInit")).then(() => l);

        function c(A) {
            return typeof A == "function"
        }

        function u(A) {
            return c(A) && !!A.isContextPlugin
        }

        function d(A, F) {
            return F.some(S => S === A || h(A) === S || h(S) === A)
        }

        function h(A) {
            return c(A) ? A.pluginName || A.name : A
        }

        function f(A, F = new Set) {
            A.forEach(S => {
                c(S) && (F.has(S) || (F.add(S), S.pluginName && !n._availablePlugins.has(S.pluginName) && n._availablePlugins.set(S.pluginName, S), S.requires && f(S.requires, F)))
            })
        }

        function m(A, F = new Set) {
            return A.map(S => c(S) ? S : n._availablePlugins.get(S)).reduce((S, P) => F.has(P) ? S : (F.add(P), P.requires && (g(P.requires, P), m(P.requires, F).forEach(J => S.add(J))), S.add(P)), new Set)
        }

        function g(A, F = null) {
            A.map(S => c(S) ? S : n._availablePlugins.get(S) || S).forEach(S => {
                _(S, F), v(S, F), E(S, F)
            })
        }

        function _(A, F) {
            if (!c(A)) throw F ? new p("plugincollection-soft-required", o, {
                missingPlugin: A,
                requiredBy: h(F)
            }) : new p("plugincollection-plugin-not-found", o, {plugin: A})
        }

        function v(A, F) {
            if (u(F) && !u(A)) throw new p("plugincollection-context-required", o, {plugin: h(A), requiredBy: h(F)})
        }

        function E(A, F) {
            if (F && d(A, t)) throw new p("plugincollection-required", o, {plugin: h(A), requiredBy: h(F)})
        }

        function V(A) {
            return A.map(F => {
                let S = n._contextPlugins.get(F);
                return S = S || new F(o), n._add(F, S), S
            })
        }

        function N(A, F) {
            return A.reduce((S, P) => !P[F] || n._contextPlugins.has(P) ? S : S.then(P[F].bind(P)), Promise.resolve())
        }

        function Z(A, F) {
            for (const S of F) {
                if (typeof S != "function") throw new p("plugincollection-replace-plugin-invalid-type", null, {pluginItem: S});
                const P = S.pluginName;
                if (!P) throw new p("plugincollection-replace-plugin-missing-name", null, {pluginItem: S});
                if (S.requires && S.requires.length) throw new p("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, {pluginName: P});
                const J = n._availablePlugins.get(P);
                if (!J) throw new p("plugincollection-plugin-for-replacing-not-exist", null, {pluginName: P});
                const ve = A.indexOf(J);
                if (ve === -1) {
                    if (n._contextPlugins.has(J)) return;
                    throw new p("plugincollection-plugin-for-replacing-not-loaded", null, {pluginName: P})
                }
                if (J.requires && J.requires.length) throw new p("plugincollection-replaced-plugin-cannot-have-dependencies", null, {pluginName: P});
                A.splice(ve, 1, S), n._availablePlugins.set(P, S)
            }
        }
    }

    destroy() {
        const e = [];
        for (const [, t] of this) typeof t.destroy == "function" && !this._contextPlugins.has(t) && e.push(t.destroy());
        return Promise.all(e)
    }

    _add(e, t) {
        this._plugins.set(e, t);
        const i = e.pluginName;
        if (i) {
            if (this._plugins.has(i)) throw new p("plugincollection-plugin-name-conflict", null, {
                pluginName: i,
                plugin1: this._plugins.get(i).constructor,
                plugin2: e
            });
            this._plugins.set(i, t)
        }
    }
}

class Zl {
    config;
    plugins;
    locale;
    t;
    editors;
    static defaultConfig;
    static builtinPlugins;
    _contextOwner = null;

    constructor(e) {
        const {translations: t, ...i} = e || {};
        this.config = new th(i, this.constructor.defaultConfig);
        const n = this.constructor.builtinPlugins;
        this.config.define("plugins", n), this.plugins = new lf(this, n);
        const o = this.config.get("language") || {};
        this.locale = new rw({
            uiLanguage: typeof o == "string" ? o : o.ui,
            contentLanguage: this.config.get("language.content"),
            translations: t
        }), this.t = this.locale.t, this.editors = new ce
    }

    initPlugins() {
        const e = this.config.get("plugins") || [], t = this.config.get("substitutePlugins") || [];
        for (const i of e.concat(t)) {
            if (typeof i != "function") throw new p("context-initplugins-constructor-only", null, {Plugin: i});
            if (i.isContextPlugin !== !0) throw new p("context-initplugins-invalid-plugin", null, {Plugin: i})
        }
        return this.plugins.init(e, [], t)
    }

    destroy() {
        return Promise.all(Array.from(this.editors, e => e.destroy())).then(() => this.plugins.destroy())
    }

    _addEditor(e, t) {
        if (this._contextOwner) throw new p("context-addeditor-private-context");
        this.editors.add(e), t && (this._contextOwner = e)
    }

    _removeEditor(e) {
        return this.editors.has(e) && this.editors.remove(e), this._contextOwner === e ? this.destroy() : Promise.resolve()
    }

    _getEditorConfig() {
        const e = {};
        for (const t of this.config.names()) ["plugins", "removePlugins", "extraPlugins"].includes(t) || (e[t] = this.config.get(t));
        return e
    }

    static create(e) {
        return new Promise(t => {
            const i = new this(e);
            t(i.initPlugins().then(() => i))
        })
    }
}

class cf extends H() {
    context;

    constructor(e) {
        super(), this.context = e
    }

    destroy() {
        this.stopListening()
    }

    static get isContextPlugin() {
        return !0
    }

    static get isOfficialPlugin() {
        return !1
    }

    static get isPremiumPlugin() {
        return !1
    }
}

class xv {
    _commands;

    constructor() {
        this._commands = new Map
    }

    add(e, t) {
        this._commands.set(e, t)
    }

    get(e) {
        return this._commands.get(e)
    }

    execute(e, ...t) {
        const i = this.get(e);
        if (!i) throw new p("commandcollection-command-not-found", this, {commandName: e});
        return i.execute(...t)
    }

    * names() {
        yield* this._commands.keys()
    }

    * commands() {
        yield* this._commands.values()
    }

    [Symbol.iterator]() {
        return this._commands[Symbol.iterator]()
    }

    destroy() {
        for (const e of this.commands()) e.destroy()
    }
}

class Iv extends ue {
    editor;

    constructor(e) {
        super(), this.editor = e
    }

    set(e, t, i = {}) {
        if (typeof t == "string") {
            const n = t;
            t = (o, r) => {
                this.editor.execute(n), r()
            }
        }
        super.set(e, t, i)
    }
}

const Io = "contentEditing", Jl = "common";

class Sv {
    keystrokeInfos = new Map;
    _editor;

    constructor(e) {
        this._editor = e;
        const t = e.config.get("menuBar.isVisible"), i = e.locale.t;
        this.addKeystrokeInfoCategory({
            id: Io,
            label: i("Content editing keystrokes"),
            description: i("These keyboard shortcuts allow for quick access to content editing features.")
        });
        const n = [{
            label: i("Close contextual balloons, dropdowns, and dialogs"),
            keystroke: "Esc"
        }, {
            label: i("Open the accessibility help dialog"),
            keystroke: "Alt+0"
        }, {
            label: i("Move focus between form fields (inputs, buttons, etc.)"),
            keystroke: [["Tab"], ["Shift+Tab"]]
        }, {
            label: i("Move focus to the toolbar, navigate between toolbars"),
            keystroke: "Alt+F10",
            mayRequireFn: !0
        }, {
            label: i("Navigate through the toolbar or menu bar"),
            keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
        }, {
            label: i("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."),
            keystroke: [["Enter"], ["Space"]]
        }];
        t && n.push({
            label: i("Move focus to the menu bar, navigate between menu bars"),
            keystroke: "Alt+F9",
            mayRequireFn: !0
        }), this.addKeystrokeInfoCategory({
            id: "navigation",
            label: i("User interface and content navigation keystrokes"),
            description: i("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."),
            groups: [{id: "common", keystrokes: n}]
        })
    }

    addKeystrokeInfoCategory({id: e, label: t, description: i, groups: n}) {
        this.keystrokeInfos.set(e, {
            id: e,
            label: t,
            description: i,
            groups: new Map
        }), this.addKeystrokeInfoGroup({categoryId: e, id: Jl}), n && n.forEach(o => {
            this.addKeystrokeInfoGroup({categoryId: e, ...o})
        })
    }

    addKeystrokeInfoGroup({categoryId: e = Io, id: t, label: i, keystrokes: n}) {
        const o = this.keystrokeInfos.get(e);
        if (!o) throw new p("accessibility-unknown-keystroke-info-category", this._editor, {groupId: t, categoryId: e});
        o.groups.set(t, {id: t, label: i, keystrokes: n || []})
    }

    addKeystrokeInfos({categoryId: e = Io, groupId: t = Jl, keystrokes: i}) {
        if (!this.keystrokeInfos.has(e)) throw new p("accessibility-unknown-keystroke-info-category", this._editor, {
            categoryId: e,
            keystrokes: i
        });
        const n = this.keystrokeInfos.get(e);
        if (!n.groups.has(t)) throw new p("accessibility-unknown-keystroke-info-group", this._editor, {
            groupId: t,
            categoryId: e,
            keystrokes: i
        });
        n.groups.get(t).keystrokes.push(...i)
    }
}

function Pv(s) {
    return {
        sessionId: Bv(),
        pageSessionId: Fv(),
        hostname: window.location.hostname,
        version: globalThis.CKEDITOR_VERSION,
        type: Rv(s),
        plugins: Vv(s.plugins),
        distribution: Ov(),
        env: Mv(),
        integration: Object.create(null),
        menuBar: {isVisible: !!s.config.get("menuBar.isVisible")},
        language: {ui: s.locale.uiLanguage, content: s.locale.contentLanguage},
        toolbar: {
            main: So(s.config.get("toolbar")),
            block: So(s.config.get("blockToolbar")),
            balloon: So(s.config.get("balloonToolbar"))
        }
    }
}

function Rv(s) {
    return Object.getPrototypeOf(s).constructor.editorName
}

function Vv(s) {
    return Array.from(s).filter(([e]) => !!e.pluginName).map(([e]) => {
        const {pluginName: t, isContextPlugin: i, isOfficialPlugin: n, isPremiumPlugin: o} = e;
        return {isContext: !!i, isOfficial: !!n, isPremium: !!o, name: t}
    })
}

function So(s) {
    if (!s) return;
    const e = Array.isArray(s) ? {items: s} : s, t = o(e.items || []);
    return {isMultiline: t.includes("-"), shouldNotGroupWhenFull: !!e.shouldNotGroupWhenFull, items: n(t)};

    function n(r) {
        return r.filter(a => a !== "|" && a !== "-")
    }

    function o(r) {
        return r.flatMap(a => typeof a == "string" ? [a] : o(a.items))
    }
}

function Ov() {
    return {channel: window[Symbol.for("cke distribution")] || "sh"}
}

function Mv() {
    let s = "unknown", e = "unknown";
    return x.isMac ? s = "mac" : x.isWindows ? s = "windows" : x.isiOS ? s = "ios" : x.isAndroid && (s = "android"), x.isGecko ? e = "gecko" : x.isBlink ? e = "blink" : x.isSafari && (e = "safari"), {
        os: s,
        browser: e
    }
}

function Bv() {
    return localStorage.getItem("__ckeditor-session-id") || localStorage.setItem("__ckeditor-session-id", pe()), localStorage.getItem("__ckeditor-session-id")
}

function Fv() {
    return C.window.CKEDITOR_PAGE_SESSION_ID = C.window.CKEDITOR_PAGE_SESSION_ID || pe(), C.window.CKEDITOR_PAGE_SESSION_ID
}

class Lv extends H() {
    static get editorName() {
        return "Editor"
    }

    accessibility;
    commands;
    config;
    conversion;
    data;
    editing;
    locale;
    model;
    plugins;
    keystrokes;
    t;
    static defaultConfig;
    static builtinPlugins;
    _context;
    _readOnlyLocks;

    constructor(e = {}) {
        if (super(), "sanitizeHtml" in e) throw new p("editor-config-sanitizehtml-not-supported");
        const t = this.constructor, {translations: i, ...n} = t.defaultConfig || {}, {translations: o = i, ...r} = e,
            a = e.language || n.language;
        this._context = e.context || new Zl({language: a, translations: o}), this._context._addEditor(this, !e.context);
        const l = Array.from(t.builtinPlugins || []);
        this.config = new th(r, n), this.config.define("plugins", l), this.config.define(this._context._getEditorConfig()), u(this.config), this.plugins = new lf(this, l, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = new Set, this.commands = new xv, this.set("state", "initializing"), this.once("ready", () => this.state = "ready", {priority: "high"}), this.once("destroy", () => this.state = "destroyed", {priority: "high"}), this.model = new K0, this.on("change:isReadOnly", () => {
            this.model.document.isReadOnly = this.isReadOnly
        });
        const c = new Vw;
        this.data = new Y_(this.model, c), this.editing = new S_(this.model, c), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new e0([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new Iv(this), this.keystrokes.listenTo(this.editing.view.document), this.accessibility = new Sv(this), d(this);

        function u(h) {
            let f = h.get("licenseKey");
            if (!f && window.CKEDITOR_GLOBAL_LICENSE_KEY && (f = window.CKEDITOR_GLOBAL_LICENSE_KEY, h.set("licenseKey", f)), !f) throw new p("license-key-missing")
        }

        function d(h) {
            const f = h.config.get("licenseKey"), m = window[Symbol.for("cke distribution")] || "sh";

            function g(P) {
                h.enableReadOnlyMode(Symbol("invalidLicense")), h._showLicenseError(P)
            }

            function _(P) {
                const J = P.split(".");
                return J.length != 3 ? null : J[1]
            }

            function v(P) {
                return ["exp", "jti", "vc"].every(ve => ve in P)
            }

            function E(P) {
                return Object.getOwnPropertyNames(P).sort().filter(ae => ae != "vc" && P[ae] != null).map(ae => P[ae])
            }

            function V(P) {
                const {hostname: J} = new URL(window.location.href);
                if (P.includes(J)) return !0;
                const ve = J.split(".");
                return P.filter(ae => ae.includes("*")).map(ae => ae.split(".")).filter(ae => ae.length <= ve.length).map(ae => Array(ve.length - ae.length).fill(ae[0] === "*" ? "*" : "").concat(ae)).some(ae => ve.every((Tg, Fa) => ae[Fa] === Tg || ae[Fa] === "*"))
            }

            function N(P) {
                const J = P[0].toUpperCase() + P.slice(1), ve = P === "evaluation" ? "an" : "a";
                console.info(`%cCKEditor 5 ${J} License`, "color: #ffffff; background: #743CCD; font-size: 14px; padding: 4px 8px; border-radius: 4px;"), console.warn(`⚠️ You are using ${ve} ${P} license of CKEditor 5${P === "trial" ? " which is for evaluation purposes only" : ""}. For production usage, please obtain a production license at https://portal.ckeditor.com/`)
            }

            if (f == "GPL") {
                m == "cloud" && g("distributionChannel");
                return
            }
            const Z = _(f);
            if (!Z) {
                g("invalid");
                return
            }
            const A = ea(Z);
            if (!A) {
                g("invalid");
                return
            }
            if (!v(A)) {
                g("invalid");
                return
            }
            if (A.distributionChannel && !U(A.distributionChannel).includes(m)) {
                g("distributionChannel");
                return
            }
            if (dw(E(A)) != A.vc.toLowerCase()) {
                g("invalid");
                return
            }
            if (new Date(A.exp * 1e3) < kp) {
                g("expired");
                return
            }
            const S = A.licensedHosts;
            if (S && S.length > 0 && !V(S)) {
                g("domainLimit");
                return
            }
            if (["evaluation", "trial"].includes(A.licenseType) && A.exp * 1e3 < Date.now()) {
                g("expired");
                return
            }
            if (["development", "evaluation", "trial"].includes(A.licenseType)) {
                const {licenseType: P} = A;
                window.CKEDITOR_WARNING_SUPPRESSIONS = window.CKEDITOR_WARNING_SUPPRESSIONS || {}, window.CKEDITOR_WARNING_SUPPRESSIONS[P] || (N(P), window.CKEDITOR_WARNING_SUPPRESSIONS[P] = !0)
            }
            if (["evaluation", "trial"].includes(A.licenseType)) {
                const P = A.licenseType, J = setTimeout(() => {
                    g(`${P}Limit`)
                }, 6e5);
                h.on("destroy", () => {
                    clearTimeout(J)
                })
            }
            A.usageEndpoint && h.once("ready", () => {
                const P = {requestId: pe(), requestTime: Math.round(Date.now() / 1e3), license: f, editor: Dv(h)};
                h._sendUsageRequest(A.usageEndpoint, P).then(J => {
                    const {status: ve, message: ae} = J;
                    ae && console.warn(ae), ve != "ok" && g("usageLimit")
                }, () => {
                    _p("license-key-validation-endpoint-not-reachable", {url: A.usageEndpoint})
                })
            }, {priority: "high"})
        }
    }

    get isReadOnly() {
        return this._readOnlyLocks.size > 0
    }

    set isReadOnly(e) {
        throw new p("editor-isreadonly-has-no-setter")
    }

    enableReadOnlyMode(e) {
        if (typeof e != "string" && typeof e != "symbol") throw new p("editor-read-only-lock-id-invalid", null, {lockId: e});
        this._readOnlyLocks.has(e) || (this._readOnlyLocks.add(e), this._readOnlyLocks.size === 1 && this.fire("change:isReadOnly", "isReadOnly", !0, !1))
    }

    disableReadOnlyMode(e) {
        if (typeof e != "string" && typeof e != "symbol") throw new p("editor-read-only-lock-id-invalid", null, {lockId: e});
        this._readOnlyLocks.has(e) && (this._readOnlyLocks.delete(e), this._readOnlyLocks.size === 0 && this.fire("change:isReadOnly", "isReadOnly", !1, !0))
    }

    setData(e) {
        this.data.set(e)
    }

    getData(e) {
        return this.data.get(e)
    }

    initPlugins() {
        const e = this.config, t = e.get("plugins"), i = e.get("removePlugins") || [], n = e.get("extraPlugins") || [],
            o = e.get("substitutePlugins") || [];
        return this.plugins.init(t.concat(n), i, o)
    }

    destroy() {
        let e = Promise.resolve();
        return this.state == "initializing" && (e = new Promise(t => this.once("ready", t))), e.then(() => {
            this.fire("destroy"), this.stopListening(), this.commands.destroy()
        }).then(() => this.plugins.destroy()).then(() => {
            this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy()
        }).then(() => this._context._removeEditor(this))
    }

    execute(e, ...t) {
        try {
            return this.commands.execute(e, ...t)
        } catch (i) {/* istanbul ignore next -- @preserve */
            p.rethrowUnexpectedError(i, this)
        }
    }

    focus() {
        this.editing.view.focus()
    }

    static create(...e) {
        throw new Error("This is an abstract method.")
    }

    static Context = Zl;
    static EditorWatchdog = af;
    static ContextWatchdog = Tv;

    _showLicenseError(e, t) {
        setTimeout(() => {
            if (e == "invalid") throw new p("invalid-license-key");
            if (e == "expired") throw new p("license-key-expired");
            if (e == "domainLimit") throw new p("license-key-domain-limit");
            if (e == "featureNotAllowed") throw new p("license-key-plugin-not-allowed", null, {pluginName: t});
            if (e == "evaluationLimit") throw new p("license-key-evaluation-limit");
            if (e == "trialLimit") throw new p("license-key-trial-limit");
            if (e == "developmentLimit") throw new p("license-key-development-limit");
            if (e == "usageLimit") throw new p("license-key-usage-limit");
            if (e == "distributionChannel") throw new p("license-key-invalid-distribution-channel")
        }, 0), this._showLicenseError = () => {
        }
    }

    async _sendUsageRequest(e, t) {
        const i = new Headers({"Content-Type": "application/json"}),
            n = await fetch(new URL(e), {method: "POST", headers: i, body: JSON.stringify(t)});
        if (!n.ok) throw new Error(`HTTP Response: ${n.status}`);
        return n.json()
    }
}

function Dv(s) {
    const e = Pv(s);

    function t(i, n) {
        if (Nt(e, i) !== void 0) throw new p("editor-usage-data-path-already-set", {path: i});
        Nd(e, i, n)
    }

    return s.fire("collectUsageData", {setUsageData: t}), e
}

function Nv(s) {
    if (!Rs(s.updateSourceElement)) throw new p("attachtoform-missing-elementapi-interface", s);
    const e = s.sourceElement;
    if (zv(e) && e.form) {
        let t;
        const i = e.form, n = () => s.updateSourceElement();
        Rs(i.submit) && (t = i.submit, i.submit = () => {
            n(), t.apply(i)
        }), i.addEventListener("submit", n), s.on("destroy", () => {
            i.removeEventListener("submit", n), t && (i.submit = t)
        })
    }
}

function zv(s) {
    return !!s && s.tagName.toLowerCase() === "textarea"
}

function _r(s) {
    class e extends s {
        sourceElement;

        updateSourceElement(i) {
            if (!this.sourceElement) throw new p("editor-missing-sourceelement", this);
            const n = this.config.get("updateSourceElementOnDestroy"),
                o = this.sourceElement instanceof HTMLTextAreaElement;
            if (!n && !o) {
                Ya(this.sourceElement, "");
                return
            }
            const r = typeof i == "string" ? i : this.data.get();
            Ya(this.sourceElement, r)
        }
    }

    return e
}

_r.updateSourceElement = _r(Object).prototype.updateSourceElement;

class Hi extends cf {
    _actions;

    static get pluginName() {
        return "PendingActions"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        this.set("hasAny", !1), this._actions = new ce({idProperty: "_id"}), this._actions.delegate("add", "remove").to(this)
    }

    add(e) {
        if (typeof e != "string") throw new p("pendingactions-add-invalid-message", this);
        const t = new (H());
        return t.set("message", e), this._actions.add(t), this.hasAny = !0, t
    }

    remove(e) {
        this._actions.remove(e), this.hasAny = !!this._actions.length
    }

    get first() {
        return this._actions.get(0)
    }

    [Symbol.iterator]() {
        return this._actions[Symbol.iterator]()
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class Hv extends H() {
    total;
    _reader;
    _data;

    constructor() {
        super();
        const e = new window.FileReader;
        this._reader = e, this._data = void 0, this.set("loaded", 0), e.onprogress = t => {
            this.loaded = t.loaded
        }
    }

    get error() {
        return this._reader.error
    }

    get data() {
        return this._data
    }

    read(e) {
        const t = this._reader;
        return this.total = e.size, new Promise((i, n) => {
            t.onload = () => {
                const o = t.result;
                this._data = o, i(o)
            }, t.onerror = () => {
                n("error")
            }, t.onabort = () => {
                n("aborted")
            }, this._reader.readAsDataURL(e)
        })
    }

    abort() {
        this._reader.abort()
    }
}

class Ft extends w {
    loaders = new ce;
    _loadersMap = new Map;
    _pendingAction = null;

    static get pluginName() {
        return "FileRepository"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Hi]
    }

    init() {
        this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (e, t) => t ? e / t * 100 : 0)
    }

    getLoader(e) {
        return this._loadersMap.get(e) || null
    }

    createLoader(e) {
        if (!this.createUploadAdapter) return L("filerepository-no-upload-adapter"), null;
        const t = new Ql(Promise.resolve(e), this.createUploadAdapter);
        return this.loaders.add(t), this._loadersMap.set(e, t), e instanceof Promise && t.file.then(i => {
            this._loadersMap.set(i, t)
        }).catch(() => {
        }), t.on("change:uploaded", () => {
            let i = 0;
            for (const n of this.loaders) i += n.uploaded;
            this.uploaded = i
        }), t.on("change:uploadTotal", () => {
            let i = 0;
            for (const n of this.loaders) n.uploadTotal && (i += n.uploadTotal);
            this.uploadTotal = i
        }), t
    }

    destroyLoader(e) {
        const t = e instanceof Ql ? e : this.getLoader(e);
        t._destroy(), this.loaders.remove(t), this._loadersMap.forEach((i, n) => {
            i === t && this._loadersMap.delete(n)
        })
    }

    _updatePendingAction() {
        const e = this.editor.plugins.get(Hi);
        if (this.loaders.length) {
            if (!this._pendingAction) {
                const t = this.editor.t, i = n => `${t("Upload in progress")} ${parseInt(n)}%.`;
                this._pendingAction = e.add(i(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", i)
            }
        } else e.remove(this._pendingAction), this._pendingAction = null
    }
}

class Ql extends H() {
    id;
    _filePromiseWrapper;
    _adapter;
    _reader;

    constructor(e, t) {
        super(), this.id = pe(), this._filePromiseWrapper = this._createFilePromiseWrapper(e), this._adapter = t(this), this._reader = new Hv, this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (i, n) => n ? i / n * 100 : 0), this.set("uploadResponse", null)
    }

    get file() {
        return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then(e => this._filePromiseWrapper ? e : null) : Promise.resolve(null)
    }

    get data() {
        return this._reader.data
    }

    read() {
        if (this.status != "idle") throw new p("filerepository-read-wrong-status", this);
        return this.status = "reading", this.file.then(e => this._reader.read(e)).then(e => {
            if (this.status !== "reading") throw this.status;
            return this.status = "idle", e
        }).catch(e => {
            throw e === "aborted" ? (this.status = "aborted", "aborted") : (this.status = "error", this._reader.error ? this._reader.error : e)
        })
    }

    upload() {
        if (this.status != "idle") throw new p("filerepository-upload-wrong-status", this);
        return this.status = "uploading", this.file.then(() => this._adapter.upload()).then(e => (this.uploadResponse = e, this.status = "idle", e)).catch(e => {
            throw this.status === "aborted" ? "aborted" : (this.status = "error", e)
        })
    }

    abort() {
        const e = this.status;
        this.status = "aborted", this._filePromiseWrapper.isFulfilled ? e == "reading" ? this._reader.abort() : e == "uploading" && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
        }), this._filePromiseWrapper.rejecter("aborted")), this._destroy()
    }

    _destroy() {
        this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0
    }

    _createFilePromiseWrapper(e) {
        const t = {};
        return t.promise = new Promise((i, n) => {
            t.rejecter = n, t.isFulfilled = !1, e.then(o => {
                t.isFulfilled = !0, i(o)
            }).catch(o => {
                t.isFulfilled = !0, n(o)
            })
        }), t
    }
}

class Uv extends w {
    static get requires() {
        return [Ft]
    }

    static get pluginName() {
        return "SimpleUploadAdapter"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor.config.get("simpleUpload");
        if (e) {
            if (!e.uploadUrl) {
                L("simple-upload-adapter-missing-uploadurl");
                return
            }
            this.editor.plugins.get(Ft).createUploadAdapter = t => new $v(t, e)
        }
    }
}

class $v {
    loader;
    options;
    xhr;

    constructor(e, t) {
        this.loader = e, this.options = t
    }

    upload() {
        return this.loader.file.then(e => new Promise((t, i) => {
            this._initRequest(), this._initListeners(t, i, e), this._sendRequest(e)
        }))
    }

    abort() {
        this.xhr && this.xhr.abort()
    }

    _initRequest() {
        const e = this.xhr = new XMLHttpRequest;
        e.open("POST", this.options.uploadUrl, !0), e.responseType = "json"
    }

    _initListeners(e, t, i) {
        const n = this.xhr, o = this.loader, r = `Couldn't upload file: ${i.name}.`;
        n.addEventListener("error", () => t(r)), n.addEventListener("abort", () => t()), n.addEventListener("load", () => {
            const a = n.response;
            if (!a || a.error) return t(a && a.error && a.error.message ? a.error.message : r);
            const l = a.url ? {default: a.url} : a.urls;
            e({...a, urls: l})
        });/* istanbul ignore else -- @preserve */
        n.upload && n.upload.addEventListener("progress", a => {
            a.lengthComputable && (o.uploadTotal = a.total, o.uploaded = a.loaded)
        })
    }

    _sendRequest(e) {
        let t = this.options.headers || {};
        typeof t == "function" && (t = t(e));
        const i = this.options.withCredentials || !1;
        for (const o of Object.keys(t)) this.xhr.setRequestHeader(o, t[o]);
        this.xhr.withCredentials = i;
        const n = new FormData;
        n.append("upload", e), this.xhr.send(n)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */var Yl = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 6.628a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"/><path d="M8.5 9.125a.3.3 0 0 0-.253-.296L5.11 8.327a.75.75 0 1 1 .388-1.449l4.04.716c.267.072.624.08.893.009l4.066-.724a.75.75 0 1 1 .388 1.45l-3.132.5a.3.3 0 0 0-.253.296v1.357a.3.3 0 0 0 .018.102l1.615 4.438a.75.75 0 0 1-1.41.513l-1.35-3.71a.3.3 0 0 0-.281-.197h-.209a.3.3 0 0 0-.282.198l-1.35 3.711a.75.75 0 0 1-1.41-.513l1.64-4.509a.3.3 0 0 0 .019-.103V9.125Z"/><path clip-rule="evenodd" d="M10 18.5a8.5 8.5 0 1 1 0-17 8.5 8.5 0 0 1 0 17Zm0 1.5c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10Z"/></svg>',
    Wv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',
    qv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
    uf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
    jv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',
    df = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
    Gv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>',
    hf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>',
    Kv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>',
    ff = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',
    Zv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>',
    Jv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>',
    Qv = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>',
    Yv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>',
    io = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>',
    vr = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>',
    Xl = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.87 13.786 1.532-1.286 3.857 4.596a1 1 0 1 1-1.532 1.286l-3.857-4.596z"/><path d="M16.004 8.5a6.5 6.5 0 0 1-9.216 5.905c-1.154-.53-.863-1.415-.663-1.615.194-.194.564-.592 1.635-.141a4.5 4.5 0 0 0 5.89-5.904l-.104-.227 1.332-1.331c.045-.046.196-.041.224.007a6.47 6.47 0 0 1 .902 3.306zm-3.4-5.715c.562.305.742 1.106.354 1.494-.388.388-.995.414-1.476.178a4.5 4.5 0 0 0-6.086 5.882l.114.236-1.348 1.349c-.038.037-.17.022-.198-.023a6.5 6.5 0 0 1 5.54-9.9 6.469 6.469 0 0 1 3.1.784z"/><path d="M4.001 11.93.948 8.877a.2.2 0 0 1 .141-.341h6.106a.2.2 0 0 1 .141.341L4.283 11.93a.2.2 0 0 1-.282 0zm11.083-6.789 3.053 3.053a.2.2 0 0 1-.14.342H11.89a.2.2 0 0 1-.14-.342l3.052-3.053a.2.2 0 0 1 .282 0z"/></svg>',
    Xv = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>',
    e1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>',
    ec = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.03 3h6.149a.75.75 0 1 1 0 1.5h-5.514L11.03 3zm1.27 3h4.879a.75.75 0 1 1 0 1.5h-4.244L12.3 6zm1.27 3h3.609a.75.75 0 1 1 0 1.5h-2.973L13.57 9zm-2.754 2.5L8.038 4.785 5.261 11.5h5.555zm.62 1.5H4.641l-1.666 4.028H1.312l5.789-14h1.875l5.789 14h-1.663L11.436 13z"/></svg>',
    tc = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>',
    t1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>',
    i1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.66 9.118a.693.693 0 0 1 .956.032l3.65 3.411 2.422-2.238a.695.695 0 0 1 .945 0L17.5 13.6V2.5h-15v11.1l4.16-4.482ZM17.8 1c.652 0 1.2.47 1.2 1.1v14.362c0 .64-.532 1.038-1.184 1.038H2.184C1.532 17.5 1 17.103 1 16.462V2.1C1 1.47 1.537 1 2.2 1h15.6Zm-5.655 6a2.128 2.128 0 0 1 .157-2.364A2.133 2.133 0 1 1 12.145 7Z"/></svg>',
    n1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h9.494a2.97 2.97 0 0 1-.414-.287 2.998 2.998 0 0 1-1.055-2.03 3.003 3.003 0 0 1 .693-2.185l.383-.455-.02.018-3.65-3.41a.695.695 0 0 0-.957-.034L1.5 13.6V2.5h15v5.535a2.97 2.97 0 0 1 1.412.932l.088.105V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.146 2.146 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.644-3.11 2.134 2.134 0 0 0-1.875-.978Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/></svg>',
    s1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h7.029a5.401 5.401 0 0 1 .615-4.338l.762-1.232-2.975-2.78a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v6.023c.449.131.887.32 1.307.573l.058.033c.046.028.09.057.135.086V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.15 2.15 0 0 0-1.611.834 2.118 2.118 0 0 0-.438 1.158 2.14 2.14 0 0 0 1.277 2.096 2.132 2.132 0 0 0 2.645-3.11 2.13 2.13 0 0 0-1.873-.978Z"/><path d="M16.63 10.294a3.003 3.003 0 0 0-4.142.887l-.117.177a.647.647 0 0 0-.096.492.664.664 0 0 0 .278.418.7.7 0 0 0 .944-.234 1.741 1.741 0 0 1 2.478-.463 1.869 1.869 0 0 1 .476 2.55.637.637 0 0 0-.071.5.646.646 0 0 0 .309.396.627.627 0 0 0 .869-.19l.027-.041a3.226 3.226 0 0 0-.956-4.492Zm-6.061 3.78-.044.066a3.228 3.228 0 0 0 .82 4.403 3.005 3.005 0 0 0 4.275-.798l.13-.197a.626.626 0 0 0 .092-.475.638.638 0 0 0-.268-.402.713.713 0 0 0-.99.26l-.018.029a1.741 1.741 0 0 1-2.477.461 1.87 1.87 0 0 1-.475-2.55l.029-.047a.647.647 0 0 0 .086-.485.66.66 0 0 0-.275-.408l-.04-.027a.609.609 0 0 0-.845.17Z"/><path d="M15.312 13.925c.24-.36.154-.838-.19-1.067-.346-.23-.82-.124-1.059.236l-1.268 1.907c-.239.36-.153.838.192 1.067.345.23.818.123 1.057-.236l1.268-1.907Z"/></svg>',
    o1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>',
    ic = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',
    r1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
    mf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>',
    a1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="m2.556 16.727.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415 1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5H8.245z"/></svg>',
    l1 = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>',
    c1 = '<svg viewBox="0 0 22 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.587 1.5c-.612 0-.601-.029-.601.551v14.84c0 .59-.01.559.591.559h18.846c.602 0 .591.03.591-.56V2.052c0-.58.01-.55-.591-.55H1.587Zm.701.971h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-14.24 1h13.008v12H4.467l.029-12Zm-2.208 1h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003v1H2.288v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h1.003l-.029 1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Zm-16.448 2h.974v1h-.974v-1Zm16.448 0h1.003v1h-1.003v-1Z"/><path d="M8.374 6.648a.399.399 0 0 1 .395-.4.402.402 0 0 1 .2.049l5.148 2.824a.4.4 0 0 1 0 .7l-5.148 2.824a.403.403 0 0 1-.595-.35V6.648Z"/></svg>',
    gf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>',
    u1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>',
    yr = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>',
    d1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>',
    pf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
    kr = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
    wf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
    bf = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
    _f = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
    h1 = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:v="https://vecta.io/nano" viewBox="0 0 20 20"><path d="M.95 1.43a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h.75v6.3H.95a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-.65h1.932l1.539-1.5H5v-.95a.95.95 0 0 0-.95-.95H3.2v-6.3h.85A.95.95 0 0 0 5 5.48v-.55h10v.55a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-3.1a.95.95 0 0 0-.95-.95h-3.1a.95.95 0 0 0-.95.95v1.05H5V2.38a.95.95 0 0 0-.95-.95H.95zm.55 3.5v-2h2v2h-2zm0 9.3v2h2v-2h-2zm15-11.3v2h2v-2h-2z"/><path d="M8.139 20.004v-2.388l7.045-7.048 2.391 2.391-7.046 7.046h-2.39zm11.421-9.101a.64.64 0 0 1-.138.206l-1.165 1.168-2.391-2.391 1.167-1.163a.63.63 0 0 1 .206-.138.635.635 0 0 1 .243-.049.63.63 0 0 1 .449.187l1.491 1.488c.059.059.108.129.138.206s.049.16.049.243a.6.6 0 0 1-.049.243z"/></svg>',
    f1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>',
    m1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M13 5.5H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2ZM13 7a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-8A.5.5 0 0 1 2 7h11Z"/></svg>',
    g1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M10 7.5H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2ZM10 9a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6A.5.5 0 0 1 2 9h8Z"/></svg>',
    p1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M7 9.5H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2ZM7 11a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4A.5.5 0 0 1 2 11h5Z"/></svg>',
    nc = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>',
    w1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>',
    b1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',
    _1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5 9.59 17h9.406v1.5H8.245z"/></svg>',
    v1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>',
    y1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>',
    Ht = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>',
    k1 = `<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>
`,
    C1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
    sc = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>',
    E1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>',
    T1 = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>',
    A1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
    x1 = `<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.734 6.375H1.75a.75.75 0 0 1 0-1.5h1.984a2.626 2.626 0 0 1 5.032 0h9.48a.75.75 0 0 1 0 1.5h-9.48a2.626 2.626 0 0 1-5.032 0Zm1.141-.75a1.375 1.375 0 1 1 2.75 0 1.375 1.375 0 0 1-2.75 0ZM16.263 14.625h1.983a.75.75 0 0 1 0 1.5h-1.983a2.626 2.626 0 0 1-5.033 0H1.75a.75.75 0 0 1 0-1.5h9.48a2.626 2.626 0 0 1 5.033 0Zm-1.142.75a1.375 1.375 0 1 1-2.75 0 1.375 1.375 0 0 1 2.75 0Z"/></svg>
`,
    I1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 0 5 4.5v15.003h-16V0h11zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692L3 1.5z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14l3.496-2.5zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22l-3.496 2.5zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0z"/></svg>',
    S1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>',
    P1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>',
    R1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>',
    V1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>',
    oc = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 5.5v3h4v-3H3Zm0 4v3h4v-3H3Zm0 4v3h4v-3H3Zm5 3h4v-3H8v3Zm5 0h4v-3h-4v3Zm4-4v-3h-4v3h4Zm0-4v-3h-4v3h4Zm1.5 8A1.5 1.5 0 0 1 17 18H3a1.5 1.5 0 0 1-1.5-1.5V3c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13.5Zm-6.5-4v-3H8v3h4Zm0-4v-3H8v3h4Z"/></svg>',
    O1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.035 1C2.446 1 2 1.54 2 2.098V10.5h1.5v-8h13v8H18V2.098C18 1.539 17.48 1 16.9 1H3.035Zm10.453 2.61a1.885 1.885 0 0 0-1.442.736 1.89 1.89 0 0 0 1.011 2.976 1.903 1.903 0 0 0 2.253-1.114 1.887 1.887 0 0 0-1.822-2.598ZM7.463 8.163a.611.611 0 0 0-.432.154L5.071 10.5h5.119L7.88 8.348a.628.628 0 0 0-.417-.185Zm6.236 1.059a.62.62 0 0 0-.42.164L12.07 10.5h2.969l-.92-1.113a.618.618 0 0 0-.42-.165ZM.91 11.5a.91.91 0 0 0-.91.912v6.877c0 .505.405.91.91.91h18.178a.91.91 0 0 0 .912-.91v-6.877a.908.908 0 0 0-.912-.912H.91ZM3.668 13h1.947l2.135 5.7H5.898l-.28-.946H3.601l-.278.945H1.516L3.668 13Zm4.947 0h1.801v4.3h2.7v1.4h-4.5V13h-.001Zm4.5 0h5.4v1.4h-1.798v4.3h-1.701v-4.3h-1.9V13h-.001Zm-8.517 1.457-.614 2.059h1.262l-.648-2.059Z"/></svg>',
    M1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>',
    fa = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>',
    B1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>',
    rc = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',
    F1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';

function vf(s) {
    return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s
}

var Po, ac;

function yf() {
    return ac || (ac = 1, Po = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
    }), Po
}

var L1 = yf();
const lc = vf(L1);
var cc = {red: 0, orange: 60, yellow: 120, green: 180, blue: 240, purple: 300};

function uc(s) {
    var e, t = [], i = 1, n;
    if (typeof s == "string") if (lc[s]) t = lc[s].slice(), n = "rgb"; else if (s === "transparent") i = 0, n = "rgb", t = [0, 0, 0]; else if (/^#[A-Fa-f0-9]+$/.test(s)) {
        var o = s.slice(1), r = o.length, a = r <= 4;
        i = 1, a ? (t = [parseInt(o[0] + o[0], 16), parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16)], r === 4 && (i = parseInt(o[3] + o[3], 16) / 255)) : (t = [parseInt(o[0] + o[1], 16), parseInt(o[2] + o[3], 16), parseInt(o[4] + o[5], 16)], r === 8 && (i = parseInt(o[6] + o[7], 16) / 255)), t[0] || (t[0] = 0), t[1] || (t[1] = 0), t[2] || (t[2] = 0), n = "rgb"
    } else if (e = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(s)) {
        var l = e[1], c = l === "rgb", o = l.replace(/a$/, "");
        n = o;
        var r = o === "cmyk" ? 4 : o === "gray" ? 1 : 3;
        t = e[2].trim().split(/\s*[,\/]\s*|\s+/).map(function (h, f) {
            if (/%$/.test(h)) return f === r ? parseFloat(h) / 100 : o === "rgb" ? parseFloat(h) * 255 / 100 : parseFloat(h);
            if (o[f] === "h") {
                if (/deg$/.test(h)) return parseFloat(h);
                if (cc[h] !== void 0) return cc[h]
            }
            return parseFloat(h)
        }), l === o && t.push(1), i = c || t[r] === void 0 ? 1 : t[r], t = t.slice(0, r)
    } else s.length > 10 && /[0-9](?:\s|\/)/.test(s) && (t = s.match(/([0-9]+)/g).map(function (u) {
        return parseFloat(u)
    }), n = s.match(/([a-z])/ig).join("").toLowerCase()); else isNaN(s) ? Array.isArray(s) || s.length ? (t = [s[0], s[1], s[2]], n = "rgb", i = s.length === 4 ? s[3] : 1) : s instanceof Object && (s.r != null || s.red != null || s.R != null ? (n = "rgb", t = [s.r || s.red || s.R || 0, s.g || s.green || s.G || 0, s.b || s.blue || s.B || 0]) : (n = "hsl", t = [s.h || s.hue || s.H || 0, s.s || s.saturation || s.S || 0, s.l || s.lightness || s.L || s.b || s.brightness]), i = s.a || s.alpha || s.opacity || 1, s.opacity != null && (i /= 100)) : (n = "rgb", t = [s >>> 16, (s & 65280) >>> 8, s & 255]);
    return {space: n, values: t, alpha: i}
}

var Ro, dc;

function kf() {
    if (dc) return Ro;
    dc = 1;
    const s = yf(), e = {};
    for (const n of Object.keys(s)) e[s[n]] = n;
    const t = {
        rgb: {channels: 3, labels: "rgb"},
        hsl: {channels: 3, labels: "hsl"},
        hsv: {channels: 3, labels: "hsv"},
        hwb: {channels: 3, labels: "hwb"},
        cmyk: {channels: 4, labels: "cmyk"},
        xyz: {channels: 3, labels: "xyz"},
        lab: {channels: 3, labels: "lab"},
        lch: {channels: 3, labels: "lch"},
        hex: {channels: 1, labels: ["hex"]},
        keyword: {channels: 1, labels: ["keyword"]},
        ansi16: {channels: 1, labels: ["ansi16"]},
        ansi256: {channels: 1, labels: ["ansi256"]},
        hcg: {channels: 3, labels: ["h", "c", "g"]},
        apple: {channels: 3, labels: ["r16", "g16", "b16"]},
        gray: {channels: 1, labels: ["gray"]}
    };
    Ro = t;
    for (const n of Object.keys(t)) {
        if (!("channels" in t[n])) throw new Error("missing channels property: " + n);
        if (!("labels" in t[n])) throw new Error("missing channel labels property: " + n);
        if (t[n].labels.length !== t[n].channels) throw new Error("channel and label counts mismatch: " + n);
        const {channels: o, labels: r} = t[n];
        delete t[n].channels, delete t[n].labels, Object.defineProperty(t[n], "channels", {value: o}), Object.defineProperty(t[n], "labels", {value: r})
    }
    t.rgb.hsl = function (n) {
        const o = n[0] / 255, r = n[1] / 255, a = n[2] / 255, l = Math.min(o, r, a), c = Math.max(o, r, a), u = c - l;
        let d, h;
        c === l ? d = 0 : o === c ? d = (r - a) / u : r === c ? d = 2 + (a - o) / u : a === c && (d = 4 + (o - r) / u), d = Math.min(d * 60, 360), d < 0 && (d += 360);
        const f = (l + c) / 2;
        return c === l ? h = 0 : f <= .5 ? h = u / (c + l) : h = u / (2 - c - l), [d, h * 100, f * 100]
    }, t.rgb.hsv = function (n) {
        let o, r, a, l, c;
        const u = n[0] / 255, d = n[1] / 255, h = n[2] / 255, f = Math.max(u, d, h), m = f - Math.min(u, d, h),
            g = function (_) {
                return (f - _) / 6 / m + 1 / 2
            };
        return m === 0 ? (l = 0, c = 0) : (c = m / f, o = g(u), r = g(d), a = g(h), u === f ? l = a - r : d === f ? l = 1 / 3 + o - a : h === f && (l = 2 / 3 + r - o), l < 0 ? l += 1 : l > 1 && (l -= 1)), [l * 360, c * 100, f * 100]
    }, t.rgb.hwb = function (n) {
        const o = n[0], r = n[1];
        let a = n[2];
        const l = t.rgb.hsl(n)[0], c = 1 / 255 * Math.min(o, Math.min(r, a));
        return a = 1 - 1 / 255 * Math.max(o, Math.max(r, a)), [l, c * 100, a * 100]
    }, t.rgb.cmyk = function (n) {
        const o = n[0] / 255, r = n[1] / 255, a = n[2] / 255, l = Math.min(1 - o, 1 - r, 1 - a),
            c = (1 - o - l) / (1 - l) || 0, u = (1 - r - l) / (1 - l) || 0, d = (1 - a - l) / (1 - l) || 0;
        return [c * 100, u * 100, d * 100, l * 100]
    };

    function i(n, o) {
        return (n[0] - o[0]) ** 2 + (n[1] - o[1]) ** 2 + (n[2] - o[2]) ** 2
    }

    return t.rgb.keyword = function (n) {
        const o = e[n];
        if (o) return o;
        let r = 1 / 0, a;
        for (const l of Object.keys(s)) {
            const c = s[l], u = i(n, c);
            u < r && (r = u, a = l)
        }
        return a
    }, t.keyword.rgb = function (n) {
        return s[n]
    }, t.rgb.xyz = function (n) {
        let o = n[0] / 255, r = n[1] / 255, a = n[2] / 255;
        o = o > .04045 ? ((o + .055) / 1.055) ** 2.4 : o / 12.92, r = r > .04045 ? ((r + .055) / 1.055) ** 2.4 : r / 12.92, a = a > .04045 ? ((a + .055) / 1.055) ** 2.4 : a / 12.92;
        const l = o * .4124 + r * .3576 + a * .1805, c = o * .2126 + r * .7152 + a * .0722,
            u = o * .0193 + r * .1192 + a * .9505;
        return [l * 100, c * 100, u * 100]
    }, t.rgb.lab = function (n) {
        const o = t.rgb.xyz(n);
        let r = o[0], a = o[1], l = o[2];
        r /= 95.047, a /= 100, l /= 108.883, r = r > .008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116, a = a > .008856 ? a ** (1 / 3) : 7.787 * a + 16 / 116, l = l > .008856 ? l ** (1 / 3) : 7.787 * l + 16 / 116;
        const c = 116 * a - 16, u = 500 * (r - a), d = 200 * (a - l);
        return [c, u, d]
    }, t.hsl.rgb = function (n) {
        const o = n[0] / 360, r = n[1] / 100, a = n[2] / 100;
        let l, c, u;
        if (r === 0) return u = a * 255, [u, u, u];
        a < .5 ? l = a * (1 + r) : l = a + r - a * r;
        const d = 2 * a - l, h = [0, 0, 0];
        for (let f = 0; f < 3; f++) c = o + 1 / 3 * -(f - 1), c < 0 && c++, c > 1 && c--, 6 * c < 1 ? u = d + (l - d) * 6 * c : 2 * c < 1 ? u = l : 3 * c < 2 ? u = d + (l - d) * (2 / 3 - c) * 6 : u = d, h[f] = u * 255;
        return h
    }, t.hsl.hsv = function (n) {
        const o = n[0];
        let r = n[1] / 100, a = n[2] / 100, l = r;
        const c = Math.max(a, .01);
        a *= 2, r *= a <= 1 ? a : 2 - a, l *= c <= 1 ? c : 2 - c;
        const u = (a + r) / 2, d = a === 0 ? 2 * l / (c + l) : 2 * r / (a + r);
        return [o, d * 100, u * 100]
    }, t.hsv.rgb = function (n) {
        const o = n[0] / 60, r = n[1] / 100;
        let a = n[2] / 100;
        const l = Math.floor(o) % 6, c = o - Math.floor(o), u = 255 * a * (1 - r), d = 255 * a * (1 - r * c),
            h = 255 * a * (1 - r * (1 - c));
        switch (a *= 255, l) {
            case 0:
                return [a, h, u];
            case 1:
                return [d, a, u];
            case 2:
                return [u, a, h];
            case 3:
                return [u, d, a];
            case 4:
                return [h, u, a];
            case 5:
                return [a, u, d]
        }
    }, t.hsv.hsl = function (n) {
        const o = n[0], r = n[1] / 100, a = n[2] / 100, l = Math.max(a, .01);
        let c, u;
        u = (2 - r) * a;
        const d = (2 - r) * l;
        return c = r * l, c /= d <= 1 ? d : 2 - d, c = c || 0, u /= 2, [o, c * 100, u * 100]
    }, t.hwb.rgb = function (n) {
        const o = n[0] / 360;
        let r = n[1] / 100, a = n[2] / 100;
        const l = r + a;
        let c;
        l > 1 && (r /= l, a /= l);
        const u = Math.floor(6 * o), d = 1 - a;
        c = 6 * o - u, (u & 1) !== 0 && (c = 1 - c);
        const h = r + c * (d - r);
        let f, m, g;
        switch (u) {
            default:
            case 6:
            case 0:
                f = d, m = h, g = r;
                break;
            case 1:
                f = h, m = d, g = r;
                break;
            case 2:
                f = r, m = d, g = h;
                break;
            case 3:
                f = r, m = h, g = d;
                break;
            case 4:
                f = h, m = r, g = d;
                break;
            case 5:
                f = d, m = r, g = h;
                break
        }
        return [f * 255, m * 255, g * 255]
    }, t.cmyk.rgb = function (n) {
        const o = n[0] / 100, r = n[1] / 100, a = n[2] / 100, l = n[3] / 100, c = 1 - Math.min(1, o * (1 - l) + l),
            u = 1 - Math.min(1, r * (1 - l) + l), d = 1 - Math.min(1, a * (1 - l) + l);
        return [c * 255, u * 255, d * 255]
    }, t.xyz.rgb = function (n) {
        const o = n[0] / 100, r = n[1] / 100, a = n[2] / 100;
        let l, c, u;
        return l = o * 3.2406 + r * -1.5372 + a * -.4986, c = o * -.9689 + r * 1.8758 + a * .0415, u = o * .0557 + r * -.204 + a * 1.057, l = l > .0031308 ? 1.055 * l ** (1 / 2.4) - .055 : l * 12.92, c = c > .0031308 ? 1.055 * c ** (1 / 2.4) - .055 : c * 12.92, u = u > .0031308 ? 1.055 * u ** (1 / 2.4) - .055 : u * 12.92, l = Math.min(Math.max(0, l), 1), c = Math.min(Math.max(0, c), 1), u = Math.min(Math.max(0, u), 1), [l * 255, c * 255, u * 255]
    }, t.xyz.lab = function (n) {
        let o = n[0], r = n[1], a = n[2];
        o /= 95.047, r /= 100, a /= 108.883, o = o > .008856 ? o ** (1 / 3) : 7.787 * o + 16 / 116, r = r > .008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116, a = a > .008856 ? a ** (1 / 3) : 7.787 * a + 16 / 116;
        const l = 116 * r - 16, c = 500 * (o - r), u = 200 * (r - a);
        return [l, c, u]
    }, t.lab.xyz = function (n) {
        const o = n[0], r = n[1], a = n[2];
        let l, c, u;
        c = (o + 16) / 116, l = r / 500 + c, u = c - a / 200;
        const d = c ** 3, h = l ** 3, f = u ** 3;
        return c = d > .008856 ? d : (c - 16 / 116) / 7.787, l = h > .008856 ? h : (l - 16 / 116) / 7.787, u = f > .008856 ? f : (u - 16 / 116) / 7.787, l *= 95.047, c *= 100, u *= 108.883, [l, c, u]
    }, t.lab.lch = function (n) {
        const o = n[0], r = n[1], a = n[2];
        let l;
        l = Math.atan2(a, r) * 360 / 2 / Math.PI, l < 0 && (l += 360);
        const u = Math.sqrt(r * r + a * a);
        return [o, u, l]
    }, t.lch.lab = function (n) {
        const o = n[0], r = n[1], l = n[2] / 360 * 2 * Math.PI, c = r * Math.cos(l), u = r * Math.sin(l);
        return [o, c, u]
    }, t.rgb.ansi16 = function (n, o = null) {
        const [r, a, l] = n;
        let c = o === null ? t.rgb.hsv(n)[2] : o;
        if (c = Math.round(c / 50), c === 0) return 30;
        let u = 30 + (Math.round(l / 255) << 2 | Math.round(a / 255) << 1 | Math.round(r / 255));
        return c === 2 && (u += 60), u
    }, t.hsv.ansi16 = function (n) {
        return t.rgb.ansi16(t.hsv.rgb(n), n[2])
    }, t.rgb.ansi256 = function (n) {
        const o = n[0], r = n[1], a = n[2];
        return o === r && r === a ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(a / 255 * 5)
    }, t.ansi16.rgb = function (n) {
        let o = n % 10;
        if (o === 0 || o === 7) return n > 50 && (o += 3.5), o = o / 10.5 * 255, [o, o, o];
        const r = (~~(n > 50) + 1) * .5, a = (o & 1) * r * 255, l = (o >> 1 & 1) * r * 255, c = (o >> 2 & 1) * r * 255;
        return [a, l, c]
    }, t.ansi256.rgb = function (n) {
        if (n >= 232) {
            const c = (n - 232) * 10 + 8;
            return [c, c, c]
        }
        n -= 16;
        let o;
        const r = Math.floor(n / 36) / 5 * 255, a = Math.floor((o = n % 36) / 6) / 5 * 255, l = o % 6 / 5 * 255;
        return [r, a, l]
    }, t.rgb.hex = function (n) {
        const r = (((Math.round(n[0]) & 255) << 16) + ((Math.round(n[1]) & 255) << 8) + (Math.round(n[2]) & 255)).toString(16).toUpperCase();
        return "000000".substring(r.length) + r
    }, t.hex.rgb = function (n) {
        const o = n.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!o) return [0, 0, 0];
        let r = o[0];
        o[0].length === 3 && (r = r.split("").map(d => d + d).join(""));
        const a = parseInt(r, 16), l = a >> 16 & 255, c = a >> 8 & 255, u = a & 255;
        return [l, c, u]
    }, t.rgb.hcg = function (n) {
        const o = n[0] / 255, r = n[1] / 255, a = n[2] / 255, l = Math.max(Math.max(o, r), a),
            c = Math.min(Math.min(o, r), a), u = l - c;
        let d, h;
        return u < 1 ? d = c / (1 - u) : d = 0, u <= 0 ? h = 0 : l === o ? h = (r - a) / u % 6 : l === r ? h = 2 + (a - o) / u : h = 4 + (o - r) / u, h /= 6, h %= 1, [h * 360, u * 100, d * 100]
    }, t.hsl.hcg = function (n) {
        const o = n[1] / 100, r = n[2] / 100, a = r < .5 ? 2 * o * r : 2 * o * (1 - r);
        let l = 0;
        return a < 1 && (l = (r - .5 * a) / (1 - a)), [n[0], a * 100, l * 100]
    }, t.hsv.hcg = function (n) {
        const o = n[1] / 100, r = n[2] / 100, a = o * r;
        let l = 0;
        return a < 1 && (l = (r - a) / (1 - a)), [n[0], a * 100, l * 100]
    }, t.hcg.rgb = function (n) {
        const o = n[0] / 360, r = n[1] / 100, a = n[2] / 100;
        if (r === 0) return [a * 255, a * 255, a * 255];
        const l = [0, 0, 0], c = o % 1 * 6, u = c % 1, d = 1 - u;
        let h = 0;
        switch (Math.floor(c)) {
            case 0:
                l[0] = 1, l[1] = u, l[2] = 0;
                break;
            case 1:
                l[0] = d, l[1] = 1, l[2] = 0;
                break;
            case 2:
                l[0] = 0, l[1] = 1, l[2] = u;
                break;
            case 3:
                l[0] = 0, l[1] = d, l[2] = 1;
                break;
            case 4:
                l[0] = u, l[1] = 0, l[2] = 1;
                break;
            default:
                l[0] = 1, l[1] = 0, l[2] = d
        }
        return h = (1 - r) * a, [(r * l[0] + h) * 255, (r * l[1] + h) * 255, (r * l[2] + h) * 255]
    }, t.hcg.hsv = function (n) {
        const o = n[1] / 100, r = n[2] / 100, a = o + r * (1 - o);
        let l = 0;
        return a > 0 && (l = o / a), [n[0], l * 100, a * 100]
    }, t.hcg.hsl = function (n) {
        const o = n[1] / 100, a = n[2] / 100 * (1 - o) + .5 * o;
        let l = 0;
        return a > 0 && a < .5 ? l = o / (2 * a) : a >= .5 && a < 1 && (l = o / (2 * (1 - a))), [n[0], l * 100, a * 100]
    }, t.hcg.hwb = function (n) {
        const o = n[1] / 100, r = n[2] / 100, a = o + r * (1 - o);
        return [n[0], (a - o) * 100, (1 - a) * 100]
    }, t.hwb.hcg = function (n) {
        const o = n[1] / 100, a = 1 - n[2] / 100, l = a - o;
        let c = 0;
        return l < 1 && (c = (a - l) / (1 - l)), [n[0], l * 100, c * 100]
    }, t.apple.rgb = function (n) {
        return [n[0] / 65535 * 255, n[1] / 65535 * 255, n[2] / 65535 * 255]
    }, t.rgb.apple = function (n) {
        return [n[0] / 255 * 65535, n[1] / 255 * 65535, n[2] / 255 * 65535]
    }, t.gray.rgb = function (n) {
        return [n[0] / 100 * 255, n[0] / 100 * 255, n[0] / 100 * 255]
    }, t.gray.hsl = function (n) {
        return [0, 0, n[0]]
    }, t.gray.hsv = t.gray.hsl, t.gray.hwb = function (n) {
        return [0, 100, n[0]]
    }, t.gray.cmyk = function (n) {
        return [0, 0, 0, n[0]]
    }, t.gray.lab = function (n) {
        return [n[0], 0, 0]
    }, t.gray.hex = function (n) {
        const o = Math.round(n[0] / 100 * 255) & 255, a = ((o << 16) + (o << 8) + o).toString(16).toUpperCase();
        return "000000".substring(a.length) + a
    }, t.rgb.gray = function (n) {
        return [(n[0] + n[1] + n[2]) / 3 / 255 * 100]
    }, Ro
}

var Vo, hc;

function D1() {
    if (hc) return Vo;
    hc = 1;
    const s = kf();

    function e() {
        const o = {}, r = Object.keys(s);
        for (let a = r.length, l = 0; l < a; l++) o[r[l]] = {distance: -1, parent: null};
        return o
    }

    function t(o) {
        const r = e(), a = [o];
        for (r[o].distance = 0; a.length;) {
            const l = a.pop(), c = Object.keys(s[l]);
            for (let u = c.length, d = 0; d < u; d++) {
                const h = c[d], f = r[h];
                f.distance === -1 && (f.distance = r[l].distance + 1, f.parent = l, a.unshift(h))
            }
        }
        return r
    }

    function i(o, r) {
        return function (a) {
            return r(o(a))
        }
    }

    function n(o, r) {
        const a = [r[o].parent, o];
        let l = s[r[o].parent][o], c = r[o].parent;
        for (; r[c].parent;) a.unshift(r[c].parent), l = i(s[r[c].parent][c], l), c = r[c].parent;
        return l.conversion = a, l
    }

    return Vo = function (o) {
        const r = t(o), a = {}, l = Object.keys(r);
        for (let c = l.length, u = 0; u < c; u++) {
            const d = l[u];
            r[d].parent !== null && (a[d] = n(d, r))
        }
        return a
    }, Vo
}

var Oo, fc;

function N1() {
    if (fc) return Oo;
    fc = 1;
    const s = kf(), e = D1(), t = {}, i = Object.keys(s);

    function n(r) {
        const a = function (...l) {
            const c = l[0];
            return c == null ? c : (c.length > 1 && (l = c), r(l))
        };
        return "conversion" in r && (a.conversion = r.conversion), a
    }

    function o(r) {
        const a = function (...l) {
            const c = l[0];
            if (c == null) return c;
            c.length > 1 && (l = c);
            const u = r(l);
            if (typeof u == "object") for (let d = u.length, h = 0; h < d; h++) u[h] = Math.round(u[h]);
            return u
        };
        return "conversion" in r && (a.conversion = r.conversion), a
    }

    return i.forEach(r => {
        t[r] = {}, Object.defineProperty(t[r], "channels", {value: s[r].channels}), Object.defineProperty(t[r], "labels", {value: s[r].labels});
        const a = e(r);
        Object.keys(a).forEach(c => {
            const u = a[c];
            t[r][c] = o(u), t[r][c].raw = n(u)
        })
    }), Oo = t, Oo
}

var Cf = N1();
const z1 = vf(Cf), Ef = Ag({__proto__: null, default: z1}, [Cf]), On = (s, e = 0, t = 1) => s > t ? t : s < e ? e : s,
    me = (s, e = 0, t = Math.pow(10, e)) => Math.round(t * s) / t, H1 = s => j1(Cr(s)),
    Cr = s => (s[0] === "#" && (s = s.substring(1)), s.length < 6 ? {
        r: parseInt(s[0] + s[0], 16),
        g: parseInt(s[1] + s[1], 16),
        b: parseInt(s[2] + s[2], 16),
        a: s.length === 4 ? me(parseInt(s[3] + s[3], 16) / 255, 2) : 1
    } : {
        r: parseInt(s.substring(0, 2), 16),
        g: parseInt(s.substring(2, 4), 16),
        b: parseInt(s.substring(4, 6), 16),
        a: s.length === 8 ? me(parseInt(s.substring(6, 8), 16) / 255, 2) : 1
    }), U1 = s => q1(W1(s)), $1 = ({h: s, s: e, v: t, a: i}) => {
        const n = (200 - e) * t / 100;
        return {
            h: me(s),
            s: me(n > 0 && n < 200 ? e * t / 100 / (n <= 100 ? n : 200 - n) * 100 : 0),
            l: me(n / 2),
            a: me(i, 2)
        }
    }, Er = s => {
        const {h: e, s: t, l: i} = $1(s);
        return `hsl(${e}, ${t}%, ${i}%)`
    }, W1 = ({h: s, s: e, v: t, a: i}) => {
        s = s / 360 * 6, e = e / 100, t = t / 100;
        const n = Math.floor(s), o = t * (1 - e), r = t * (1 - (s - n) * e), a = t * (1 - (1 - s + n) * e), l = n % 6;
        return {
            r: me([t, r, o, o, a, t][l] * 255),
            g: me([a, t, t, r, o, o][l] * 255),
            b: me([o, o, a, t, t, r][l] * 255),
            a: me(i, 2)
        }
    }, is = s => {
        const e = s.toString(16);
        return e.length < 2 ? "0" + e : e
    }, q1 = ({r: s, g: e, b: t, a: i}) => {
        const n = i < 1 ? is(me(i * 255)) : "";
        return "#" + is(s) + is(e) + is(t) + n
    }, j1 = ({r: s, g: e, b: t, a: i}) => {
        const n = Math.max(s, e, t), o = n - Math.min(s, e, t),
            r = o ? n === s ? (e - t) / o : n === e ? 2 + (t - s) / o : 4 + (s - e) / o : 0;
        return {h: me(60 * (r < 0 ? r + 6 : r)), s: me(n ? o / n * 100 : 0), v: me(n / 255 * 100), a: i}
    }, Tf = (s, e) => {
        if (s === e) return !0;
        for (const t in s) if (s[t] !== e[t]) return !1;
        return !0
    }, G1 = (s, e) => s.toLowerCase() === e.toLowerCase() ? !0 : Tf(Cr(s), Cr(e)), mc = {}, Af = s => {
        let e = mc[s];
        return e || (e = document.createElement("template"), e.innerHTML = s, mc[s] = e), e
    }, ma = (s, e, t) => {
        s.dispatchEvent(new CustomEvent(e, {bubbles: !0, detail: t}))
    };
let Di = !1;
const Tr = s => "touches" in s, K1 = s => Di && !Tr(s) ? !1 : (Di || (Di = Tr(s)), !0), gc = (s, e) => {
    const t = Tr(e) ? e.touches[0] : e, i = s.el.getBoundingClientRect();
    ma(s.el, "move", s.getMove({
        x: On((t.pageX - (i.left + window.pageXOffset)) / i.width),
        y: On((t.pageY - (i.top + window.pageYOffset)) / i.height)
    }))
}, Z1 = (s, e) => {
    const t = e.keyCode;
    t > 40 || s.xy && t < 37 || t < 33 || (e.preventDefault(), ma(s.el, "move", s.getMove({
        x: t === 39 ? .01 : t === 37 ? -.01 : t === 34 ? .05 : t === 33 ? -.05 : t === 35 ? 1 : t === 36 ? -1 : 0,
        y: t === 40 ? .01 : t === 38 ? -.01 : 0
    }, !0)))
};

class xf {
    constructor(e, t, i, n) {
        const o = Af(`<div role="slider" tabindex="0" part="${t}" ${i}><div part="${t}-pointer"></div></div>`);
        e.appendChild(o.content.cloneNode(!0));
        const r = e.querySelector(`[part=${t}]`);
        r.addEventListener("mousedown", this), r.addEventListener("touchstart", this), r.addEventListener("keydown", this), this.el = r, this.xy = n, this.nodes = [r.firstChild, r]
    }

    set dragging(e) {
        const t = e ? document.addEventListener : document.removeEventListener;
        t(Di ? "touchmove" : "mousemove", this), t(Di ? "touchend" : "mouseup", this)
    }

    handleEvent(e) {
        switch (e.type) {
            case"mousedown":
            case"touchstart":
                if (e.preventDefault(), !K1(e) || !Di && e.button != 0) return;
                this.el.focus(), gc(this, e), this.dragging = !0;
                break;
            case"mousemove":
            case"touchmove":
                e.preventDefault(), gc(this, e);
                break;
            case"mouseup":
            case"touchend":
                this.dragging = !1;
                break;
            case"keydown":
                Z1(this, e);
                break
        }
    }

    style(e) {
        e.forEach((t, i) => {
            for (const n in t) this.nodes[i].style.setProperty(n, t[n])
        })
    }
}

class J1 extends xf {
    constructor(e) {
        super(e, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', !1)
    }

    update({h: e}) {
        this.h = e, this.style([{
            left: `${e / 360 * 100}%`,
            color: Er({h: e, s: 100, v: 100, a: 1})
        }]), this.el.setAttribute("aria-valuenow", `${me(e)}`)
    }

    getMove(e, t) {
        return {h: t ? On(this.h + e.x * 360, 0, 360) : 360 * e.x}
    }
}

class Q1 extends xf {
    constructor(e) {
        super(e, "saturation", 'aria-label="Color"', !0)
    }

    update(e) {
        this.hsva = e, this.style([{
            top: `${100 - e.v}%`,
            left: `${e.s}%`,
            color: Er(e)
        }, {
            "background-color": Er({
                h: e.h,
                s: 100,
                v: 100,
                a: 1
            })
        }]), this.el.setAttribute("aria-valuetext", `Saturation ${me(e.s)}%, Brightness ${me(e.v)}%`)
    }

    getMove(e, t) {
        return {
            s: t ? On(this.hsva.s + e.x * 100, 0, 100) : e.x * 100,
            v: t ? On(this.hsva.v - e.y * 100, 0, 100) : Math.round(100 - e.y * 100)
        }
    }
}

const Y1 = ':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}',
    X1 = "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}",
    ey = "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}",
    ns = Symbol("same"), Mo = Symbol("color"), pc = Symbol("hsva"), Bo = Symbol("update"), wc = Symbol("parts"),
    bc = Symbol("css"), _c = Symbol("sliders");

class ty extends HTMLElement {
    static get observedAttributes() {
        return ["color"]
    }

    get [bc]() {
        return [Y1, X1, ey]
    }

    get [_c]() {
        return [Q1, J1]
    }

    get color() {
        return this[Mo]
    }

    set color(e) {
        if (!this[ns](e)) {
            const t = this.colorModel.toHsva(e);
            this[Bo](t), this[Mo] = e
        }
    }

    constructor() {
        super();
        const e = Af(`<style>${this[bc].join("")}</style>`), t = this.attachShadow({mode: "open"});
        t.appendChild(e.content.cloneNode(!0)), t.addEventListener("move", this), this[wc] = this[_c].map(i => new i(t))
    }

    connectedCallback() {
        if (this.hasOwnProperty("color")) {
            const e = this.color;
            delete this.color, this.color = e
        } else this.color || (this.color = this.colorModel.defaultColor)
    }

    attributeChangedCallback(e, t, i) {
        const n = this.colorModel.fromAttr(i);
        this[ns](n) || (this.color = n)
    }

    handleEvent(e) {
        const t = this[pc], i = {...t, ...e.detail};
        this[Bo](i);
        let n;
        !Tf(i, t) && !this[ns](n = this.colorModel.fromHsva(i)) && (this[Mo] = n, ma(this, "color-changed", {value: n}))
    }

    [ns](e) {
        return this.color && this.colorModel.equal(e, this.color)
    }

    [Bo](e) {
        this[pc] = e, this[wc].forEach(t => t.update(e))
    }
}

const iy = {
    defaultColor: "#000",
    toHsva: H1,
    fromHsva: ({h: s, s: e, v: t}) => U1({h: s, s: e, v: t, a: 1}),
    equal: G1,
    fromAttr: s => s
};

class ny extends ty {
    get colorModel() {
        return iy
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class Ie extends ce {
    _parentElement;

    constructor(e = []) {
        super(e, {idProperty: "viewUid"}), this.on("add", (t, i, n) => {
            this._renderViewIntoCollectionParent(i, n)
        }), this.on("remove", (t, i) => {
            i.element && this._parentElement && i.element.remove()
        }), this._parentElement = null
    }

    destroy() {
        this.map(e => e.destroy())
    }

    setParent(e) {
        this._parentElement = e;
        for (const t of this) this._renderViewIntoCollectionParent(t)
    }

    delegate(...e) {
        if (!e.length || !sy(e)) throw new p("ui-viewcollection-delegate-wrong-events", this);
        return {
            to: t => {
                for (const i of this) for (const n of e) i.delegate(n).to(t);
                this.on("add", (i, n) => {
                    for (const o of e) n.delegate(o).to(t)
                }), this.on("remove", (i, n) => {
                    for (const o of e) n.stopDelegating(o, t)
                })
            }
        }
    }

    _renderViewIntoCollectionParent(e, t) {
        e.isRendered || e.render(), e.element && this._parentElement && this._parentElement.insertBefore(e.element, this._parentElement.children[t])
    }

    remove(e) {
        return super.remove(e)
    }
}

function sy(s) {
    return s.every(e => typeof e == "string")
}

const oy = "http://www.w3.org/1999/xhtml";

class Te extends W() {
    ns;
    tag;
    text;
    attributes;
    children;
    eventListeners;
    _isRendered;
    _revertData;

    constructor(e) {
        super(), Object.assign(this, yc(vc(e))), this._isRendered = !1, this._revertData = null
    }

    render() {
        const e = this._renderNode({intoFragment: !0});
        return this._isRendered = !0, e
    }

    apply(e) {
        return this._revertData = Ec(), this._renderNode({
            node: e,
            intoFragment: !1,
            isApplying: !0,
            revertData: this._revertData
        }), e
    }

    revert(e) {
        if (!this._revertData) throw new p("ui-template-revert-not-applied", [this, e]);
        this._revertTemplateFromNode(e, this._revertData)
    }

    * getViews() {
        function* e(t) {
            if (t.children) for (const i of t.children) zs(i) ? yield i : ga(i) && (yield* e(i))
        }

        yield* e(this)
    }

    static bind(e, t) {
        return {
            to(i, n) {
                return new ry({eventNameOrFunction: i, attribute: i, observable: e, emitter: t, callback: n})
            }, if(i, n, o) {
                return new If({observable: e, emitter: t, attribute: i, valueIfTrue: n, callback: o})
            }
        }
    }

    static extend(e, t) {
        if (e._isRendered) throw new p("template-extend-render", [this, e]);
        Vf(e, yc(vc(t)))
    }

    _renderNode(e) {
        let t;
        if (e.node ? t = this.tag && this.text : t = this.tag ? this.text : !this.text, t) throw new p("ui-template-wrong-syntax", this);
        return this.text ? this._renderText(e) : this._renderElement(e)
    }

    _renderElement(e) {
        let t = e.node;
        return t || (t = e.node = document.createElementNS(this.ns || oy, this.tag)), this._renderAttributes(e), this._renderElementChildren(e), this._setUpListeners(e), t
    }

    _renderText(e) {
        let t = e.node;
        return t ? e.revertData.text = t.textContent : t = e.node = document.createTextNode(""), vs(this.text) ? this._bindToObservable({
            schema: this.text,
            updater: ly(t),
            data: e
        }) : t.textContent = this.text.join(""), t
    }

    _renderAttributes(e) {
        if (!this.attributes) return;
        const t = e.node, i = e.revertData;
        for (const n in this.attributes) {
            const o = t.getAttribute(n), r = this.attributes[n];
            i && (i.attributes[n] = o);
            const a = Cc(r) ? r[0].ns : null;
            if (vs(r)) {
                const l = Cc(r) ? r[0].value : r;
                i && Tc(n) && l.unshift(o), this._bindToObservable({schema: l, updater: cy(t, n, a), data: e})
            } else if (n == "style" && typeof r[0] != "string") this._renderStyleAttribute(r[0], e); else {
                i && o && Tc(n) && r.unshift(o);
                const l = r.map(c => c && (c.value || c)).reduce((c, u) => c.concat(u), []).reduce(Rf, "");
                Ui(l) || t.setAttributeNS(a, n, l)
            }
        }
    }

    _renderStyleAttribute(e, t) {
        const i = t.node;
        for (const n in e) {
            const o = e[n];
            vs(o) ? this._bindToObservable({schema: [o], updater: uy(i, n), data: t}) : i.style[n] = o
        }
    }

    _renderElementChildren(e) {
        const t = e.node, i = e.intoFragment ? document.createDocumentFragment() : t, n = e.isApplying;
        let o = 0;
        for (const r of this.children) if (pa(r)) {
            if (!n) {
                r.setParent(t);
                for (const a of r) i.appendChild(a.element)
            }
        } else if (zs(r)) n || (r.isRendered || r.render(), i.appendChild(r.element)); else if (zt(r)) i.appendChild(r); else if (n) {
            const a = e.revertData, l = Ec();
            a.children.push(l), r._renderNode({
                intoFragment: !1,
                node: i.childNodes[o++],
                isApplying: !0,
                revertData: l
            })
        } else i.appendChild(r.render());
        e.intoFragment && t.appendChild(i)
    }

    _setUpListeners(e) {
        if (this.eventListeners) for (const t in this.eventListeners) {
            const i = this.eventListeners[t].map(n => {
                const [o, r] = t.split("@");
                return n.activateDomEventListener(o, r, e)
            });
            e.revertData && e.revertData.bindings.push(i)
        }
    }

    _bindToObservable({schema: e, updater: t, data: i}) {
        const n = i.revertData;
        Sf(e, t, i);
        const o = e.filter(r => !Ui(r)).filter(r => r.observable).map(r => r.activateAttributeListener(e, t, i));
        n && n.bindings.push(o)
    }

    _revertTemplateFromNode(e, t) {
        for (const n of t.bindings) for (const o of n) o();
        if (t.text) {
            e.textContent = t.text;
            return
        }
        const i = e;
        for (const n in t.attributes) {
            const o = t.attributes[n];
            o === null ? i.removeAttribute(n) : i.setAttribute(n, o)
        }
        for (let n = 0; n < t.children.length; ++n) this._revertTemplateFromNode(i.childNodes[n], t.children[n])
    }
}

class Un {
    attribute;
    observable;
    emitter;
    callback;

    constructor(e) {
        this.attribute = e.attribute, this.observable = e.observable, this.emitter = e.emitter, this.callback = e.callback
    }

    getValue(e) {
        const t = this.observable[this.attribute];
        return this.callback ? this.callback(t, e) : t
    }

    activateAttributeListener(e, t, i) {
        const n = () => Sf(e, t, i);
        return this.emitter.listenTo(this.observable, `change:${this.attribute}`, n), () => {
            this.emitter.stopListening(this.observable, `change:${this.attribute}`, n)
        }
    }
}

class ry extends Un {
    eventNameOrFunction;

    constructor(e) {
        super(e), this.eventNameOrFunction = e.eventNameOrFunction
    }

    activateDomEventListener(e, t, i) {
        const n = (o, r) => {
            (!t || r.target.matches(t)) && (typeof this.eventNameOrFunction == "function" ? this.eventNameOrFunction(r) : this.observable.fire(this.eventNameOrFunction, r))
        };
        return this.emitter.listenTo(i.node, e, n), () => {
            this.emitter.stopListening(i.node, e, n)
        }
    }
}

class If extends Un {
    valueIfTrue;

    constructor(e) {
        super(e), this.valueIfTrue = e.valueIfTrue
    }

    getValue(e) {
        const t = super.getValue(e);
        return Ui(t) ? !1 : this.valueIfTrue || !0
    }
}

function vs(s) {
    return s ? (s.value && (s = s.value), Array.isArray(s) ? s.some(vs) : s instanceof Un) : !1
}

function ay(s, e) {
    return s.map(t => t instanceof Un ? t.getValue(e) : t)
}

function Sf(s, e, {node: t}) {
    const i = ay(s, t);
    let n;
    s.length == 1 && s[0] instanceof If ? n = i[0] : n = i.reduce(Rf, ""), Ui(n) ? e.remove() : e.set(n)
}

function ly(s) {
    return {
        set(e) {
            s.textContent = e
        }, remove() {
            s.textContent = ""
        }
    }
}

function cy(s, e, t) {
    return {
        set(i) {
            s.setAttributeNS(t, e, i)
        }, remove() {
            s.removeAttributeNS(t, e)
        }
    }
}

function uy(s, e) {
    return {
        set(t) {
            s.style[e] = t
        }, remove() {
            s.style[e] = null
        }
    }
}

function vc(s) {
    return Ks(s, t => {
        if (t && (t instanceof Un || ga(t) || zs(t) || pa(t))) return t
    })
}

function yc(s) {
    if (typeof s == "string" ? s = fy(s) : s.text && my(s), s.on && (s.eventListeners = hy(s.on), delete s.on), !s.text) {
        s.attributes && dy(s.attributes);
        const e = [];
        if (s.children) if (pa(s.children)) e.push(s.children); else for (const t of s.children) ga(t) || zs(t) || zt(t) ? e.push(t) : e.push(new Te(t));
        s.children = e
    }
    return s
}

function dy(s) {
    for (const e in s) s[e].value && (s[e].value = U(s[e].value)), Pf(s, e)
}

function hy(s) {
    for (const e in s) Pf(s, e);
    return s
}

function fy(s) {
    return {text: [s]}
}

function my(s) {
    s.text = U(s.text)
}

function Pf(s, e) {
    s[e] = U(s[e])
}

function Rf(s, e) {
    return Ui(e) ? s : Ui(s) ? e : `${s} ${e}`
}

function kc(s, e) {
    for (const t in e) s[t] ? s[t].push(...e[t]) : s[t] = e[t]
}

function Vf(s, e) {
    if (e.attributes && (s.attributes || (s.attributes = {}), kc(s.attributes, e.attributes)), e.eventListeners && (s.eventListeners || (s.eventListeners = {}), kc(s.eventListeners, e.eventListeners)), e.text && s.text.push(...e.text), e.children && e.children.length) {
        if (s.children.length != e.children.length) throw new p("ui-template-extend-children-mismatch", s);
        let t = 0;
        for (const i of e.children) Vf(s.children[t++], i)
    }
}

function Ui(s) {
    return !s && s !== 0
}

function zs(s) {
    return s instanceof T
}

function ga(s) {
    return s instanceof Te
}

function pa(s) {
    return s instanceof Ie
}

function Cc(s) {
    return tt(s[0]) && s[0].ns
}

function Ec() {
    return {children: [], bindings: [], attributes: {}}
}

function Tc(s) {
    return s == "class" || s == "style"
}

class T extends xe(H()) {
    element;
    isRendered;
    locale;
    t;
    template;
    _viewCollections;
    _unboundChildren;
    _bindTemplate;

    constructor(e) {
        super(), this.element = null, this.isRendered = !1, this.locale = e, this.t = e && e.t, this._viewCollections = new ce, this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (t, i) => {
            i.locale = e, i.t = e && e.t
        }), this.decorate("render")
    }

    get bindTemplate() {
        return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Te.bind(this, this)
    }

    createCollection(e) {
        const t = new Ie(e);
        return this._viewCollections.add(t), t
    }

    registerChild(e) {
        ze(e) || (e = [e]);
        for (const t of e) this._unboundChildren.add(t)
    }

    deregisterChild(e) {
        ze(e) || (e = [e]);
        for (const t of e) this._unboundChildren.remove(t)
    }

    setTemplate(e) {
        this.template = new Te(e)
    }

    extendTemplate(e) {
        Te.extend(this.template, e)
    }

    render() {
        if (this.isRendered) throw new p("ui-view-render-already-rendered", this);
        this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = !0
    }

    destroy() {
        this.stopListening(), this._viewCollections.map(e => e.destroy()), this.template && this.template._revertData && this.template.revert(this.element)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Ji({emitter: s, activator: e, callback: t, contextElements: i, listenerOptions: n}) {
    s.listenTo(document, "mousedown", (o, r) => {
        if (!e()) return;
        const a = typeof r.composedPath == "function" ? r.composedPath() : [], l = typeof i == "function" ? i() : i;
        for (const c of l) if (c.contains(r.target) || a.includes(c)) return;
        t()
    }, n)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function $i(s) {
    class e extends s {
        disableCssTransitions() {
            this._isCssTransitionsDisabled = !0
        }

        enableCssTransitions() {
            this._isCssTransitionsDisabled = !1
        }

        constructor(...i) {
            super(...i), this.set("_isCssTransitionsDisabled", !1), this.initializeCssTransitionDisablerMixin()
        }

        initializeCssTransitionDisablerMixin() {
            this.extendTemplate({attributes: {class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")]}})
        }
    }

    return e
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function li({view: s}) {
    s.listenTo(s.element, "submit", (e, t) => {
        t.preventDefault(), s.fire("submit")
    }, {useCapture: !0})
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Of({keystrokeHandler: s, focusTracker: e, gridItems: t, numberOfColumns: i, uiLanguageDirection: n}) {
    const o = typeof i == "number" ? () => i : i;
    s.set("arrowright", r((c, u) => n === "rtl" ? l(c, u.length) : a(c, u.length))), s.set("arrowleft", r((c, u) => n === "rtl" ? a(c, u.length) : l(c, u.length))), s.set("arrowup", r((c, u) => {
        let d = c - o();
        return d < 0 && (d = c + o() * Math.floor(u.length / o()), d > u.length - 1 && (d -= o())), d
    })), s.set("arrowdown", r((c, u) => {
        let d = c + o();
        return d > u.length - 1 && (d = c % o()), d
    }));

    function r(c) {
        return u => {
            const d = t.find(m => m.element === e.focusedElement), h = t.getIndex(d), f = c(h, t);
            t.get(f).focus(), u.stopPropagation(), u.preventDefault()
        }
    }

    function a(c, u) {
        return c === u - 1 ? 0 : c + 1
    }

    function l(c, u) {
        return c === 0 ? u - 1 : c - 1
    }
}

class ot extends T {
    static presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];

    constructor() {
        super();
        const e = this.bindTemplate;
        this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", !0), this.set("isVisible", !0), this.setTemplate({
            tag: "svg",
            ns: "http://www.w3.org/2000/svg",
            attributes: {
                class: ["ck", "ck-icon", e.if("isVisible", "ck-hidden", t => !t), "ck-reset_all-excluded", e.if("isColorInherited", "ck-icon_inherit-color")],
                viewBox: e.to("viewBox"),
                "aria-hidden": !0
            }
        })
    }

    render() {
        super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
            this._updateXMLContent(), this._colorFillPaths()
        }), this.on("change:fillColor", () => {
            this._colorFillPaths()
        })
    }

    _updateXMLContent() {
        if (this.content) {
            const t = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg");
            if (!t) throw new p("ui-iconview-invalid-svg", this);
            const i = t.getAttribute("viewBox");
            i && (this.viewBox = i);
            for (const {
                name: n,
                value: o
            } of Array.from(t.attributes)) ot.presentationalAttributeNames.includes(n) && this.element.setAttribute(n, o);
            for (; this.element.firstChild;) this.element.removeChild(this.element.firstChild);
            for (; t.childNodes.length > 0;) this.element.appendChild(t.childNodes[0])
        }
    }

    _colorFillPaths() {
        this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach(e => {
            e.style.fill = this.fillColor
        })
    }
}

class Mf extends T {
    constructor() {
        super(), this.set({style: void 0, text: void 0, id: void 0});
        const e = this.bindTemplate;
        this.setTemplate({
            tag: "span",
            attributes: {class: ["ck", "ck-button__label"], style: e.to("style"), id: e.to("id")},
            children: [{text: e.to("text")}]
        })
    }
}

class I extends T {
    children;
    labelView;
    iconView;
    keystrokeView;
    _focusDelayed = null;

    constructor(e, t = new Mf) {
        super(e);
        const i = this.bindTemplate, n = pe();
        this.set("_ariaPressed", !1), this.set("_ariaChecked", !1), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${n}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isVisible", !0), this.set("isToggleable", !1), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.set("withKeystroke", !1), this.children = this.createCollection(), this.labelView = this._setupLabelView(t), this.iconView = new ot, this.iconView.extendTemplate({attributes: {class: "ck-button__icon"}}), this.iconView.bind("content").to(this, "icon"), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
        const o = {
            tag: "button",
            attributes: {
                class: ["ck", "ck-button", i.to("class"), i.if("isEnabled", "ck-disabled", r => !r), i.if("isVisible", "ck-hidden", r => !r), i.to("isOn", r => r ? "ck-on" : "ck-off"), i.if("withText", "ck-button_with-text"), i.if("withKeystroke", "ck-button_with-keystroke")],
                role: i.to("role"),
                type: i.to("type", r => r || "button"),
                tabindex: i.to("tabindex"),
                "aria-checked": i.to("_ariaChecked"),
                "aria-pressed": i.to("_ariaPressed"),
                "aria-label": i.to("ariaLabel"),
                "aria-labelledby": i.to("ariaLabelledBy"),
                "aria-disabled": i.if("isEnabled", !0, r => !r),
                "data-cke-tooltip-text": i.to("_tooltipString"),
                "data-cke-tooltip-position": i.to("tooltipPosition")
            },
            children: this.children,
            on: {
                click: i.to(r => {
                    this.isEnabled ? this.fire("execute") : r.preventDefault()
                })
            }
        };
        this.bind("_ariaPressed").to(this, "isOn", this, "isToggleable", this, "role", (r, a, l) => !a || Ac(l) ? !1 : String(!!r)), this.bind("_ariaChecked").to(this, "isOn", this, "isToggleable", this, "role", (r, a, l) => !a || !Ac(l) ? !1 : String(!!r)), x.isSafari && (this._focusDelayed || (this._focusDelayed = Xr(() => this.focus(), 0)), o.on.mousedown = i.to(() => {
            this._focusDelayed()
        }), o.on.mouseup = i.to(() => {
            this._focusDelayed.cancel()
        })), this.setTemplate(o)
    }

    render() {
        super.render(), this.icon && this.children.add(this.iconView), this.on("change:icon", (e, t, i, n) => {
            i && !n ? this.children.add(this.iconView, 0) : !i && n && this.children.remove(this.iconView)
        }), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView)
    }

    focus() {
        this.element.focus()
    }

    destroy() {
        this._focusDelayed && this._focusDelayed.cancel(), super.destroy()
    }

    _setupLabelView(e) {
        return e.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy"), e
    }

    _createKeystrokeView() {
        const e = new T;
        return e.setTemplate({
            tag: "span",
            attributes: {class: ["ck", "ck-button__keystroke"]},
            children: [{text: this.bindTemplate.to("keystroke", t => Ms(t))}]
        }), e
    }

    _getTooltipString(e, t, i) {
        return e ? typeof e == "string" ? e : (i && (i = Ms(i)), e instanceof Function ? e(t, i) : `${t}${i ? ` (${i})` : ""}`) : ""
    }
}

function Ac(s) {
    switch (s) {
        case"radio":
        case"checkbox":
        case"option":
        case"switch":
        case"menuitemcheckbox":
        case"menuitemradio":
            return !0;
        default:
            return !1
    }
}

class ci extends T {
    children;
    iconView;

    constructor(e, t = {}) {
        super(e);
        const i = this.bindTemplate;
        this.set("label", t.label || ""), this.set("class", t.class || null), this.children = this.createCollection(), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-form__header", i.to("class")]},
            children: this.children
        }), t.icon && (this.iconView = new ot, this.iconView.content = t.icon, this.children.add(this.iconView));
        const n = new T(e);
        n.setTemplate({
            tag: "h2",
            attributes: {class: ["ck", "ck-form__header__label"], role: "presentation"},
            children: [{text: i.to("label")}]
        }), this.children.add(n)
    }
}

class We extends W() {
    focusables;
    focusTracker;
    keystrokeHandler;
    actions;

    constructor(e) {
        if (super(), this.focusables = e.focusables, this.focusTracker = e.focusTracker, this.keystrokeHandler = e.keystrokeHandler, this.actions = e.actions, e.actions && e.keystrokeHandler) for (const t in e.actions) {
            let i = e.actions[t];
            typeof i == "string" && (i = [i]);
            for (const n of i) e.keystrokeHandler.set(n, (o, r) => {
                this[t](), r()
            }, e.keystrokeHandlerOptions)
        }
        this.on("forwardCycle", () => this.focusFirst(), {priority: "low"}), this.on("backwardCycle", () => this.focusLast(), {priority: "low"})
    }

    get first() {
        return this.focusables.find(Fo) || null
    }

    get last() {
        return this.focusables.filter(Fo).slice(-1)[0] || null
    }

    get next() {
        return this._getDomFocusableItem(1)
    }

    get previous() {
        return this._getDomFocusableItem(-1)
    }

    get current() {
        let e = null;
        return this.focusTracker.focusedElement === null ? null : (this.focusables.find((t, i) => {
            const n = t.element === this.focusTracker.focusedElement;
            return n && (e = i), n
        }), e)
    }

    focusFirst() {
        this._focus(this.first, 1)
    }

    focusLast() {
        this._focus(this.last, -1)
    }

    focusNext() {
        const e = this.next;
        if (e && this.focusables.getIndex(e) === this.current) {
            this.fire("forwardCycle");
            return
        }
        e === this.first ? this.fire("forwardCycle") : this._focus(e, 1)
    }

    focusPrevious() {
        const e = this.previous;
        if (e && this.focusables.getIndex(e) === this.current) {
            this.fire("backwardCycle");
            return
        }
        e === this.last ? this.fire("backwardCycle") : this._focus(e, -1)
    }

    chain(e) {
        const t = () => this.current === null ? null : this.focusables.get(this.current);
        this.listenTo(e, "forwardCycle", i => {
            const n = t();
            this.focusNext(), n !== t() && i.stop()
        }, {priority: "low"}), this.listenTo(e, "backwardCycle", i => {
            const n = t();
            this.focusPrevious(), n !== t() && i.stop()
        }, {priority: "low"})
    }

    unchain(e) {
        this.stopListening(e)
    }

    _focus(e, t) {
        e && this.focusTracker.focusedElement !== e.element && e.focus(t)
    }

    _getDomFocusableItem(e) {
        const t = this.focusables.length;
        if (!t) return null;
        const i = this.current;
        if (i === null) return this[e === 1 ? "first" : "last"];
        let n = this.focusables.get(i), o = (i + t + e) % t;
        do {
            const r = this.focusables.get(o);
            if (Fo(r)) {
                n = r;
                break
            }
            o = (o + t + e) % t
        } while (o !== i);
        return n
    }
}

function Fo(s) {
    return $n(s) && ft(s.element)
}

function $n(s) {
    return "focus" in s && typeof s.focus == "function"
}

function gy(s) {
    return $n(s) && "focusCycler" in s && s.focusCycler instanceof We
}

function py(s) {
    class e extends s {
        _onDragBound = this._onDrag.bind(this);
        _onDragEndBound = this._onDragEnd.bind(this);
        _lastDraggingCoordinates = {x: 0, y: 0};

        constructor(...i) {
            super(...i), this.on("render", () => {
                this._attachListeners()
            }), this.set("isDragging", !1)
        }

        _attachListeners() {
            this.listenTo(this.element, "mousedown", this._onDragStart.bind(this)), this.listenTo(this.element, "touchstart", this._onDragStart.bind(this))
        }

        _attachDragListeners() {
            this.listenTo(C.document, "mouseup", this._onDragEndBound), this.listenTo(C.document, "touchend", this._onDragEndBound), this.listenTo(C.document, "mousemove", this._onDragBound), this.listenTo(C.document, "touchmove", this._onDragBound)
        }

        _detachDragListeners() {
            this.stopListening(C.document, "mouseup", this._onDragEndBound), this.stopListening(C.document, "touchend", this._onDragEndBound), this.stopListening(C.document, "mousemove", this._onDragBound), this.stopListening(C.document, "touchmove", this._onDragBound)
        }

        _onDragStart(i, n) {
            if (!this._isHandleElementPressed(n)) return;
            this._attachDragListeners();
            let o = 0, r = 0;
            n instanceof MouseEvent ? (o = n.clientX, r = n.clientY) : (o = n.touches[0].clientX, r = n.touches[0].clientY), this._lastDraggingCoordinates = {
                x: o,
                y: r
            }, this.isDragging = !0
        }

        _onDrag(i, n) {
            if (!this.isDragging) {
                this._detachDragListeners();
                return
            }
            let o = 0, r = 0;
            n instanceof MouseEvent ? (o = n.clientX, r = n.clientY) : (o = n.touches[0].clientX, r = n.touches[0].clientY), n.preventDefault(), this.fire("drag", {
                deltaX: Math.round(o - this._lastDraggingCoordinates.x),
                deltaY: Math.round(r - this._lastDraggingCoordinates.y)
            }), this._lastDraggingCoordinates = {x: o, y: r}
        }

        _onDragEnd() {
            this._detachDragListeners(), this.isDragging = !1
        }

        _isHandleElementPressed(i) {
            return this.dragHandleElement ? this.dragHandleElement === i.target || i.target instanceof HTMLElement && this.dragHandleElement.contains(i.target) : !1
        }
    }

    return e
}

class wy extends T {
    children;
    keystrokes;
    focusCycler;
    _focusTracker;
    _focusables;

    constructor(e) {
        super(e), this.children = this.createCollection(), this.keystrokes = new ue, this._focusTracker = new se, this._focusables = new Ie, this.focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this._focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"}
        }), this.setTemplate({tag: "div", attributes: {class: ["ck", "ck-dialog__actions"]}, children: this.children})
    }

    render() {
        super.render(), this.keystrokes.listenTo(this.element)
    }

    setButtons(e) {
        for (const t of e) {
            const i = new I(this.locale);
            let n;
            i.on("execute", () => t.onExecute()), t.onCreate && t.onCreate(i);
            for (n in t) n != "onExecute" && n != "onCreate" && i.set(n, t[n]);
            this.children.add(i)
        }
        this._updateFocusCyclableItems()
    }

    focus(e) {
        e === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst()
    }

    _updateFocusCyclableItems() {
        Array.from(this.children).forEach(e => {
            this._focusables.add(e), this._focusTracker.add(e.element)
        })
    }
}

class by extends T {
    children;

    constructor(e) {
        super(e), this.children = this.createCollection(), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-dialog__content"]},
            children: this.children
        })
    }

    reset() {
        for (; this.children.length;) this.children.remove(0)
    }
}

const je = {
    SCREEN_CENTER: "screen-center",
    EDITOR_CENTER: "editor-center",
    EDITOR_TOP_SIDE: "editor-top-side",
    EDITOR_TOP_CENTER: "editor-top-center",
    EDITOR_BOTTOM_CENTER: "editor-bottom-center",
    EDITOR_ABOVE_CENTER: "editor-above-center",
    EDITOR_BELOW_CENTER: "editor-below-center"
}, xc = Hn("px");

class Mn extends py(T) {
    parts;
    headerView;
    closeButtonView;
    actionsView;
    static defaultOffset = 15;
    contentView;
    keystrokes;
    focusTracker;
    wasMoved = !1;
    _getCurrentDomRoot;
    _getViewportOffset;
    _focusables;
    _focusCycler;

    constructor(e, {getCurrentDomRoot: t, getViewportOffset: i, keystrokeHandlerOptions: n}) {
        super(e);
        const o = this.bindTemplate, r = e.t;
        this.set("className", ""), this.set("ariaLabel", r("Editor dialog")), this.set("isModal", !1), this.set("position", je.SCREEN_CENTER), this.set("_isVisible", !1), this.set("_isTransparent", !1), this.set("_top", 0), this.set("_left", 0), this._getCurrentDomRoot = t, this._getViewportOffset = i, this.decorate("moveTo"), this.parts = this.createCollection(), this.keystrokes = new ue, this.focusTracker = new se, this._focusables = new Ie, this._focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"},
            keystrokeHandlerOptions: n
        }), this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-dialog-overlay", o.if("isModal", "ck-dialog-overlay__transparent", a => !a), o.if("_isVisible", "ck-hidden", a => !a)],
                tabindex: "-1"
            },
            children: [{
                tag: "div",
                attributes: {
                    tabindex: "-1",
                    class: ["ck", "ck-dialog", o.if("isModal", "ck-dialog_modal"), o.to("className")],
                    role: "dialog",
                    "aria-label": o.to("ariaLabel"),
                    style: {
                        top: o.to("_top", a => xc(a)),
                        left: o.to("_left", a => xc(a)),
                        visibility: o.if("_isTransparent", "hidden")
                    }
                },
                children: this.parts
            }]
        })
    }

    render() {
        super.render(), this.keystrokes.set("Esc", (e, t) => {
            e.defaultPrevented || (this.fire("close", {source: "escKeyPress"}), t())
        }), this.on("drag", (e, {deltaX: t, deltaY: i}) => {
            this.wasMoved = !0, this.moveBy(t, i)
        }), this.listenTo(C.window, "resize", () => {
            this._isVisible && !this.wasMoved && this.updatePosition()
        }), this.listenTo(C.document, "scroll", () => {
            this._isVisible && !this.wasMoved && this.updatePosition()
        }), this.on("change:_isVisible", (e, t, i) => {
            i && (this._isTransparent = !0, setTimeout(() => {
                this.updatePosition(), this._isTransparent = !1, this.focus()
            }, 10))
        }), this.keystrokes.listenTo(this.element)
    }

    get dragHandleElement() {
        return this.headerView && !this.isModal ? this.headerView.element : null
    }

    setupParts({icon: e, title: t, hasCloseButton: i = !0, content: n, actionButtons: o}) {
        t && (this.headerView = new ci(this.locale, {icon: e}), i && (this.closeButtonView = this._createCloseButton(), this.headerView.children.add(this.closeButtonView)), this.headerView.label = t, this.ariaLabel = t, this.parts.add(this.headerView, 0)), n && (n instanceof T && (n = [n]), this.contentView = new by(this.locale), this.contentView.children.addMany(n), this.parts.add(this.contentView)), o && (this.actionsView = new wy(this.locale), this.actionsView.setButtons(o), this.parts.add(this.actionsView)), this._updateFocusCyclableItems()
    }

    focus() {
        this._focusCycler.focusFirst()
    }

    moveTo(e, t) {
        const i = this._getViewportRect(), n = this._getDialogRect();
        e + n.width > i.right && (e = i.right - n.width), e < i.left && (e = i.left), t < i.top && (t = i.top), this._moveTo(e, t)
    }

    _moveTo(e, t) {
        this._left = e, this._top = t
    }

    moveBy(e, t) {
        this.moveTo(this._left + e, this._top + t)
    }

    _moveOffScreen() {
        this._moveTo(-9999, -9999)
    }

    updatePosition() {
        if (!this.element || !this.element.parentNode) return;
        const e = this._getViewportRect();
        let t = this.position, i;
        this._getCurrentDomRoot() ? i = this._getVisibleDomRootRect(e) : t = je.SCREEN_CENTER;
        const n = Mn.defaultOffset, o = this._getDialogRect();
        switch (t) {
            case je.EDITOR_TOP_SIDE: {
                if (i) {
                    const r = this.locale.contentLanguageDirection === "ltr" ? i.right - o.width - n : i.left + n;
                    this.moveTo(r, i.top + n)
                } else this._moveOffScreen();
                break
            }
            case je.EDITOR_CENTER: {
                i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), Math.round(i.top + i.height / 2 - o.height / 2)) : this._moveOffScreen();
                break
            }
            case je.SCREEN_CENTER: {
                this.moveTo(Math.round((e.width - o.width) / 2), Math.round((e.height - o.height) / 2));
                break
            }
            case je.EDITOR_TOP_CENTER: {
                i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), i.top + n) : this._moveOffScreen();
                break
            }
            case je.EDITOR_BOTTOM_CENTER: {
                i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), i.bottom - o.height - n) : this._moveOffScreen();
                break
            }
            case je.EDITOR_ABOVE_CENTER: {
                i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), i.top - o.height - n) : this._moveOffScreen();
                break
            }
            case je.EDITOR_BELOW_CENTER: {
                i ? this.moveTo(Math.round(i.left + i.width / 2 - o.width / 2), i.bottom + n) : this._moveOffScreen();
                break
            }
        }
    }

    _getVisibleDomRootRect(e) {
        let t = new R(this._getCurrentDomRoot()).getVisible();
        if (t) {
            if (t = e.getIntersection(t), !t) return null
        } else return null;
        return t
    }

    _getDialogRect() {
        return new R(this.element.firstElementChild)
    }

    _getViewportRect() {
        const e = new R(C.window);
        if (this.isModal) return e;
        const t = {top: 0, bottom: 0, left: 0, right: 0, ...this._getViewportOffset()};
        return e.top += t.top, e.height -= t.top, e.bottom -= t.bottom, e.height -= t.bottom, e.left += t.left, e.right -= t.right, e.width -= t.left + t.right, e
    }

    _updateFocusCyclableItems() {
        const e = [];
        if (this.contentView) for (const t of this.contentView.children) $n(t) && e.push(t);
        this.actionsView && e.push(this.actionsView), this.closeButtonView && e.push(this.closeButtonView), e.forEach(t => {
            this._focusables.add(t), this.focusTracker.add(t.element), gy(t) && this._focusCycler.chain(t.focusCycler)
        })
    }

    _createCloseButton() {
        const e = new I(this.locale), t = this.locale.t;
        return e.set({
            label: t("Close"),
            tooltip: !0,
            icon: hf
        }), e.on("execute", () => this.fire("close", {source: "closeButton"})), e
    }
}

class Me extends w {
    view;
    static _visibleDialogPlugin;
    _onHide;

    static get pluginName() {
        return "Dialog"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e);
        const t = e.t;
        this._initShowHideListeners(), this._initFocusToggler(), this._initMultiRootIntegration(), this.set({
            id: null,
            isOpen: !1
        }), e.accessibility.addKeystrokeInfos({
            categoryId: "navigation",
            keystrokes: [{
                label: t("Move focus in and out of an active dialog window"),
                keystroke: "Ctrl+F6",
                mayRequireFn: !0
            }]
        })
    }

    destroy() {
        super.destroy(), Me._visibleDialogPlugin === this && this._unlockBodyScroll()
    }

    _initShowHideListeners() {
        this.on("show", (e, t) => {
            this._show(t)
        }), this.on("show", (e, t) => {
            t.onShow && t.onShow(this)
        }, {priority: "low"}), this.on("hide", () => {
            Me._visibleDialogPlugin && Me._visibleDialogPlugin._hide()
        }), this.on("hide", () => {
            this._onHide && (this._onHide(this), this._onHide = void 0)
        }, {priority: "low"})
    }

    _initFocusToggler() {
        const e = this.editor;
        e.keystrokes.set("Ctrl+F6", (t, i) => {
            !this.isOpen || this.view.isModal || (this.view.focusTracker.isFocused ? e.editing.view.focus() : this.view.focus(), i())
        })
    }

    _initMultiRootIntegration() {
        const e = this.editor.model;
        e.document.on("change:data", () => {
            if (!this.view) return;
            const t = e.document.differ.getChangedRoots();
            for (const i of t) i.state && this.view.updatePosition()
        })
    }

    show(e) {
        this.hide(), this.fire(`show:${e.id}`, e)
    }

    _show({
              id: e,
              icon: t,
              title: i,
              hasCloseButton: n = !0,
              content: o,
              actionButtons: r,
              className: a,
              isModal: l,
              position: c,
              onHide: u,
              keystrokeHandlerOptions: d
          }) {
        const h = this.editor;
        this.view = new Mn(h.locale, {
            getCurrentDomRoot: () => h.editing.view.getDomRoot(h.model.document.selection.anchor.root.rootName),
            getViewportOffset: () => h.ui.viewportOffset,
            keystrokeHandlerOptions: d
        });
        const f = this.view;
        f.on("close", () => {
            this.hide()
        }), h.ui.view.body.add(f), h.keystrokes.listenTo(f.element), c || (c = l ? je.SCREEN_CENTER : je.EDITOR_CENTER), l && this._lockBodyScroll(), f.set({
            position: c,
            _isVisible: !0,
            className: a,
            isModal: l
        }), f.setupParts({
            icon: t,
            title: i,
            hasCloseButton: n,
            content: o,
            actionButtons: r
        }), this.id = e, u && (this._onHide = u), this.isOpen = !0, Me._visibleDialogPlugin = this
    }

    hide() {
        Me._visibleDialogPlugin && Me._visibleDialogPlugin.fire(`hide:${Me._visibleDialogPlugin.id}`)
    }

    _hide() {
        if (!this.view) return;
        const e = this.editor, t = this.view;
        t.isModal && this._unlockBodyScroll(), t.contentView && t.contentView.reset(), e.ui.view.body.remove(t), e.ui.focusTracker.remove(t.element), e.keystrokes.stopListening(t.element), t.destroy(), e.editing.view.focus(), this.id = null, this.isOpen = !1, Me._visibleDialogPlugin = null
    }

    _lockBodyScroll() {
        document.documentElement.classList.add("ck-dialog-scroll-locked")
    }

    _unlockBodyScroll() {
        document.documentElement.classList.remove("ck-dialog-scroll-locked")
    }
}

class Qi extends I {
    _checkIconHolderView = new _y;

    constructor(e, t = new Mf) {
        super(e, t), this.set({hasCheckSpace: !1, _hasCheck: this.isToggleable});
        const i = this.bindTemplate;
        this.extendTemplate({attributes: {class: ["ck-list-item-button", i.if("isToggleable", "ck-list-item-button_toggleable")]}}), this.bind("_hasCheck").to(this, "hasCheckSpace", this, "isToggleable", (n, o) => n || o)
    }

    render() {
        super.render(), this._hasCheck && this.children.add(this._checkIconHolderView, 0), this._watchCheckIconHolderMount()
    }

    _watchCheckIconHolderMount() {
        this._checkIconHolderView.bind("isOn").to(this, "isOn", e => this.isToggleable && e), this.on("change:_hasCheck", (e, t, i) => {
            const {children: n, _checkIconHolderView: o} = this;
            i ? n.add(o, 0) : n.remove(o)
        })
    }
}

class _y extends T {
    children;
    _checkIconView = this._createCheckIconView();

    constructor() {
        super();
        const e = this.bindTemplate;
        this.children = this.createCollection(), this.set("isOn", !1), this.setTemplate({
            tag: "span",
            children: this.children,
            attributes: {class: ["ck", "ck-list-item-button__check-holder", e.to("isOn", t => t ? "ck-on" : "ck-off")]}
        })
    }

    render() {
        super.render(), this.isOn && this.children.add(this._checkIconView, 0), this._watchCheckIconMount()
    }

    _watchCheckIconMount() {
        this.on("change:isOn", (e, t, i) => {
            const {children: n, _checkIconView: o} = this;
            i && !n.has(o) ? n.add(o) : !i && n.has(o) && n.remove(o)
        })
    }

    _createCheckIconView() {
        const e = new ot;
        return e.content = ff, e.extendTemplate({attributes: {class: "ck-list-item-button__check-icon"}}), e
    }
}

class K extends Qi {
    constructor(e) {
        super(e), this.set({
            withText: !0,
            withKeystroke: !0,
            tooltip: !1,
            role: "menuitem"
        }), this.extendTemplate({attributes: {class: ["ck-menu-bar__menu__item__button"]}})
    }
}

class no extends T {
    id;

    constructor(e) {
        super(e), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${pe()}`;
        const t = this.bindTemplate;
        this.setTemplate({
            tag: "label",
            attributes: {class: ["ck", "ck-label"], id: this.id, for: t.to("for")},
            children: [{text: t.to("text")}]
        })
    }
}

class vy extends T {
    constructor(e, t) {
        super(e);
        const i = e.t, n = new no;
        n.text = i("Help Contents. To close this dialog press ESC."), this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-accessibility-help-dialog__content"],
                "aria-labelledby": n.id,
                role: "document",
                tabindex: -1
            },
            children: [Oe(document, "p", {}, i("Below, you can find a list of keyboard shortcuts that can be used in the editor.")), ...this._createCategories(Array.from(t.values())), n]
        })
    }

    focus() {
        this.element.focus()
    }

    _createCategories(e) {
        return e.map(t => {
            const i = [Oe(document, "h3", {}, t.label), ...Array.from(t.groups.values()).map(n => this._createGroup(n)).flat()];
            return t.description && i.splice(1, 0, Oe(document, "p", {}, t.description)), Oe(document, "section", {}, i)
        })
    }

    _createGroup(e) {
        const t = e.keystrokes.sort((n, o) => n.label.localeCompare(o.label)).map(n => this._createGroupRow(n)).flat(),
            i = [Oe(document, "dl", {}, t)];
        return e.label && i.unshift(Oe(document, "h4", {}, e.label)), i
    }

    _createGroupRow(e) {
        const t = this.locale.t, i = Oe(document, "dt"), n = Oe(document, "dd"), o = ky(e.keystroke), r = [];
        for (const a of o) r.push(a.map(yy).join(""));
        return i.innerHTML = e.label, n.innerHTML = r.join(", ") + (e.mayRequireFn && x.isMac ? ` ${t("(may require <kbd>Fn</kbd>)")}` : ""), [i, n]
    }
}

function yy(s) {
    return Ms(s).split("+").map(e => `<kbd>${e}</kbd>`).join("+")
}

function ky(s) {
    return typeof s == "string" ? [[s]] : typeof s[0] == "string" ? [s] : s
}

class Cy extends w {
    contentView = null;

    static get requires() {
        return [Me]
    }

    static get pluginName() {
        return "AccessibilityHelp"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.locale.t;
        e.ui.componentFactory.add("accessibilityHelp", () => {
            const i = this._createButton(I);
            return i.set({tooltip: !0, withText: !1, label: t("Accessibility help")}), i
        }), e.ui.componentFactory.add("menuBar:accessibilityHelp", () => {
            const i = this._createButton(K);
            return i.label = t("Accessibility"), i
        }), e.keystrokes.set("Alt+0", (i, n) => {
            this._toggleDialog(), n()
        }), this._setupRootLabels()
    }

    _createButton(e) {
        const t = this.editor, i = t.plugins.get("Dialog"), n = t.locale, o = new e(n);
        return o.set({
            keystroke: "Alt+0",
            icon: Yl,
            isToggleable: !0
        }), o.on("execute", () => this._toggleDialog()), o.bind("isOn").to(i, "id", r => r === "accessibilityHelp"), o
    }

    _setupRootLabels() {
        const e = this.editor, t = e.editing.view, i = e.t;
        e.ui.on("ready", () => {
            t.change(o => {
                for (const r of t.document.roots) n(o, r)
            }), e.on("addRoot", (o, r) => {
                const a = e.editing.view.document.getRoot(r.rootName);
                t.change(l => n(l, a))
            }, {priority: "low"})
        });

        function n(o, r) {
            const l = [r.getAttribute("aria-label"), i("Press %0 for help.", [Ms("Alt+0")])].filter(c => c).join(". ");
            o.setAttribute("aria-label", l, r)
        }
    }

    _toggleDialog() {
        const e = this.editor, t = e.plugins.get("Dialog"), i = e.locale.t;
        this.contentView || (this.contentView = new vy(e.locale, e.accessibility.keystrokeInfos)), t.id === "accessibilityHelp" ? t.hide() : t.show({
            id: "accessibilityHelp",
            className: "ck-accessibility-help-dialog",
            title: i("Accessibility help"),
            icon: Yl,
            hasCloseButton: !0,
            content: this.contentView
        })
    }
}

class Qe extends Ie {
    locale;
    _bodyCollectionContainer;
    static _bodyWrapper;

    constructor(e, t = []) {
        super(t), this.locale = e
    }

    get bodyCollectionContainer() {
        return this._bodyCollectionContainer
    }

    attachToDom() {
        this._bodyCollectionContainer = new Te({
            tag: "div",
            attributes: {
                class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
                dir: this.locale.uiLanguageDirection,
                role: "application"
            },
            children: this
        }).render(), (!Qe._bodyWrapper || !Qe._bodyWrapper.isConnected) && (Qe._bodyWrapper = Oe(document, "div", {class: "ck-body-wrapper"}), document.body.appendChild(Qe._bodyWrapper)), Qe._bodyWrapper.appendChild(this._bodyCollectionContainer)
    }

    detachFromDom() {
        super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove(), Qe._bodyWrapper && !Qe._bodyWrapper.childElementCount && (Qe._bodyWrapper.remove(), delete Qe._bodyWrapper)
    }
}

class Wi extends I {
    toggleSwitchView;

    constructor(e) {
        super(e), this.isToggleable = !0, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({attributes: {class: "ck-switchbutton"}})
    }

    render() {
        super.render(), this.children.add(this.toggleSwitchView)
    }

    _createToggleView() {
        const e = new T;
        return e.setTemplate({
            tag: "span",
            attributes: {class: ["ck", "ck-button__toggle"]},
            children: [{tag: "span", attributes: {class: ["ck", "ck-button__toggle__inner"]}}]
        }), e
    }
}

class Ic extends Bf(I) {
}

class Ey extends Bf(Qi) {
}

function Bf(s) {
    class e extends s {
        buttonView;
        _fileInputView;

        constructor(...i) {
            super(...i), this.buttonView = this, this._fileInputView = new Ty(this.locale), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.on("execute", () => {
                this._fileInputView.open()
            }), this.extendTemplate({attributes: {class: "ck-file-dialog-button"}})
        }

        render() {
            super.render(), this.children.add(this._fileInputView)
        }
    }

    return e
}

class Ty extends T {
    constructor(e) {
        super(e), this.set("acceptedType", void 0), this.set("allowMultipleFiles", !1);
        const t = this.bindTemplate;
        this.setTemplate({
            tag: "input",
            attributes: {
                class: ["ck-hidden"],
                type: "file",
                tabindex: "-1",
                accept: t.to("acceptedType"),
                multiple: t.to("allowMultipleFiles")
            },
            on: {
                change: t.to(() => {
                    this.element?.files?.length && this.fire("done", this.element.files), this.element.value = ""
                })
            }
        })
    }

    open() {
        this.element.click()
    }
}

class Ff extends T {
    buttonView;
    children;

    constructor(e, t) {
        super(e);
        const i = this.bindTemplate;
        this.set("isCollapsed", !1), this.set("label", ""), this.buttonView = this._createButtonView(), this.children = this.createCollection(), this.set("_collapsibleAriaLabelUid", void 0), t && this.children.addMany(t), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-collapsible", i.if("isCollapsed", "ck-collapsible_collapsed")]},
            children: [this.buttonView, {
                tag: "div",
                attributes: {
                    class: ["ck", "ck-collapsible__children"],
                    role: "region",
                    hidden: i.if("isCollapsed", "hidden"),
                    "aria-labelledby": i.to("_collapsibleAriaLabelUid")
                },
                children: this.children
            }]
        })
    }

    render() {
        super.render(), this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id
    }

    focus() {
        this.buttonView.focus()
    }

    _createButtonView() {
        const e = new I(this.locale), t = e.bindTemplate;
        return e.set({
            withText: !0,
            icon: io
        }), e.extendTemplate({attributes: {"aria-expanded": t.to("isOn", i => String(i))}}), e.bind("label").to(this), e.bind("isOn").to(this, "isCollapsed", i => !i), e.on("execute", () => {
            this.isCollapsed = !this.isCollapsed
        }), e
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Ay(s, e) {
    const t = s.t, i = {
        Black: t("Black"),
        "Dim grey": t("Dim grey"),
        Grey: t("Grey"),
        "Light grey": t("Light grey"),
        White: t("White"),
        Red: t("Red"),
        Orange: t("Orange"),
        Yellow: t("Yellow"),
        "Light green": t("Light green"),
        Green: t("Green"),
        Aquamarine: t("Aquamarine"),
        Turquoise: t("Turquoise"),
        "Light blue": t("Light blue"),
        Blue: t("Blue"),
        Purple: t("Purple")
    };
    return e.map(n => {
        const o = i[n.label];
        return o && o != n.label && (n.label = o), n
    })
}

function xy(s) {
    return s.map(Iy).filter(e => !!e)
}

function Iy(s) {
    return typeof s == "string" ? {
        model: s,
        label: s,
        hasBorder: !1,
        view: {name: "span", styles: {color: s}}
    } : {
        model: s.color,
        label: s.label || s.color,
        hasBorder: s.hasBorder === void 0 ? !1 : s.hasBorder,
        view: {name: "span", styles: {color: `${s.color}`}}
    }
}

class Lf extends I {
    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.set("color", void 0), this.set("hasBorder", !1), this.icon = Jv, this.extendTemplate({
            attributes: {
                style: {backgroundColor: t.to("color", i => x.isMediaForcedColors ? null : i)},
                class: ["ck", "ck-color-grid__tile", t.if("hasBorder", "ck-color-selector__color-tile_bordered")]
            }
        })
    }

    render() {
        super.render(), this.iconView.fillColor = "hsl(0, 0%, 100%)"
    }
}

class Sc extends T {
    columns;
    items;
    focusTracker;
    keystrokes;

    constructor(e, t) {
        super(e);
        const i = t && t.colorDefinitions ? t.colorDefinitions : [];
        this.columns = t?.columns || 5;
        const n = {gridTemplateColumns: `repeat( ${this.columns}, 1fr)`};
        this.set("selectedColor", void 0), this.items = this.createCollection(), this.focusTracker = new se, this.keystrokes = new ue, this.items.on("add", (o, r) => {
            r.isOn = r.color === this.selectedColor
        }), i.forEach(o => {
            const r = new Lf;
            r.set({
                color: o.color,
                label: o.label,
                tooltip: !0,
                hasBorder: o.options.hasBorder
            }), r.on("execute", () => {
                this.fire("execute", {value: o.color, hasBorder: o.options.hasBorder, label: o.label})
            }), this.items.add(r)
        }), this.setTemplate({
            tag: "div",
            children: this.items,
            attributes: {class: ["ck", "ck-color-grid"], style: n}
        }), this.on("change:selectedColor", (o, r, a) => {
            for (const l of this.items) l.isOn = l.color === a
        })
    }

    focus() {
        this.items.length && this.items.first.focus()
    }

    focusLast() {
        this.items.length && this.items.last.focus()
    }

    render() {
        super.render();
        for (const e of this.items) this.focusTracker.add(e.element);
        this.items.on("add", (e, t) => {
            this.focusTracker.add(t.element)
        }), this.items.on("remove", (e, t) => {
            this.focusTracker.remove(t.element)
        }), this.keystrokes.listenTo(this.element), Of({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: this.columns,
            uiLanguageDirection: this.locale?.uiLanguageDirection
        })
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Df(s, e) {
    if (!s) return "";
    const t = Nf(s);
    if (!t) return "";
    if (t.space === e) return s;
    if (!Vy(t)) return "";
    const n = Ef[t.space][e];
    if (!n) return "";
    const o = n(t.space === "hex" ? t.hexValue : t.values);
    return Ry(o, e)
}

function Sy(s) {
    if (!s) return "";
    const e = Nf(s);
    return e ? e.space === "hex" ? e.hexValue : Df(s, "hex") : "#000"
}

function Py(s, e) {
    customElements.get(s) === void 0 && customElements.define(s, e)
}

function Ry(s, e) {
    switch (e) {
        case"hex":
            return `#${s}`;
        case"rgb":
            return `rgb(${s[0]}, ${s[1]}, ${s[2]})`;
        case"hsl":
            return `hsl(${s[0]}, ${s[1]}%, ${s[2]}%)`;
        case"hwb":
            return `hwb(${s[0]}, ${s[1]}, ${s[2]})`;
        case"lab":
            return `lab(${s[0]}% ${s[1]} ${s[2]})`;
        case"lch":
            return `lch(${s[0]}% ${s[1]} ${s[2]})`;
        default:
            return ""
    }
}

function Nf(s) {
    if (s.startsWith("#")) {
        const t = uc(s);
        return {space: "hex", values: t.values, hexValue: s, alpha: t.alpha}
    }
    const e = uc(s);
    return e.space ? e : null
}

function Vy(s) {
    return Object.keys(Ef).includes(s.space)
}

class Ut extends T {
    fieldView;
    labelView;
    statusView;
    fieldWrapperChildren;

    constructor(e, t) {
        super(e);
        const i = `ck-labeled-field-view-${pe()}`, n = `ck-labeled-field-view-status-${pe()}`;
        this.fieldView = t(this, i, n), this.set("label", void 0), this.set("isEnabled", !0), this.set("isEmpty", !0), this.set("isFocused", !1), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(i), this.statusView = this._createStatusView(n), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (r, a) => r || a);
        const o = this.bindTemplate;
        this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-labeled-field-view", o.to("class"), o.if("isEnabled", "ck-disabled", r => !r), o.if("isEmpty", "ck-labeled-field-view_empty"), o.if("isFocused", "ck-labeled-field-view_focused"), o.if("placeholder", "ck-labeled-field-view_placeholder"), o.if("errorText", "ck-error")]},
            children: [{
                tag: "div",
                attributes: {class: ["ck", "ck-labeled-field-view__input-wrapper"]},
                children: this.fieldWrapperChildren
            }, this.statusView]
        })
    }

    _createLabelView(e) {
        const t = new no(this.locale);
        return t.for = e, t.bind("text").to(this, "label"), t
    }

    _createStatusView(e) {
        const t = new T(this.locale), i = this.bindTemplate;
        return t.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-labeled-field-view__status", i.if("errorText", "ck-labeled-field-view__status_error"), i.if("_statusText", "ck-hidden", n => !n)],
                id: e,
                role: i.if("errorText", "alert")
            },
            children: [{text: i.to("_statusText")}]
        }), t
    }

    focus(e) {
        this.fieldView.focus(e)
    }
}

class Oy extends T {
    focusTracker;

    constructor(e) {
        super(e), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("tabIndex", void 0), this.set("isReadOnly", !1), this.set("hasError", !1), this.set("ariaDescribedById", void 0), this.set("ariaLabel", void 0), this.focusTracker = new se, this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", !0);
        const t = this.bindTemplate;
        this.setTemplate({
            tag: "input",
            attributes: {
                class: ["ck", "ck-input", t.if("isFocused", "ck-input_focused"), t.if("isEmpty", "ck-input-text_empty"), t.if("hasError", "ck-error")],
                id: t.to("id"),
                placeholder: t.to("placeholder"),
                tabindex: t.to("tabIndex"),
                readonly: t.to("isReadOnly"),
                "aria-invalid": t.if("hasError", !0),
                "aria-describedby": t.to("ariaDescribedById"),
                "aria-label": t.to("ariaLabel")
            },
            on: {
                input: t.to((...i) => {
                    this.fire("input", ...i), this._updateIsEmpty()
                }), change: t.to(this._updateIsEmpty.bind(this))
            }
        })
    }

    render() {
        super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (e, t, i) => {
            this._setDomElementValue(i), this._updateIsEmpty()
        })
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy()
    }

    select() {
        this.element.select()
    }

    focus() {
        this.element.focus()
    }

    reset() {
        this.value = this.element.value = "", this._updateIsEmpty()
    }

    _updateIsEmpty() {
        this.isEmpty = My(this.element)
    }

    _setDomElementValue(e) {
        this.element.value = !e && e !== 0 ? "" : e
    }
}

function My(s) {
    return !s.value
}

class zf extends Oy {
    constructor(e) {
        super(e), this.set("inputMode", "text");
        const t = this.bindTemplate;
        this.extendTemplate({attributes: {inputmode: t.to("inputMode")}})
    }
}

class By extends zf {
    constructor(e) {
        super(e), this.extendTemplate({attributes: {type: "text", class: ["ck-input-text"]}})
    }
}

class Fy extends zf {
    constructor(e, {min: t, max: i, step: n} = {}) {
        super(e);
        const o = this.bindTemplate;
        this.set("min", t), this.set("max", i), this.set("step", n), this.extendTemplate({
            attributes: {
                type: "number",
                class: ["ck-input-number"],
                min: o.to("min"),
                max: o.to("max"),
                step: o.to("step")
            }
        })
    }
}

class Ly extends T {
    children;

    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-reset", "ck-dropdown__panel", t.to("position", i => `ck-dropdown__panel_${i}`), t.if("isVisible", "ck-dropdown__panel-visible")],
                tabindex: "-1"
            },
            children: this.children,
            on: {
                selectstart: t.to(i => {
                    i.target.tagName.toLocaleLowerCase() !== "input" && i.preventDefault()
                })
            }
        })
    }

    focus() {
        if (this.children.length) {
            const e = this.children.first;
            typeof e.focus == "function" ? e.focus() : L("ui-dropdown-panel-focus-child-missing-focus", {
                childView: this.children.first,
                dropdownPanel: this
            })
        }
    }

    focusLast() {
        if (this.children.length) {
            const e = this.children.last;
            typeof e.focusLast == "function" ? e.focusLast() : e.focus()
        }
    }
}

class Bn extends T {
    buttonView;
    panelView;
    focusTracker;
    keystrokes;
    listView;
    toolbarView;
    menuView;

    constructor(e, t, i) {
        super(e);
        const n = this.bindTemplate;
        this.buttonView = t, this.panelView = i, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new ue, this.focusTracker = new se, this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-dropdown", n.to("class"), n.if("isEnabled", "ck-disabled", o => !o)],
                id: n.to("id"),
                "aria-describedby": n.to("ariaDescribedById")
            },
            children: [t, i]
        }), t.extendTemplate({
            attributes: {
                class: ["ck-dropdown__button"],
                "data-cke-tooltip-disabled": n.to("isOpen")
            }
        })
    }

    render() {
        super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen
        }), this.on("change:isOpen", (t, i, n) => {
            if (n) if (this.panelPosition === "auto") {
                const o = Bn._getOptimalPosition({
                    element: this.panelView.element,
                    target: this.buttonView.element,
                    fitInViewport: !0,
                    positions: this._panelPositions
                });
                this.panelView.position = o ? o.name : this._defaultPanelPositionName
            } else this.panelView.position = this.panelPosition
        }), this.keystrokes.listenTo(this.element);
        const e = (t, i) => {
            this.isOpen && (this.isOpen = !1, i())
        };
        this.keystrokes.set("arrowdown", (t, i) => {
            this.buttonView.isEnabled && !this.isOpen && (this.isOpen = !0, i())
        }), this.keystrokes.set("arrowright", (t, i) => {
            this.isOpen && i()
        }), this.keystrokes.set("arrowleft", e), this.keystrokes.set("esc", e)
    }

    focus() {
        this.buttonView.focus()
    }

    get _panelPositions() {
        const {
            south: e,
            north: t,
            southEast: i,
            southWest: n,
            northEast: o,
            northWest: r,
            southMiddleEast: a,
            southMiddleWest: l,
            northMiddleEast: c,
            northMiddleWest: u
        } = Bn.defaultPanelPositions;
        return this.locale.uiLanguageDirection !== "rtl" ? [i, n, a, l, e, o, r, c, u, t] : [n, i, l, a, e, r, o, u, c, t]
    }

    get _defaultPanelPositionName() {
        return this.locale.uiLanguageDirection === "rtl" ? "sw" : "se"
    }

    static defaultPanelPositions = {
        south: (e, t) => ({
            top: e.bottom,
            left: e.left - (t.width - e.width) / 2,
            name: "s"
        }),
        southEast: e => ({top: e.bottom, left: e.left, name: "se"}),
        southWest: (e, t) => ({top: e.bottom, left: e.left - t.width + e.width, name: "sw"}),
        southMiddleEast: (e, t) => ({top: e.bottom, left: e.left - (t.width - e.width) / 4, name: "sme"}),
        southMiddleWest: (e, t) => ({top: e.bottom, left: e.left - (t.width - e.width) * 3 / 4, name: "smw"}),
        north: (e, t) => ({top: e.top - t.height, left: e.left - (t.width - e.width) / 2, name: "n"}),
        northEast: (e, t) => ({top: e.top - t.height, left: e.left, name: "ne"}),
        northWest: (e, t) => ({top: e.top - t.height, left: e.left - t.width + e.width, name: "nw"}),
        northMiddleEast: (e, t) => ({top: e.top - t.height, left: e.left - (t.width - e.width) / 4, name: "nme"}),
        northMiddleWest: (e, t) => ({top: e.top - t.height, left: e.left - (t.width - e.width) * 3 / 4, name: "nmw"})
    };
    static _getOptimalPosition = Zr
}

class Hf extends I {
    arrowView;

    constructor(e) {
        super(e), this.arrowView = this._createArrowView(), this.extendTemplate({
            attributes: {
                "aria-haspopup": !0,
                "aria-expanded": this.bindTemplate.to("isOn", t => String(t))
            }
        }), this.delegate("execute").to(this, "open")
    }

    render() {
        super.render(), this.children.add(this.arrowView)
    }

    _createArrowView() {
        const e = new ot;
        return e.content = io, e.extendTemplate({attributes: {class: "ck-dropdown__arrow"}}), e
    }
}

class Ke extends T {
    children;

    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.set("isVisible", !0), this.children = this.createCollection(), this.setTemplate({
            tag: "li",
            attributes: {class: ["ck", "ck-list__item", t.if("isVisible", "ck-hidden", i => !i)], role: "presentation"},
            children: this.children
        })
    }

    focus() {
        this.children.first && this.children.first.focus()
    }
}

class so extends T {
    constructor(e) {
        super(e), this.setTemplate({tag: "li", attributes: {class: ["ck", "ck-list__separator"]}})
    }
}

class ys extends T {
    labelView;
    items;
    children;

    constructor(e, t = new no) {
        super(e);
        const i = this.bindTemplate, n = new ui(e);
        this.set({
            label: "",
            isVisible: !0
        }), this.labelView = t, this.labelView.bind("text").to(this, "label"), this.children = this.createCollection(), this.children.addMany([this.labelView, n]), n.set({
            role: "group",
            ariaLabelledBy: t.id
        }), n.focusTracker.destroy(), n.keystrokes.destroy(), this.items = n.items, this.setTemplate({
            tag: "li",
            attributes: {
                role: "presentation",
                class: ["ck", "ck-list__group", i.if("isVisible", "ck-hidden", o => !o)]
            },
            children: this.children
        })
    }

    focus() {
        if (this.items) {
            const e = this.items.find(t => !(t instanceof so));
            e && e.focus()
        }
    }
}

class ui extends T {
    focusables;
    items;
    focusTracker;
    keystrokes;
    _focusCycler;
    _listItemGroupToChangeListeners = new WeakMap;

    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.focusables = new Ie, this.items = this.createCollection(), this.focusTracker = new se, this.keystrokes = new ue, this._focusCycler = new We({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "arrowup", focusNext: "arrowdown"}
        }), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", void 0), this.set("role", void 0), this.setTemplate({
            tag: "ul",
            attributes: {
                class: ["ck", "ck-reset", "ck-list"],
                role: t.to("role"),
                "aria-label": t.to("ariaLabel"),
                "aria-labelledby": t.to("ariaLabelledBy")
            },
            children: this.items
        })
    }

    render() {
        super.render();
        for (const e of this.items) e instanceof ys ? this._registerFocusableItemsGroup(e) : e instanceof Ke && this._registerFocusableListItem(e);
        this.items.on("change", (e, t) => {
            for (const i of t.removed) i instanceof ys ? this._deregisterFocusableItemsGroup(i) : i instanceof Ke && this._deregisterFocusableListItem(i);
            for (const i of Array.from(t.added).reverse()) i instanceof ys ? this._registerFocusableItemsGroup(i, t.index) : this._registerFocusableListItem(i, t.index)
        }), this.keystrokes.listenTo(this.element)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    focus() {
        this._focusCycler.focusFirst()
    }

    focusFirst() {
        this._focusCycler.focusFirst()
    }

    focusLast() {
        this._focusCycler.focusLast()
    }

    _registerFocusableListItem(e, t) {
        this.focusTracker.add(e.element), this.focusables.add(e, t)
    }

    _deregisterFocusableListItem(e) {
        this.focusTracker.remove(e.element), this.focusables.remove(e)
    }

    _getOnGroupItemsChangeCallback(e) {
        return (t, i) => {
            for (const n of i.removed) this._deregisterFocusableListItem(n);
            for (const n of Array.from(i.added).reverse()) this._registerFocusableListItem(n, this.items.getIndex(e) + i.index)
        }
    }

    _registerFocusableItemsGroup(e, t) {
        Array.from(e.items).forEach((n, o) => {
            const r = typeof t < "u" ? t + o : void 0;
            this._registerFocusableListItem(n, r)
        });
        const i = this._getOnGroupItemsChangeCallback(e);
        this._listItemGroupToChangeListeners.set(e, i), e.items.on("change", i)
    }

    _deregisterFocusableItemsGroup(e) {
        for (const t of e.items) this._deregisterFocusableListItem(t);
        e.items.off("change", this._listItemGroupToChangeListeners.get(e)), this._listItemGroupToChangeListeners.delete(e)
    }
}

const Pc = Hn("px"), Dy = {top: -99999, left: -99999, name: "arrowless", config: {withArrow: !1}};

class Be extends T {
    content;
    _pinWhenIsVisibleCallback;
    _resizeObserver;

    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", !1), this.set("withArrow", !0), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this._resizeObserver = null, this.content = this.createCollection(), this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-balloon-panel", t.to("position", i => `ck-balloon-panel_${i}`), t.if("isVisible", "ck-balloon-panel_visible"), t.if("withArrow", "ck-balloon-panel_with-arrow"), t.to("class")],
                style: {top: t.to("top", Pc), left: t.to("left", Pc)}
            },
            children: this.content
        })
    }

    destroy() {
        this.hide(), super.destroy()
    }

    show() {
        this.isVisible = !0
    }

    hide() {
        this.isVisible = !1
    }

    attachTo(e) {
        const t = ks(e.target);
        if (t && !ft(t)) return !1;
        this.show();
        const i = Be.defaultPositions, n = Object.assign({}, {
                element: this.element,
                positions: [i.southArrowNorth, i.southArrowNorthMiddleWest, i.southArrowNorthMiddleEast, i.southArrowNorthWest, i.southArrowNorthEast, i.northArrowSouth, i.northArrowSouthMiddleWest, i.northArrowSouthMiddleEast, i.northArrowSouthWest, i.northArrowSouthEast, i.viewportStickyNorth],
                limiter: C.document.body,
                fitInViewport: !0
            }, e), o = Be._getOptimalPosition(n) || Dy, r = parseInt(o.left), a = parseInt(o.top), l = o.name,
            c = o.config || {}, {withArrow: u = !0} = c;
        return this.top = a, this.left = r, this.position = l, this.withArrow = u, !0
    }

    pin(e) {
        this.unpin(), this._startPinning(e) && (this._pinWhenIsVisibleCallback = () => {
            this.isVisible ? this._startPinning(e) : this._stopPinning()
        }, this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback))
    }

    unpin() {
        this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide())
    }

    _startPinning(e) {
        if (!this.attachTo(e)) return !1;
        let t = ks(e.target);
        const i = e.limiter ? ks(e.limiter) : C.document.body;
        if (this.listenTo(C.document, "scroll", (n, o) => {
            const r = o.target, a = t && r.contains(t), l = i && r.contains(i);
            (a || l || !t || !i) && this.attachTo(e)
        }, {useCapture: !0}), this.listenTo(C.window, "resize", () => {
            this.attachTo(e)
        }), !this._resizeObserver && (t && X(t) && (t = t.parentElement), t)) {
            const n = () => {
                ft(t) || this.unpin()
            };
            this._resizeObserver = new Q(t, n)
        }
        return !0
    }

    _stopPinning() {
        this.stopListening(C.document, "scroll"), this.stopListening(C.window, "resize"), this._resizeObserver && (this._resizeObserver.destroy(), this._resizeObserver = null)
    }

    static generatePositions(e = {}) {
        const {
            sideOffset: t = Be.arrowSideOffset,
            heightOffset: i = Be.arrowHeightOffset,
            stickyVerticalOffset: n = Be.stickyVerticalOffset,
            config: o
        } = e;
        return {
            northWestArrowSouthWest: (l, c) => ({
                top: r(l, c),
                left: l.left - t,
                name: "arrow_sw", ...o && {config: o}
            }),
            northWestArrowSouthMiddleWest: (l, c) => ({
                top: r(l, c),
                left: l.left - c.width * .25 - t,
                name: "arrow_smw", ...o && {config: o}
            }),
            northWestArrowSouth: (l, c) => ({
                top: r(l, c),
                left: l.left - c.width / 2,
                name: "arrow_s", ...o && {config: o}
            }),
            northWestArrowSouthMiddleEast: (l, c) => ({
                top: r(l, c),
                left: l.left - c.width * .75 + t,
                name: "arrow_sme", ...o && {config: o}
            }),
            northWestArrowSouthEast: (l, c) => ({
                top: r(l, c),
                left: l.left - c.width + t,
                name: "arrow_se", ...o && {config: o}
            }),
            northArrowSouthWest: (l, c) => ({
                top: r(l, c),
                left: l.left + l.width / 2 - t,
                name: "arrow_sw", ...o && {config: o}
            }),
            northArrowSouthMiddleWest: (l, c) => ({
                top: r(l, c),
                left: l.left + l.width / 2 - c.width * .25 - t,
                name: "arrow_smw", ...o && {config: o}
            }),
            northArrowSouth: (l, c) => ({
                top: r(l, c),
                left: l.left + l.width / 2 - c.width / 2,
                name: "arrow_s", ...o && {config: o}
            }),
            northArrowSouthMiddleEast: (l, c) => ({
                top: r(l, c),
                left: l.left + l.width / 2 - c.width * .75 + t,
                name: "arrow_sme", ...o && {config: o}
            }),
            northArrowSouthEast: (l, c) => ({
                top: r(l, c),
                left: l.left + l.width / 2 - c.width + t,
                name: "arrow_se", ...o && {config: o}
            }),
            northEastArrowSouthWest: (l, c) => ({
                top: r(l, c),
                left: l.right - t,
                name: "arrow_sw", ...o && {config: o}
            }),
            northEastArrowSouthMiddleWest: (l, c) => ({
                top: r(l, c),
                left: l.right - c.width * .25 - t,
                name: "arrow_smw", ...o && {config: o}
            }),
            northEastArrowSouth: (l, c) => ({
                top: r(l, c),
                left: l.right - c.width / 2,
                name: "arrow_s", ...o && {config: o}
            }),
            northEastArrowSouthMiddleEast: (l, c) => ({
                top: r(l, c),
                left: l.right - c.width * .75 + t,
                name: "arrow_sme", ...o && {config: o}
            }),
            northEastArrowSouthEast: (l, c) => ({
                top: r(l, c),
                left: l.right - c.width + t,
                name: "arrow_se", ...o && {config: o}
            }),
            southWestArrowNorthWest: l => ({top: a(l), left: l.left - t, name: "arrow_nw", ...o && {config: o}}),
            southWestArrowNorthMiddleWest: (l, c) => ({
                top: a(l),
                left: l.left - c.width * .25 - t,
                name: "arrow_nmw", ...o && {config: o}
            }),
            southWestArrowNorth: (l, c) => ({
                top: a(l),
                left: l.left - c.width / 2,
                name: "arrow_n", ...o && {config: o}
            }),
            southWestArrowNorthMiddleEast: (l, c) => ({
                top: a(l),
                left: l.left - c.width * .75 + t,
                name: "arrow_nme", ...o && {config: o}
            }),
            southWestArrowNorthEast: (l, c) => ({
                top: a(l),
                left: l.left - c.width + t,
                name: "arrow_ne", ...o && {config: o}
            }),
            southArrowNorthWest: l => ({
                top: a(l),
                left: l.left + l.width / 2 - t,
                name: "arrow_nw", ...o && {config: o}
            }),
            southArrowNorthMiddleWest: (l, c) => ({
                top: a(l),
                left: l.left + l.width / 2 - c.width * .25 - t,
                name: "arrow_nmw", ...o && {config: o}
            }),
            southArrowNorth: (l, c) => ({
                top: a(l),
                left: l.left + l.width / 2 - c.width / 2,
                name: "arrow_n", ...o && {config: o}
            }),
            southArrowNorthMiddleEast: (l, c) => ({
                top: a(l),
                left: l.left + l.width / 2 - c.width * .75 + t,
                name: "arrow_nme", ...o && {config: o}
            }),
            southArrowNorthEast: (l, c) => ({
                top: a(l),
                left: l.left + l.width / 2 - c.width + t,
                name: "arrow_ne", ...o && {config: o}
            }),
            southEastArrowNorthWest: l => ({top: a(l), left: l.right - t, name: "arrow_nw", ...o && {config: o}}),
            southEastArrowNorthMiddleWest: (l, c) => ({
                top: a(l),
                left: l.right - c.width * .25 - t,
                name: "arrow_nmw", ...o && {config: o}
            }),
            southEastArrowNorth: (l, c) => ({
                top: a(l),
                left: l.right - c.width / 2,
                name: "arrow_n", ...o && {config: o}
            }),
            southEastArrowNorthMiddleEast: (l, c) => ({
                top: a(l),
                left: l.right - c.width * .75 + t,
                name: "arrow_nme", ...o && {config: o}
            }),
            southEastArrowNorthEast: (l, c) => ({
                top: a(l),
                left: l.right - c.width + t,
                name: "arrow_ne", ...o && {config: o}
            }),
            westArrowEast: (l, c) => ({
                top: l.top + l.height / 2 - c.height / 2,
                left: l.left - c.width - i,
                name: "arrow_e", ...o && {config: o}
            }),
            eastArrowWest: (l, c) => ({
                top: l.top + l.height / 2 - c.height / 2,
                left: l.right + i,
                name: "arrow_w", ...o && {config: o}
            }),
            viewportStickyNorth: (l, c, u) => {
                const d = new R(C.document.body).getIntersection(u.getVisible());
                if (!d) return null;
                const h = d.getVisible();
                return !l.getIntersection(h) || !(h.top - l.top - n < c.height && h.bottom - l.bottom < c.height) ? null : {
                    top: h.top + n,
                    left: l.left + l.width / 2 - c.width / 2,
                    name: "arrowless",
                    config: {withArrow: !1, ...o}
                }
            }
        };

        function r(l, c) {
            return l.top - c.height - i
        }

        function a(l) {
            return l.bottom + i
        }
    }

    static arrowSideOffset = 25;
    static arrowHeightOffset = 10;
    static stickyVerticalOffset = 20;
    static _getOptimalPosition = Zr;
    static defaultPositions = Be.generatePositions()
}

function ks(s) {
    return At(s) ? s : Js(s) ? s.commonAncestorContainer : typeof s == "function" ? ks(s()) : null
}

class wa extends T {
    constructor(e) {
        super(e), this.setTemplate({tag: "span", attributes: {class: ["ck", "ck-toolbar__separator"]}})
    }
}

class Ny extends T {
    constructor(e) {
        super(e), this.setTemplate({tag: "span", attributes: {class: ["ck", "ck-toolbar__line-break"]}})
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function zy(s) {
    return s.bindTemplate.to(e => {
        e.target === s.element && e.preventDefault()
    })
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Uf(s) {
    if (Array.isArray(s)) return {items: s, removeItems: []};
    const e = {items: [], removeItems: []};
    return s ? {...e, ...s} : e
}

const Hy = {
    alignLeft: uf,
    bold: df,
    importExport: o1,
    paragraph: w1,
    plus: y1,
    text: M1,
    threeVerticalDots: fa,
    pilcrow: v1,
    dragIndicator: Yv
};

class oo extends T {
    options;
    items;
    focusTracker;
    keystrokes;
    itemsView;
    children;
    focusables;
    _focusCycler;
    _behavior;

    constructor(e, t) {
        super(e);
        const i = this.bindTemplate, n = this.t;
        this.options = t || {}, this.set("ariaLabel", n("Editor toolbar")), this.set("maxWidth", "auto"), this.set("role", "toolbar"), this.set("isGrouping", !!this.options.shouldGroupWhenFull), this.items = this.createCollection(), this.focusTracker = new se, this.keystrokes = new ue, this.set("class", void 0), this.set("isCompact", !1), this.set("isVertical", !1), this.itemsView = new Uy(e), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
        const o = e.uiLanguageDirection === "rtl";
        this._focusCycler = new We({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
                focusPrevious: [o ? "arrowright" : "arrowleft", "arrowup"],
                focusNext: [o ? "arrowleft" : "arrowright", "arrowdown"]
            }
        });
        const r = ["ck", "ck-toolbar", i.to("class"), i.if("isCompact", "ck-toolbar_compact"), i.if("isGrouping", "ck-toolbar_grouping"), i.if("isVertical", "ck-toolbar_vertical")];
        this.options.shouldGroupWhenFull && this.options.isFloating && r.push("ck-toolbar_floating"), this.setTemplate({
            tag: "div",
            attributes: {
                class: r,
                role: i.to("role"),
                "aria-label": i.to("ariaLabel"),
                style: {maxWidth: i.to("maxWidth")},
                tabindex: -1
            },
            children: this.children,
            on: {mousedown: zy(this)}
        }), this._behavior = this.options.shouldGroupWhenFull ? new Vc(this) : new Rc(this)
    }

    render() {
        super.render(), this.focusTracker.add(this.element);
        for (const e of this.items) this.focusTracker.add(e);
        this.items.on("add", (e, t) => {
            this.focusTracker.add(t)
        }), this.items.on("remove", (e, t) => {
            this.focusTracker.remove(t)
        }), this.keystrokes.listenTo(this.element), this._behavior.render(this)
    }

    destroy() {
        return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy()
    }

    focus() {
        this._focusCycler.focusFirst()
    }

    focusLast() {
        this._focusCycler.focusLast()
    }

    fillFromConfig(e, t, i) {
        this.items.addMany(this._buildItemsFromConfig(e, t, i))
    }

    switchBehavior(e) {
        this._behavior.type !== e && (this._behavior.destroy(), this.itemsView.children.clear(), this.focusables.clear(), e === "dynamic" ? (this._behavior = new Vc(this), this._behavior.render(this), this._behavior.refreshItems()) : (this._behavior = new Rc(this), this._behavior.render(this)))
    }

    _buildItemsFromConfig(e, t, i) {
        const n = Uf(e), o = i || n.removeItems;
        return this._cleanItemsConfiguration(n.items, t, o).map(a => tt(a) ? this._createNestedToolbarDropdown(a, t, o) : a === "|" ? new wa : a === "-" ? new Ny : t.create(a)).filter(a => !!a)
    }

    _cleanItemsConfiguration(e, t, i) {
        const n = e.filter((o, r, a) => o === "|" ? !0 : i.indexOf(o) !== -1 ? !1 : o === "-" ? this.options.shouldGroupWhenFull ? (L("toolbarview-line-break-ignored-when-grouping-items", a), !1) : !0 : !tt(o) && !t.has(o) ? (L("toolbarview-item-unavailable", {item: o}), !1) : !0);
        return this._cleanSeparatorsAndLineBreaks(n)
    }

    _cleanSeparatorsAndLineBreaks(e) {
        const t = r => r !== "-" && r !== "|", i = e.length, n = e.findIndex(t);
        if (n === -1) return [];
        const o = i - e.slice().reverse().findIndex(t);
        return e.slice(n, o).filter((r, a, l) => t(r) ? !0 : !(a > 0 && l[a - 1] === r))
    }

    _createNestedToolbarDropdown(e, t, i) {
        let {label: n, icon: o, items: r, tooltip: a = !0, withText: l = !1} = e;
        if (r = this._cleanItemsConfiguration(r, t, i), !r.length) return null;
        const c = this.locale, u = Ae(c);
        return n || L("toolbarview-nested-toolbar-dropdown-missing-label", e), u.class = "ck-toolbar__nested-toolbar-dropdown", u.buttonView.set({
            label: n,
            tooltip: a,
            withText: !!l
        }), o !== !1 ? u.buttonView.icon = Hy[o] || o || fa : u.buttonView.withText = !0, qn(u, () => u.toolbarView._buildItemsFromConfig(r, t, i)), u
    }
}

class Uy extends T {
    children;

    constructor(e) {
        super(e), this.children = this.createCollection(), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-toolbar__items"]},
            children: this.children
        })
    }
}

class Rc {
    type = "static";

    constructor(e) {
        e.isGrouping = !1, e.itemsView.children.bindTo(e.items).using(t => t), e.focusables.bindTo(e.items).using(t => $n(t) ? t : null)
    }

    render() {
    }

    destroy() {
    }
}

class Vc {
    type = "dynamic";
    view;
    viewChildren;
    viewFocusables;
    viewItemsView;
    viewFocusTracker;
    viewLocale;
    ungroupedItems;
    groupedItems;
    groupedItemsDropdown;
    resizeObserver = null;
    cachedPadding = null;
    shouldUpdateGroupingOnNextResize = !1;
    viewElement;

    constructor(e) {
        this.view = e, this.viewChildren = e.children, this.viewFocusables = e.focusables, this.viewItemsView = e.itemsView, this.viewFocusTracker = e.focusTracker, this.viewLocale = e.locale, this.view.isGrouping = !0, this.ungroupedItems = e.createCollection(), this.groupedItems = e.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), e.itemsView.children.bindTo(this.ungroupedItems).using(t => t), this.ungroupedItems.on("change", this._updateFocusCyclableItems.bind(this)), e.children.on("change", this._updateFocusCyclableItems.bind(this)), e.items.on("change", (t, i) => {
            const n = i.index, o = Array.from(i.added);
            for (const r of i.removed) n >= this.ungroupedItems.length ? this.groupedItems.remove(r) : this.ungroupedItems.remove(r);
            for (let r = n; r < n + o.length; r++) {
                const a = o[r - n];
                r > this.ungroupedItems.length ? this.groupedItems.add(a, r - this.ungroupedItems.length) : this.ungroupedItems.add(a, r)
            }
            this._updateGrouping()
        })
    }

    render(e) {
        this.viewElement = e.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(e)
    }

    destroy() {
        this.groupedItemsDropdown.destroy(), this.viewChildren.length > 1 && (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last)), this.resizeObserver.destroy()
    }

    refreshItems() {
        const e = this.view;
        if (e.items.length) {
            for (let t = 0; t < e.items.length; t++) {
                const i = [...e.items][t];
                this.ungroupedItems.add(i, t)
            }
            this._updateGrouping()
        }
    }

    _updateGrouping() {
        if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) return;
        if (!ft(this.viewElement)) {
            this.shouldUpdateGroupingOnNextResize = !0;
            return
        }
        const e = this.groupedItems.length;
        let t;
        for (; this._areItemsOverflowing;) this._groupLastItem(), t = !0;
        if (!t && this.groupedItems.length) {
            for (; this.groupedItems.length && !this._areItemsOverflowing;) this._ungroupFirstItem();
            this._areItemsOverflowing && this._groupLastItem()
        }
        this.groupedItems.length !== e && this.view.fire("groupedItemsUpdate")
    }

    get _areItemsOverflowing() {
        if (!this.ungroupedItems.length) return !1;
        const e = this.viewElement, t = this.viewLocale.uiLanguageDirection, i = new R(e.lastChild), n = new R(e);
        if (!this.cachedPadding) {
            const o = C.window.getComputedStyle(e), r = t === "ltr" ? "paddingRight" : "paddingLeft";
            this.cachedPadding = Number.parseInt(o[r])
        }
        return t === "ltr" ? i.right > n.right - this.cachedPadding : i.left < n.left + this.cachedPadding
    }

    _enableGroupingOnResize() {
        let e;
        this.resizeObserver = new Q(this.viewElement, t => {
            (!e || e !== t.contentRect.width || this.shouldUpdateGroupingOnNextResize) && (this.shouldUpdateGroupingOnNextResize = !1, this._updateGrouping(), e = t.contentRect.width)
        }), this._updateGrouping()
    }

    _enableGroupingOnMaxWidthChange(e) {
        e.on("change:maxWidth", () => {
            this._updateGrouping()
        })
    }

    _groupLastItem() {
        this.groupedItems.length || (this.viewChildren.add(new wa), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0)
    }

    _ungroupFirstItem() {
        this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element))
    }

    _createGroupedItemsDropdown() {
        const e = this.viewLocale, t = e.t, i = Ae(e);
        return i.class = "ck-toolbar__grouped-dropdown", i.panelPosition = e.uiLanguageDirection === "ltr" ? "sw" : "se", qn(i, this.groupedItems), i.buttonView.set({
            label: t("Show more items"),
            tooltip: !0,
            tooltipPosition: e.uiLanguageDirection === "rtl" ? "se" : "sw",
            icon: fa
        }), i
    }

    _updateFocusCyclableItems() {
        this.viewFocusables.clear(), this.ungroupedItems.map(e => {
            $n(e) && this.viewFocusables.add(e)
        }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown)
    }
}

class Wn extends T {
    children;
    actionView;
    arrowView;
    keystrokes;
    focusTracker;

    constructor(e, t) {
        super(e);
        const i = this.bindTemplate;
        this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", !0), this.set("isOn", !1), this.set("isToggleable", !1), this.set("isVisible", !0), this.set("keystroke", void 0), this.set("withKeystroke", !1), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", !1), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", !1), this.children = this.createCollection(), this.actionView = this._createActionView(t), this.arrowView = this._createArrowView(), this.keystrokes = new ue, this.focusTracker = new se, this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-splitbutton", i.to("class"), i.if("isVisible", "ck-hidden", n => !n), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")]},
            children: this.children
        })
    }

    render() {
        super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (e, t) => {
            this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), t())
        }), this.keystrokes.set("arrowleft", (e, t) => {
            this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), t())
        })
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    focus() {
        this.actionView.focus()
    }

    _createActionView(e) {
        const t = e || new I;
        return e || t.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t.extendTemplate({attributes: {class: "ck-splitbutton__action"}}), t.delegate("execute").to(this), t
    }

    _createArrowView() {
        const e = new I, t = e.bindTemplate;
        return e.icon = io, e.extendTemplate({
            attributes: {
                class: ["ck-splitbutton__arrow"],
                "data-cke-tooltip-disabled": t.to("isOn"),
                "aria-haspopup": !0,
                "aria-expanded": t.to("isOn", i => String(i))
            }
        }), e.bind("isEnabled").to(this), e.bind("label").to(this), e.bind("tooltip").to(this), e.delegate("execute").to(this, "open"), e
    }
}

function Ae(s, e = Hf) {
    const t = typeof e == "function" ? new e(s) : e, i = new Ly(s), n = new Bn(s, t, i);
    return t.bind("isEnabled").to(n), t instanceof Wn ? t.arrowView.bind("isOn").to(n, "isOpen") : t.bind("isOn").to(n, "isOpen"), $y(n), n
}

function qn(s, e, t = {}) {
    s.extendTemplate({attributes: {class: ["ck-toolbar-dropdown"]}}), s.isOpen ? Oc(s, e, t) : s.once("change:isOpen", () => Oc(s, e, t), {priority: "highest"}), t.enableActiveItemFocusOnDropdownOpen && ba(s, () => s.toolbarView.items.find(i => i.isOn))
}

function Oc(s, e, t) {
    const i = s.locale, n = i.t, o = s.toolbarView = new oo(i), r = typeof e == "function" ? e() : e;
    o.ariaLabel = t.ariaLabel || n("Dropdown toolbar"), t.maxWidth && (o.maxWidth = t.maxWidth), t.class && (o.class = t.class), t.isCompact && (o.isCompact = t.isCompact), t.isVertical && (o.isVertical = !0), r instanceof Ie ? o.items.bindTo(r).using(a => a) : o.items.addMany(r), s.panelView.children.add(o), s.focusTracker.add(o), o.items.delegate("execute").to(s)
}

function jn(s, e, t = {}) {
    s.isOpen ? Mc(s, e, t) : s.once("change:isOpen", () => Mc(s, e, t), {priority: "highest"}), ba(s, () => s.listView.items.find(i => i instanceof Ke ? i.children.first.isOn : !1))
}

function Mc(s, e, t) {
    const i = s.locale, n = s.listView = new ui(i), o = typeof e == "function" ? e() : e;
    n.ariaLabel = t.ariaLabel, n.role = t.role, Wf(s, n.items, o, i), s.panelView.children.add(n), n.items.delegate("execute").to(s)
}

function ba(s, e) {
    s.on("change:isOpen", () => {
        if (!s.isOpen) return;
        const t = e();
        t && (typeof t.focus == "function" ? t.focus() : L("ui-dropdown-focus-child-on-open-child-missing-focus", {view: t}))
    }, {priority: Le.low - 10})
}

function $y(s) {
    Wy(s), qy(s), jy(s), Gy(s), Ky(s), Zy(s)
}

function Wy(s) {
    Ji({
        emitter: s, activator: () => s.isRendered && s.isOpen, callback: () => {
            s.isOpen = !1
        }, contextElements: () => [s.element, ...$f(s.focusTracker).filter(e => !s.element.contains(e))]
    })
}

function $f(s) {
    return [...s.elements, ...s.externalViews.flatMap(e => $f(e.focusTracker))]
}

function qy(s) {
    s.on("execute", e => {
        e.source instanceof Wi || (s.isOpen = !1)
    })
}

function jy(s) {
    s.focusTracker.on("change:isFocused", (e, t, i) => {
        i || !s.isOpen || (s.isOpen = !1)
    })
}

function Gy(s) {
    s.keystrokes.set("arrowdown", (e, t) => {
        s.isOpen && (s.panelView.focus(), t())
    }), s.keystrokes.set("arrowup", (e, t) => {
        s.isOpen && (s.panelView.focusLast(), t())
    })
}

function Ky(s) {
    s.on("change:isOpen", (e, t, i) => {
        if (i) return;
        s.focusTracker.elements.some(o => o.contains(C.document.activeElement)) && s.buttonView.focus()
    })
}

function Zy(s) {
    s.on("change:isOpen", (e, t, i) => {
        i && s.panelView.focus()
    }, {priority: "low"})
}

function Wf(s, e, t, i) {
    Jy(e), e.bindTo(t).using(n => {
        if (n.type === "separator") return new so(i);
        if (n.type === "group") {
            const o = new ys(i);
            return o.set({label: n.label}), Wf(s, o.items, n.items, i), o.items.delegate("execute").to(s), o
        } else if (n.type === "button" || n.type === "switchbutton") {
            const o = n.model.role === "menuitemcheckbox" || n.model.role === "menuitemradio", r = new Ke(i);
            let a;
            return n.type === "button" ? (a = new Qi(i), a.set({isToggleable: o})) : a = new Wi(i), a.bind(...Object.keys(n.model)).to(n.model), a.delegate("execute").to(r), r.children.add(a), r
        }
        return null
    })
}

function Jy(s) {
    let e = 0;
    const t = o => !(o instanceof Ke) || !(o.children.first instanceof Qi) ? null : o.children.first, i = o => {
        const r = t(o);
        return !r || !r.isToggleable ? null : r
    }, n = o => {
        for (const r of s) {
            const a = t(r);
            a && (a.hasCheckSpace = o)
        }
    };
    s.on("change", (o, r) => {
        const a = e > 0;
        for (const c of r.removed) i(c) && e--;
        for (const c of r.added) {
            const u = t(c);
            u && (u.isToggleable && e++, u.hasCheckSpace = e > 0)
        }
        const l = e > 0;
        a !== l && n(l)
    })
}

const ti = (s, e, t) => {
    const i = new By(s.locale);
    return i.set({
        id: e,
        ariaDescribedById: t
    }), i.bind("isReadOnly").to(s, "isEnabled", n => !n), i.bind("hasError").to(s, "errorText", n => !!n), i.on("input", () => {
        s.errorText = null
    }), s.bind("isEmpty", "isFocused", "placeholder").to(i), i
}, Qy = (s, e, t) => {
    const i = new Fy(s.locale);
    return i.set({
        id: e,
        ariaDescribedById: t,
        inputMode: "numeric"
    }), i.bind("isReadOnly").to(s, "isEnabled", n => !n), i.bind("hasError").to(s, "errorText", n => !!n), i.on("input", () => {
        s.errorText = null
    }), s.bind("isEmpty", "isFocused", "placeholder").to(i), i
}, Yy = 150;

class Xy extends T {
    hexInputRow;
    _debounceColorPickerEvent;
    _config;

    constructor(e, t = {}) {
        super(e), this.set({color: "", _hexColor: ""}), this.hexInputRow = this._createInputRow();
        const i = this.createCollection();
        t.hideInput || i.add(this.hexInputRow), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-color-picker"], tabindex: -1},
            children: i
        }), this._config = t, this._debounceColorPickerEvent = it(n => {
            this.set("color", n), this.fire("colorSelected", {color: this.color})
        }, Yy, {leading: !0}), this.on("set:color", (n, o, r) => {
            n.return = Df(r, this._config.format || "hsl")
        }), this.on("change:color", () => {
            this._hexColor = Lo(this.color)
        }), this.on("change:_hexColor", () => {
            document.activeElement !== this.picker && this.picker.setAttribute("color", this._hexColor), Lo(this.color) != Lo(this._hexColor) && (this.color = this._hexColor)
        })
    }

    render() {
        if (super.render(), Py("hex-color-picker", ny), this.picker = C.document.createElement("hex-color-picker"), this.picker.setAttribute("class", "hex-color-picker"), this.picker.setAttribute("tabindex", "-1"), this._createSlidersView(), this.element) {
            this.hexInputRow.element ? this.element.insertBefore(this.picker, this.hexInputRow.element) : this.element.appendChild(this.picker);
            const e = document.createElement("style");
            e.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}', this.picker.shadowRoot.appendChild(e)
        }
        this.picker.addEventListener("color-changed", e => {
            const t = e.detail.value;
            this._debounceColorPickerEvent(t)
        })
    }

    focus() {/* istanbul ignore next -- @preserve */
        !this._config.hideInput && (x.isGecko || x.isiOS || x.isSafari || x.isBlink) && this.hexInputRow.children.get(1).focus(), this.slidersView.first.focus()
    }

    _createSlidersView() {
        const i = [...this.picker.shadowRoot.children].filter(n => n.getAttribute("role") === "slider").map(n => new ek(n));
        this.slidersView = this.createCollection(), i.forEach(n => {
            this.slidersView.add(n)
        })
    }

    _createInputRow() {
        const e = this._createColorInput();
        return new ik(this.locale, e)
    }

    _createColorInput() {
        const e = new Ut(this.locale, ti), {t} = this.locale;
        return e.set({
            label: t("HEX"),
            class: "color-picker-hex-input"
        }), e.fieldView.bind("value").to(this, "_hexColor", i => e.isFocused ? e.fieldView.value : i.startsWith("#") ? i.substring(1) : i), e.fieldView.on("input", () => {
            const i = e.fieldView.element.value;
            if (i) {
                const n = qf(i);
                n && this._debounceColorPickerEvent(n)
            }
        }), e
    }

    isValid() {
        const {t: e} = this.locale;
        return this._config.hideInput ? !0 : (this.resetValidationStatus(), this.hexInputRow.getParsedColor() ? !0 : (this.hexInputRow.inputView.errorText = e('Please enter a valid color (e.g. "ff0000").'), !1))
    }

    resetValidationStatus() {
        this.hexInputRow.inputView.errorText = null
    }
}

function Lo(s) {
    let e = Sy(s);
    return e || (e = "#000"), e.length === 4 && (e = "#" + [e[1], e[1], e[2], e[2], e[3], e[3]].join("")), e.toLowerCase()
}

class ek extends T {
    constructor(e) {
        super(), this.element = e
    }

    focus() {
        this.element.focus()
    }
}

class tk extends T {
    constructor(e) {
        super(e), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-color-picker__hash-view"]},
            children: "#"
        })
    }
}

class ik extends T {
    children;
    inputView;

    constructor(e, t) {
        super(e), this.inputView = t, this.children = this.createCollection([new tk, this.inputView]), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-color-picker__row"]},
            children: this.children
        })
    }

    getParsedColor() {
        return qf(this.inputView.fieldView.element.value)
    }
}

function qf(s) {
    if (!s) return null;
    const e = s.trim().replace(/^#/, "");
    return ![3, 4, 6, 8].includes(e.length) || !/^(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})$/.test(e) ? null : `#${e}`
}

class nk extends H(ce) {
    constructor(e) {
        super(e), this.set("isEmpty", !0), this.on("change", () => {
            this.set("isEmpty", this.length === 0)
        })
    }

    add(e, t) {
        return this.find(i => i.color === e.color) ? this : super.add(e, t)
    }

    hasColor(e) {
        return !!this.find(t => t.color === e)
    }
}

class sk extends T {
    items;
    colorDefinitions;
    focusTracker;
    columns;
    documentColors;
    documentColorsCount;
    staticColorsGrid;
    documentColorsGrid;
    colorPickerButtonView;
    removeColorButtonView;
    _focusables;
    _documentColorsLabel;
    _removeButtonLabel;
    _colorPickerLabel;

    constructor(e, {
        colors: t,
        columns: i,
        removeButtonLabel: n,
        documentColorsLabel: o,
        documentColorsCount: r,
        colorPickerLabel: a,
        focusTracker: l,
        focusables: c
    }) {
        super(e);
        const u = this.bindTemplate;
        this.set("isVisible", !0), this.focusTracker = l, this.items = this.createCollection(), this.colorDefinitions = t, this.columns = i, this.documentColors = new nk, this.documentColorsCount = r, this._focusables = c, this._removeButtonLabel = n, this._colorPickerLabel = a, this._documentColorsLabel = o, this.setTemplate({
            tag: "div",
            attributes: {class: ["ck-color-grids-fragment", u.if("isVisible", "ck-hidden", d => !d)]},
            children: this.items
        }), this.removeColorButtonView = this._createRemoveColorButton(), this.items.add(this.removeColorButtonView)
    }

    updateDocumentColors(e, t) {
        const i = e.document, n = this.documentColorsCount;
        this.documentColors.clear();
        for (const o of i.getRoots()) {
            const r = e.createRangeIn(o);
            for (const a of r.getItems()) if (a.is("$textProxy") && a.hasAttribute(t) && (this._addColorToDocumentColors(a.getAttribute(t)), this.documentColors.length >= n)) return
        }
    }

    updateSelectedColors() {
        const e = this.documentColorsGrid, t = this.staticColorsGrid, i = this.selectedColor;
        t.selectedColor = i, e && (e.selectedColor = i)
    }

    render() {
        if (super.render(), this.staticColorsGrid = this._createStaticColorsGrid(), this.items.add(this.staticColorsGrid), this.documentColorsCount) {
            const e = Te.bind(this.documentColors, this.documentColors), t = new T(this.locale);
            t.setTemplate({
                tag: "span",
                attributes: {class: ["ck", "ck-color-grid__label", e.if("isEmpty", "ck-hidden")]},
                children: [{text: this._documentColorsLabel}]
            }), this.items.add(t), this.documentColorsGrid = this._createDocumentColorsGrid(), this.items.add(this.documentColorsGrid)
        }
        this._createColorPickerButton(), this._addColorSelectorElementsToFocusTracker()
    }

    focus() {
        this.removeColorButtonView.focus()
    }

    destroy() {
        super.destroy()
    }

    addColorPickerButton() {
        this.colorPickerButtonView && (this.items.add(this.colorPickerButtonView), this.focusTracker.add(this.colorPickerButtonView.element), this._focusables.add(this.colorPickerButtonView))
    }

    _addColorSelectorElementsToFocusTracker() {
        this.focusTracker.add(this.removeColorButtonView.element), this._focusables.add(this.removeColorButtonView), this.staticColorsGrid && (this.focusTracker.add(this.staticColorsGrid.element), this._focusables.add(this.staticColorsGrid)), this.documentColorsGrid && (this.focusTracker.add(this.documentColorsGrid.element), this._focusables.add(this.documentColorsGrid))
    }

    _createColorPickerButton() {
        this.colorPickerButtonView = new I, this.colorPickerButtonView.set({
            label: this._colorPickerLabel,
            withText: !0,
            icon: Zv,
            class: "ck-color-selector__color-picker"
        }), this.colorPickerButtonView.on("execute", () => {
            this.fire("colorPicker:show")
        })
    }

    _createRemoveColorButton() {
        const e = new I;
        return e.set({
            withText: !0,
            icon: vr,
            label: this._removeButtonLabel
        }), e.class = "ck-color-selector__remove-color", e.on("execute", () => {
            this.fire("execute", {value: null, source: "removeColorButton"})
        }), e.render(), e
    }

    _createStaticColorsGrid() {
        const e = new Sc(this.locale, {colorDefinitions: this.colorDefinitions, columns: this.columns});
        return e.on("execute", (t, i) => {
            this.fire("execute", {value: i.value, source: "staticColorsGrid"})
        }), e
    }

    _createDocumentColorsGrid() {
        const e = Te.bind(this.documentColors, this.documentColors), t = new Sc(this.locale, {columns: this.columns});
        return t.extendTemplate({attributes: {class: e.if("isEmpty", "ck-hidden")}}), t.items.bindTo(this.documentColors).using(i => {
            const n = new Lf;
            return n.set({color: i.color, hasBorder: i.options?.hasBorder}), i.label && n.set({
                label: i.label,
                tooltip: !0
            }), n.on("execute", () => {
                this.fire("execute", {value: i.color, source: "documentColorsGrid"})
            }), n
        }), this.documentColors.on("change:isEmpty", (i, n, o) => {
            o && (t.selectedColor = null)
        }), t
    }

    _addColorToDocumentColors(e) {
        const t = this.colorDefinitions.find(i => i.color === e);
        t ? this.documentColors.add(Object.assign({}, t)) : this.documentColors.add({
            color: e,
            label: e,
            options: {hasBorder: !1}
        })
    }
}

class ok extends T {
    items;
    colorPickerView;
    saveButtonView;
    cancelButtonView;
    actionBarView;
    focusTracker;
    keystrokes;
    _focusables;
    _colorPickerViewConfig;

    constructor(e, {focusTracker: t, focusables: i, keystrokes: n, colorPickerViewConfig: o}) {
        super(e), this.items = this.createCollection(), this.focusTracker = t, this.keystrokes = n, this.set("isVisible", !1), this.set("selectedColor", void 0), this._focusables = i, this._colorPickerViewConfig = o;
        const r = this.bindTemplate, {saveButtonView: a, cancelButtonView: l} = this._createActionButtons();
        this.saveButtonView = a, this.cancelButtonView = l, this.actionBarView = this._createActionBarView({
            saveButtonView: a,
            cancelButtonView: l
        }), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck-color-picker-fragment", r.if("isVisible", "ck-hidden", c => !c)]},
            children: this.items
        })
    }

    render() {
        super.render();
        const e = new Xy(this.locale, {...this._colorPickerViewConfig});
        this.colorPickerView = e, this.colorPickerView.render(), this.selectedColor && (e.color = this.selectedColor), this.listenTo(this, "change:selectedColor", (t, i, n) => {
            e.color = n
        }), this.items.add(this.colorPickerView), this.items.add(this.actionBarView), this._addColorPickersElementsToFocusTracker(), this._stopPropagationOnArrowsKeys(), this._executeOnEnterPress(), this._executeUponColorChange()
    }

    destroy() {
        super.destroy()
    }

    focus() {
        this.colorPickerView.focus()
    }

    resetValidationStatus() {
        this.colorPickerView.resetValidationStatus()
    }

    _executeOnEnterPress() {
        this.keystrokes.set("enter", e => {
            this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element && this.colorPickerView.isValid() && (this.fire("execute", {value: this.selectedColor}), e.stopPropagation(), e.preventDefault())
        })
    }

    _stopPropagationOnArrowsKeys() {
        const e = t => t.stopPropagation();
        this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e)
    }

    _addColorPickersElementsToFocusTracker() {
        for (const t of this.colorPickerView.slidersView) this.focusTracker.add(t.element), this._focusables.add(t);
        const e = this.colorPickerView.hexInputRow.children.get(1);
        e.element && (this.focusTracker.add(e.element), this._focusables.add(e)), this.focusTracker.add(this.saveButtonView.element), this._focusables.add(this.saveButtonView), this.focusTracker.add(this.cancelButtonView.element), this._focusables.add(this.cancelButtonView)
    }

    _createActionBarView({saveButtonView: e, cancelButtonView: t}) {
        const i = new T, n = this.createCollection();
        return n.add(e), n.add(t), i.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-color-selector_action-bar"]},
            children: n
        }), i
    }

    _createActionButtons() {
        const e = this.locale, t = e.t, i = new I(e), n = new I(e);
        return i.set({
            icon: ff,
            class: "ck-button-save",
            type: "button",
            withText: !1,
            label: t("Accept")
        }), n.set({
            icon: hf,
            class: "ck-button-cancel",
            type: "button",
            withText: !1,
            label: t("Cancel")
        }), i.on("execute", () => {
            this.colorPickerView.isValid() && this.fire("execute", {
                source: "colorPickerSaveButton",
                value: this.selectedColor
            })
        }), n.on("execute", () => {
            this.fire("colorPicker:cancel")
        }), {saveButtonView: i, cancelButtonView: n}
    }

    _executeUponColorChange() {
        this.colorPickerView.on("colorSelected", (e, t) => {
            this.fire("execute", {value: t.color, source: "colorPicker"}), this.set("selectedColor", t.color)
        })
    }
}

class jf extends T {
    focusTracker;
    keystrokes;
    items;
    colorGridsFragmentView;
    colorPickerFragmentView;
    _focusCycler;
    _focusables;
    _colorPickerViewConfig;

    constructor(e, {
        colors: t,
        columns: i,
        removeButtonLabel: n,
        documentColorsLabel: o,
        documentColorsCount: r,
        colorPickerLabel: a,
        colorPickerViewConfig: l
    }) {
        super(e), this.items = this.createCollection(), this.focusTracker = new se, this.keystrokes = new ue, this._focusables = new Ie, this._colorPickerViewConfig = l, this._focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"}
        }), this.colorGridsFragmentView = new sk(e, {
            colors: t,
            columns: i,
            removeButtonLabel: n,
            documentColorsLabel: o,
            documentColorsCount: r,
            colorPickerLabel: a,
            focusTracker: this.focusTracker,
            focusables: this._focusables
        }), this.colorPickerFragmentView = new ok(e, {
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokes: this.keystrokes,
            colorPickerViewConfig: l
        }), this.set("_isColorGridsFragmentVisible", !0), this.set("_isColorPickerFragmentVisible", !1), this.set("selectedColor", void 0), this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible"), this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible"), this.on("change:selectedColor", (c, u, d) => {
            this.colorGridsFragmentView.set("selectedColor", d), this.colorPickerFragmentView.set("selectedColor", d)
        }), this.colorGridsFragmentView.on("change:selectedColor", (c, u, d) => {
            this.set("selectedColor", d)
        }), this.colorPickerFragmentView.on("change:selectedColor", (c, u, d) => {
            this.set("selectedColor", d)
        }), this.setTemplate({tag: "div", attributes: {class: ["ck", "ck-color-selector"]}, children: this.items})
    }

    render() {
        super.render(), this.keystrokes.listenTo(this.element)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    appendUI() {
        this._appendColorGridsFragment(), this._colorPickerViewConfig && this._appendColorPickerFragment()
    }

    showColorPickerFragment() {
        !this.colorPickerFragmentView.colorPickerView || this._isColorPickerFragmentVisible || (this._isColorPickerFragmentVisible = !0, this.colorPickerFragmentView.focus(), this.colorPickerFragmentView.resetValidationStatus(), this._isColorGridsFragmentVisible = !1)
    }

    showColorGridsFragment() {
        this._isColorGridsFragmentVisible || (this._isColorGridsFragmentVisible = !0, this.colorGridsFragmentView.focus(), this._isColorPickerFragmentVisible = !1)
    }

    focus() {
        this._focusCycler.focusFirst()
    }

    focusLast() {
        this._focusCycler.focusLast()
    }

    updateDocumentColors(e, t) {
        this.colorGridsFragmentView.updateDocumentColors(e, t)
    }

    updateSelectedColors() {
        this.colorGridsFragmentView.updateSelectedColors()
    }

    _appendColorGridsFragment() {
        this.items.length || (this.items.add(this.colorGridsFragmentView), this.colorGridsFragmentView.delegate("execute").to(this), this.colorGridsFragmentView.delegate("colorPicker:show").to(this))
    }

    _appendColorPickerFragment() {
        this.items.length !== 2 && (this.items.add(this.colorPickerFragmentView), this.colorGridsFragmentView.colorPickerButtonView && this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
            this.showColorPickerFragment()
        }), this.colorGridsFragmentView.addColorPickerButton(), this.colorPickerFragmentView.delegate("execute").to(this), this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this))
    }
}

class rk {
    editor;
    _components = new Map;

    constructor(e) {
        this.editor = e
    }

    * names() {
        for (const e of this._components.values()) yield e.originalName
    }

    add(e, t) {
        this._components.set(Do(e), {callback: t, originalName: e})
    }

    create(e) {
        if (!this.has(e)) throw new p("componentfactory-item-missing", this, {name: e});
        return this._components.get(Do(e)).callback(this.editor.locale)
    }

    has(e) {
        return this._components.has(Do(e))
    }
}

function Do(s) {
    return String(s).toLowerCase()
}

const Bc = "ck-tooltip";

class ye extends xe() {
    tooltipTextView;
    balloonPanelView;
    static defaultBalloonPositions = Be.generatePositions({heightOffset: 5, sideOffset: 13});
    _currentElementWithTooltip = null;
    _currentTooltipPosition = null;
    _mutationObserver = null;
    _pinTooltipDebounced;
    _unpinTooltipDebounced;
    _watchdogExcluded;
    static _editors = new Set;
    static _instance = null;

    constructor(e) {
        if (super(), ye._editors.add(e), ye._instance) return ye._instance;
        ye._instance = this, this.tooltipTextView = new T(e.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({
            tag: "span",
            attributes: {class: ["ck", "ck-tooltip__text"]},
            children: [{text: this.tooltipTextView.bindTemplate.to("text")}]
        }), this.balloonPanelView = new Be(e.locale), this.balloonPanelView.class = Bc, this.balloonPanelView.content.add(this.tooltipTextView), this._mutationObserver = ak(() => {
            this._updateTooltipPosition()
        }), this._pinTooltipDebounced = it(this._pinTooltip, 600), this._unpinTooltipDebounced = it(this._unpinTooltip, 400), this.listenTo(C.document, "keydown", this._onKeyDown.bind(this), {useCapture: !0}), this.listenTo(C.document, "mouseenter", this._onEnterOrFocus.bind(this), {useCapture: !0}), this.listenTo(C.document, "mouseleave", this._onLeaveOrBlur.bind(this), {useCapture: !0}), this.listenTo(C.document, "focus", this._onEnterOrFocus.bind(this), {useCapture: !0}), this.listenTo(C.document, "blur", this._onLeaveOrBlur.bind(this), {useCapture: !0}), this.listenTo(C.document, "scroll", this._onScroll.bind(this), {useCapture: !0}), this._watchdogExcluded = !0
    }

    destroy(e) {
        const t = e.ui.view && e.ui.view.body;
        ye._editors.delete(e), this.stopListening(e.ui), t && t.has(this.balloonPanelView) && t.remove(this.balloonPanelView), ye._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), ye._instance = null)
    }

    static getPositioningFunctions(e) {
        const t = ye.defaultBalloonPositions;
        return {
            s: [t.southArrowNorth, t.southArrowNorthEast, t.southArrowNorthWest],
            n: [t.northArrowSouth],
            e: [t.eastArrowWest],
            w: [t.westArrowEast],
            sw: [t.southArrowNorthEast],
            se: [t.southArrowNorthWest]
        }[e]
    }

    _onKeyDown(e, t) {
        t.key === "Escape" && this._currentElementWithTooltip && (this._unpinTooltip(), t.stopPropagation())
    }

    _onEnterOrFocus(e, {target: t}) {
        const i = No(t);
        if (!i) {
            e.name === "focus" && this._unpinTooltip();
            return
        }
        if (i === this._currentElementWithTooltip) {
            this._unpinTooltipDebounced.cancel();
            return
        }
        this._unpinTooltip(), e.name === "focus" && !i.matches(":hover") || i.matches("[data-cke-tooltip-instant]") ? this._pinTooltip(i, zo(i)) : this._pinTooltipDebounced(i, zo(i))
    }

    _onLeaveOrBlur(e, {target: t, relatedTarget: i}) {
        if (e.name === "mouseleave") {
            if (!At(t)) return;
            const n = this.balloonPanelView.element, o = n && (n === i || n.contains(i)), r = !o && t === n;
            if (o) {
                this._unpinTooltipDebounced.cancel();
                return
            }
            if (!r && this._currentElementWithTooltip && t !== this._currentElementWithTooltip) return;
            const a = No(t), l = No(i);
            (r || a && a !== l) && (this._pinTooltipDebounced.cancel(), this._currentElementWithTooltip && this._currentElementWithTooltip.matches("[data-cke-tooltip-instant]") || a && a.matches("[data-cke-tooltip-instant]") ? this._unpinTooltip() : this._unpinTooltipDebounced())
        } else {
            if (this._currentElementWithTooltip && t !== this._currentElementWithTooltip) return;
            this._pinTooltipDebounced.cancel(), this._unpinTooltipDebounced()
        }
    }

    _onScroll(e, {target: t}) {
        this._currentElementWithTooltip && (t.contains(this.balloonPanelView.element) && t.contains(this._currentElementWithTooltip) || this._unpinTooltip())
    }

    _pinTooltip(e, {text: t, position: i, cssClass: n}) {
        this._unpinTooltip();
        const o = re(ye._editors.values()).ui.view.body;
        o.has(this.balloonPanelView) || o.add(this.balloonPanelView), this.tooltipTextView.text = t, this.balloonPanelView.class = [Bc, n].filter(r => r).join(" "), this.balloonPanelView.pin({
            target: e,
            positions: ye.getPositioningFunctions(i)
        }), this._mutationObserver.attach(e);
        for (const r of ye._editors) this.listenTo(r.ui, "update", this._updateTooltipPosition.bind(this), {priority: "low"});
        this._currentElementWithTooltip = e, this._currentTooltipPosition = i
    }

    _unpinTooltip() {
        this._unpinTooltipDebounced.cancel(), this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
        for (const e of ye._editors) this.stopListening(e.ui, "update");
        this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this.tooltipTextView.text = "", this._mutationObserver.detach()
    }

    _updateTooltipPosition() {
        if (!this._currentElementWithTooltip) return;
        const e = zo(this._currentElementWithTooltip);
        if (!ft(this._currentElementWithTooltip) || !e.text) {
            this._unpinTooltip();
            return
        }
        this.balloonPanelView.pin({
            target: this._currentElementWithTooltip,
            positions: ye.getPositioningFunctions(e.position)
        })
    }
}

function No(s) {
    return At(s) ? s.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null
}

function zo(s) {
    return {
        text: s.dataset.ckeTooltipText,
        position: s.dataset.ckeTooltipPosition || "s",
        cssClass: s.dataset.ckeTooltipClass || ""
    }
}

function ak(s) {
    const e = new MutationObserver(() => {
        s()
    });
    return {
        attach(t) {
            e.observe(t, {attributes: !0, attributeFilter: ["data-cke-tooltip-text", "data-cke-tooltip-position"]})
        }, detach() {
            e.disconnect()
        }
    }
}

const lk = 50, ck = 350;

class Gf extends xe() {
    editor;
    _balloonView = null;
    _showBalloonThrottled = Ni(() => this._showBalloon(), 50, {leading: !0});
    _lastFocusedEditableElement = null;
    _balloonClass;

    constructor(e, t = {}) {
        super(), this.editor = e, this._balloonClass = t.balloonClass, e.on("ready", () => this._handleEditorReady())
    }

    destroy() {
        const e = this._balloonView;
        e && (e.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening()
    }

    _handleEditorReady() {
        const e = this.editor;
        this._isEnabled() && e.ui.view && (e.ui.focusTracker.on("change:isFocused", (t, i, n) => {
            this._updateLastFocusedEditableElement(), n ? this._showBalloon() : this._hideBalloon()
        }), e.ui.focusTracker.on("change:focusedElement", (t, i, n) => {
            this._updateLastFocusedEditableElement(), n && this._showBalloon()
        }), e.ui.on("update", () => {
            this._showBalloonThrottled()
        }))
    }

    _getNormalizedConfig() {
        return {
            side: this.editor.locale.contentLanguageDirection === "ltr" ? "right" : "left",
            position: "border",
            verticalOffset: 0,
            horizontalOffset: 5
        }
    }

    _showBalloon() {
        const e = this._getBalloonAttachOptions();
        e && (this._balloonView || (this._balloonView = this._createBalloonView()), this._balloonView.pin(e))
    }

    _hideBalloon() {
        this._balloonView && this._balloonView.unpin()
    }

    _createBalloonView() {
        const e = this.editor, t = new Be, i = this._createBadgeContent();
        return t.content.add(i), this._balloonClass && (t.class = this._balloonClass), e.ui.view.body.add(t), t
    }

    _getBalloonAttachOptions() {
        if (!this._lastFocusedEditableElement) return null;
        const e = this._getNormalizedConfig(),
            t = e.side === "right" ? uk(this._lastFocusedEditableElement, e) : dk(this._lastFocusedEditableElement, e);
        return {target: this._lastFocusedEditableElement, positions: [t]}
    }

    _updateLastFocusedEditableElement() {
        const e = this.editor, t = e.ui.focusTracker.isFocused, i = e.ui.focusTracker.focusedElement;
        if (!t || !i) {
            this._lastFocusedEditableElement = null;
            return
        }
        const n = Array.from(e.ui.getEditableElementsNames()).map(o => e.ui.getEditableElement(o));
        n.includes(i) ? this._lastFocusedEditableElement = i : this._lastFocusedEditableElement = n[0]
    }
}

function uk(s, e) {
    return Kf(s, e, (t, i) => t.left + t.width - i.width - e.horizontalOffset)
}

function dk(s, e) {
    return Kf(s, e, t => t.left + e.horizontalOffset)
}

function Kf(s, e, t) {
    return (i, n) => {
        const o = new R(s);
        if (o.width < ck || o.height < lk) return null;
        let r;
        e.position === "inside" ? r = o.bottom - n.height : r = o.bottom - n.height / 2, r -= e.verticalOffset;
        const a = t(o, n), c = i.clone().moveTo(a, r).getIntersection(n.clone().moveTo(a, r)).getVisible();
        return !c || c.getArea() < n.getArea() ? null : {
            top: r,
            left: a,
            name: `position_${e.position}-side_${e.side}`,
            config: {withArrow: !1}
        }
    }
}

const hk = "Powered by";

class fk extends Gf {
    constructor(e) {
        super(e, {balloonClass: "ck-powered-by-balloon"})
    }

    _isEnabled() {
        const e = this.editor;
        if (e.config.get("ui.poweredBy.forceVisible")) return !0;
        const i = e.config.get("licenseKey");
        if (i == "GPL") return !0;
        const n = ea(i.split(".")[1]);
        return n ? !n.whiteLabel : !0
    }

    _createBadgeContent() {
        return new mk(this.editor.locale, this._getNormalizedConfig().label)
    }

    _getNormalizedConfig() {
        const e = super._getNormalizedConfig(), t = this.editor.config.get("ui.poweredBy") || {},
            i = t.position || e.position, n = i === "inside" ? 5 : e.verticalOffset;
        return {
            position: i,
            side: t.side || e.side,
            label: t.label === void 0 ? hk : t.label,
            verticalOffset: t.verticalOffset !== void 0 ? t.verticalOffset : n,
            horizontalOffset: t.horizontalOffset !== void 0 ? t.horizontalOffset : e.horizontalOffset,
            forceVisible: !!t.forceVisible
        }
    }
}

class mk extends T {
    constructor(e, t) {
        super(e);
        const i = new ot, n = this.bindTemplate;
        i.set({content: k1, isColorInherited: !1}), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-powered-by"], "aria-hidden": !0},
            children: [{
                tag: "a",
                attributes: {
                    href: "https://ckeditor.com/powered-by-ckeditor/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
                    target: "_blank",
                    tabindex: "-1"
                },
                children: [...t ? [{
                    tag: "span",
                    attributes: {class: ["ck", "ck-powered-by__label"]},
                    children: [t]
                }] : [], i],
                on: {dragstart: n.to(o => o.preventDefault())}
            }]
        })
    }
}

class gk extends Gf {
    licenseTypeMessage = {
        evaluation: "For evaluation purposes only",
        trial: "For evaluation purposes only",
        development: "For development purposes only"
    };

    constructor(e) {
        super(e, {balloonClass: "ck-evaluation-badge-balloon"})
    }

    _isEnabled() {
        const t = this.editor.config.get("licenseKey"), i = Fc(t);
        return !!(i && this.licenseTypeMessage[i])
    }

    _createBadgeContent() {
        const e = this.editor.config.get("licenseKey"), t = Fc(e);
        return new pk(this.editor.locale, this.licenseTypeMessage[t])
    }

    _getNormalizedConfig() {
        const e = super._getNormalizedConfig(), t = this.editor.config.get("ui.poweredBy") || {},
            i = t.position || e.position, n = t.side || e.side;
        return {
            position: i,
            side: n === "left" ? "right" : "left",
            verticalOffset: e.verticalOffset,
            horizontalOffset: e.horizontalOffset
        }
    }
}

class pk extends T {
    constructor(e, t) {
        super(e), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-evaluation-badge"], "aria-hidden": !0},
            children: [{tag: "span", attributes: {class: ["ck", "ck-evaluation-badge__label"]}, children: [t]}]
        })
    }
}

function Fc(s) {
    if (s == "GPL") return "GPL";
    const e = ea(s.split(".")[1]);
    return e ? e.licenseType || "production" : null
}

const Lc = {POLITE: "polite", ASSERTIVE: "assertive"};

class wk {
    editor;
    view;

    constructor(e) {
        this.editor = e, e.once("ready", () => {
            for (const t of Object.values(Lc)) this.announce("", t)
        })
    }

    announce(e, t = Lc.POLITE) {
        const i = this.editor;
        if (!i.ui.view) return;
        this.view || (this.view = new bk(i.locale), i.ui.view.body.add(this.view));
        const {politeness: n, isUnsafeHTML: o} = typeof t == "string" ? {politeness: t} : t;
        let r = this.view.regionViews.find(a => a.politeness === n);
        r || (r = new _k(i, n), this.view.regionViews.add(r)), r.announce({announcement: e, isUnsafeHTML: o})
    }
}

class bk extends T {
    regionViews;

    constructor(e) {
        super(e), this.regionViews = this.createCollection(), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-aria-live-announcer"]},
            children: this.regionViews
        })
    }
}

class _k extends T {
    politeness;
    _domConverter;
    _pruneAnnouncementsInterval;

    constructor(e, t) {
        super(e.locale), this.setTemplate({
            tag: "div",
            attributes: {"aria-live": t, "aria-relevant": "additions"},
            children: [{tag: "ul", attributes: {class: ["ck", "ck-aria-live-region-list"]}}]
        }), e.on("destroy", () => {
            this._pruneAnnouncementsInterval !== null && (clearInterval(this._pruneAnnouncementsInterval), this._pruneAnnouncementsInterval = null)
        }), this.politeness = t, this._domConverter = e.data.htmlProcessor.domConverter, this._pruneAnnouncementsInterval = setInterval(() => {
            this.element && this._listElement.firstChild && this._listElement.firstChild.remove()
        }, 5e3)
    }

    announce({announcement: e, isUnsafeHTML: t}) {
        if (!e.trim().length) return;
        const i = document.createElement("li");
        t ? this._domConverter.setContentOf(i, e) : i.innerText = e, this._listElement.appendChild(i)
    }

    get _listElement() {
        return this.element.querySelector("ul")
    }
}

class St extends Ke {
    constructor(e, t) {
        super(e);
        const i = this.bindTemplate;
        this.extendTemplate({
            attributes: {class: ["ck-menu-bar__menu__item"]},
            on: {mouseenter: i.to("mouseenter")}
        }), this.delegate("mouseenter").to(t)
    }
}

const ss = 5, wi = {
    toggleMenusAndFocusItemsOnHover(s) {
        s.on("menu:mouseenter", e => {
            if (!(!s.isFocusBorderEnabled && !s.isOpen)) {
                if (s.isOpen) for (const t of s.menus) {
                    const i = e.path[0], n = i instanceof St && i.children.first === t;
                    t.isOpen = (e.path.includes(t) || n) && t.isEnabled
                }
                e.source.focus()
            }
        })
    }, focusCycleMenusOnArrows(s) {
        const e = s.locale.uiLanguageDirection === "rtl";
        s.on("menu:arrowright", i => {
            t(i.source, e ? -1 : 1)
        }), s.on("menu:arrowleft", i => {
            t(i.source, e ? 1 : -1)
        });

        function t(i, n) {
            const o = s.children.getIndex(i), r = i.isOpen, a = s.children.length, l = s.children.get((o + a + n) % a);
            i.isOpen = !1, r && (l.isOpen = !0), l.buttonView.focus()
        }
    }, closeMenusWhenTheBarCloses(s) {
        s.on("change:isOpen", () => {
            s.isOpen || s.menus.forEach(e => {
                e.isOpen = !1
            })
        })
    }, closeMenuWhenAnotherOnTheSameLevelOpens(s) {
        s.on("menu:change:isOpen", (e, t, i) => {
            i && s.menus.filter(n => e.source.parentMenuView === n.parentMenuView && e.source !== n && n.isOpen).forEach(n => {
                n.isOpen = !1
            })
        })
    }, closeOnClickOutside(s) {
        Ji({
            emitter: s,
            activator: () => s.isOpen,
            callback: () => s.close(),
            contextElements: () => s.children.map(e => e.element)
        })
    }, enableFocusHighlightOnInteraction(s) {
        let e = !1;
        s.on("change:isOpen", (t, i, n) => {
            n || (e || (s.isFocusBorderEnabled = !1), e = !1)
        }), s.listenTo(s.element, "keydown", () => {
            e = !0
        }, {useCapture: !0}), s.listenTo(s.element, "keyup", () => {
            e = !1
        }, {useCapture: !0}), s.listenTo(s.element, "focus", () => {
            e && (s.isFocusBorderEnabled = !0)
        }, {useCapture: !0})
    }
}, Rt = {
    openAndFocusPanelOnArrowDownKey(s) {
        s.keystrokes.set("arrowdown", (e, t) => {
            s.isEnabled && s.focusTracker.focusedElement === s.buttonView.element && (s.isOpen || (s.isOpen = !0), s.panelView.focus(), t())
        })
    }, openOnArrowRightKey(s) {
        const e = s.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
        s.keystrokes.set(e, (t, i) => {
            s.focusTracker.focusedElement !== s.buttonView.element || !s.isEnabled || (s.isOpen || (s.isOpen = !0), s.panelView.focus(), i())
        })
    }, openOnButtonClick(s) {
        s.buttonView.on("execute", () => {
            s.isOpen = !0
        })
    }, toggleOnButtonClick(s) {
        s.buttonView.on("execute", () => {
            s.isOpen = !s.isOpen
        })
    }, openAndFocusOnEnterKeyPress(s) {
        s.keystrokes.set("enter", (e, t) => {
            s.focusTracker.focusedElement === s.buttonView.element && (s.isOpen = !0, s.panelView.focus(), t())
        })
    }, closeOnArrowLeftKey(s) {
        const e = s.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
        s.keystrokes.set(e, (t, i) => {
            s.isOpen && (s.isOpen = !1, s.focus(), i())
        })
    }, closeOnEscKey(s) {
        s.keystrokes.set("esc", (e, t) => {
            s.isOpen && (s.isOpen = !1, s.focus(), t())
        })
    }, closeOnParentClose(s) {
        s.parentMenuView.on("change:isOpen", (e, t, i) => {
            !i && e.source === s.parentMenuView && (s.isOpen = !1)
        })
    }
}, vk = {
    southEast: s => ({top: s.bottom, left: s.left, name: "se"}),
    southWest: (s, e) => ({top: s.bottom, left: s.left - e.width + s.width, name: "sw"}),
    northEast: (s, e) => ({top: s.top - e.height, left: s.left, name: "ne"}),
    northWest: (s, e) => ({top: s.top - e.height, left: s.left - e.width + s.width, name: "nw"}),
    eastSouth: s => ({top: s.top, left: s.right - ss, name: "es"}),
    eastNorth: (s, e) => ({top: s.top - e.height, left: s.right - ss, name: "en"}),
    westSouth: (s, e) => ({top: s.top, left: s.left - e.width + ss, name: "ws"}),
    westNorth: (s, e) => ({top: s.top - e.height, left: s.left - e.width + ss, name: "wn"})
}, yk = [{
    menuId: "file",
    label: "File",
    groups: [{groupId: "export", items: ["menuBar:exportPdf", "menuBar:exportWord"]}, {
        groupId: "import",
        items: ["menuBar:importWord"]
    }, {groupId: "revisionHistory", items: ["menuBar:revisionHistory"]}]
}, {
    menuId: "edit",
    label: "Edit",
    groups: [{groupId: "undo", items: ["menuBar:undo", "menuBar:redo"]}, {
        groupId: "selectAll",
        items: ["menuBar:selectAll"]
    }, {groupId: "findAndReplace", items: ["menuBar:findAndReplace"]}]
}, {
    menuId: "view",
    label: "View",
    groups: [{groupId: "sourceEditingEnhanced", items: ["menuBar:sourceEditingEnhanced"]}, {
        groupId: "sourceEditing",
        items: ["menuBar:sourceEditing"]
    }, {groupId: "showBlocks", items: ["menuBar:showBlocks"]}, {
        groupId: "previewMergeFields",
        items: ["menuBar:previewMergeFields"]
    }, {groupId: "fullscreen", items: ["menuBar:fullscreen"]}, {
        groupId: "restrictedEditing",
        items: ["menuBar:restrictedEditing"]
    }]
}, {
    menuId: "insert",
    label: "Insert",
    groups: [{
        groupId: "insertMainWidgets",
        items: ["menuBar:insertImage", "menuBar:ckbox", "menuBar:ckfinder", "menuBar:insertTable", "menuBar:insertTableLayout"]
    }, {
        groupId: "insertInline",
        items: ["menuBar:link", "menuBar:bookmark", "menuBar:comment", "menuBar:insertMergeField", "menuBar:emoji"]
    }, {
        groupId: "insertMinorWidgets",
        items: ["menuBar:mediaEmbed", "menuBar:insertTemplate", "menuBar:specialCharacters", "menuBar:blockQuote", "menuBar:codeBlock", "menuBar:htmlEmbed"]
    }, {
        groupId: "insertStructureWidgets",
        items: ["menuBar:horizontalLine", "menuBar:pageBreak", "menuBar:tableOfContents"]
    }, {groupId: "restrictedEditingException", items: ["menuBar:restrictedEditingException"]}]
}, {
    menuId: "format",
    label: "Format",
    groups: [{
        groupId: "textAndFont",
        items: [{
            menuId: "text",
            label: "Text",
            groups: [{
                groupId: "basicStyles",
                items: ["menuBar:bold", "menuBar:italic", "menuBar:underline", "menuBar:strikethrough", "menuBar:superscript", "menuBar:subscript", "menuBar:code"]
            }, {groupId: "textPartLanguage", items: ["menuBar:textPartLanguage"]}]
        }, {
            menuId: "font",
            label: "Font",
            groups: [{
                groupId: "fontProperties",
                items: ["menuBar:fontSize", "menuBar:fontFamily"]
            }, {
                groupId: "fontColors",
                items: ["menuBar:fontColor", "menuBar:fontBackgroundColor"]
            }, {groupId: "highlight", items: ["menuBar:highlight"]}]
        }, "menuBar:heading"]
    }, {
        groupId: "list",
        items: ["menuBar:bulletedList", "menuBar:numberedList", "menuBar:multiLevelList", "menuBar:todoList"]
    }, {groupId: "indent", items: ["menuBar:alignment", "menuBar:indent", "menuBar:outdent"]}, {
        groupId: "caseChange",
        items: ["menuBar:caseChange"]
    }, {groupId: "removeFormat", items: ["menuBar:removeFormat"]}]
}, {
    menuId: "tools",
    label: "Tools",
    groups: [{groupId: "aiTools", items: ["menuBar:aiAssistant", "menuBar:aiCommands"]}, {
        groupId: "tools",
        items: ["menuBar:trackChanges", "menuBar:commentsArchive"]
    }]
}, {menuId: "help", label: "Help", groups: [{groupId: "help", items: ["menuBar:accessibilityHelp"]}]}];

function kk(s) {
    let e;
    return !("items" in s) || !s.items ? e = {
        items: Ve(yk),
        addItems: [],
        removeItems: [],
        isVisible: !0,
        isUsingDefaultConfig: !0, ...s
    } : e = {items: s.items, removeItems: [], addItems: [], isVisible: !0, isUsingDefaultConfig: !1, ...s}, e
}

function Ck({normalizedConfig: s, locale: e, componentFactory: t, extraItems: i}) {
    const n = Ve(s);
    return Dc(s, n, i), Ek(s, n), Dc(s, n, n.addItems), Tk(s, n, t), Zf(s, n), Ak(n, e), n
}

function Ek(s, e) {
    const t = e.removeItems, i = [];
    e.items = e.items.filter(({menuId: n}) => t.includes(n) ? (i.push(n), !1) : !0), Yi(e.items, n => {
        n.groups = n.groups.filter(({groupId: o}) => t.includes(o) ? (i.push(o), !1) : !0);
        for (const o of n.groups) o.items = o.items.filter(r => {
            const a = Jf(r);
            return t.includes(a) ? (i.push(a), !1) : !0
        })
    });
    for (const n of t) i.includes(n) || L("menu-bar-item-could-not-be-removed", {menuBarConfig: s, itemName: n})
}

function Dc(s, e, t) {
    const i = [];
    if (t.length != 0) {
        for (const n of t) {
            const o = Sk(n.position), r = Pk(n.position);
            if (xk(n)) if (!r) o === "start" ? (e.items.unshift(n.menu), i.push(n)) : o === "end" && (e.items.push(n.menu), i.push(n)); else {
                const a = e.items.findIndex(l => l.menuId === r);
                a != -1 ? o === "before" ? (e.items.splice(a, 0, n.menu), i.push(n)) : o === "after" && (e.items.splice(a + 1, 0, n.menu), i.push(n)) : Nc(e, n.menu, r, o) && i.push(n)
            } else Ik(n) ? Yi(e.items, a => {
                if (a.menuId === r) o === "start" ? (a.groups.unshift(n.group), i.push(n)) : o === "end" && (a.groups.push(n.group), i.push(n)); else {
                    const l = a.groups.findIndex(c => c.groupId === r);
                    l !== -1 && (o === "before" ? (a.groups.splice(l, 0, n.group), i.push(n)) : o === "after" && (a.groups.splice(l + 1, 0, n.group), i.push(n)))
                }
            }) : Nc(e, n.item, r, o) && i.push(n)
        }
        for (const n of t) i.includes(n) || L("menu-bar-item-could-not-be-added", {
            menuBarConfig: s,
            addedItemConfig: n
        })
    }
}

function Nc(s, e, t, i) {
    let n = !1;
    return Yi(s.items, o => {
        for (const {groupId: r, items: a} of o.groups) {
            if (n) return;
            if (r === t) i === "start" ? (a.unshift(e), n = !0) : i === "end" && (a.push(e), n = !0); else {
                const l = a.findIndex(c => Jf(c) === t);
                l !== -1 && (i === "before" ? (a.splice(l, 0, e), n = !0) : i === "after" && (a.splice(l + 1, 0, e), n = !0))
            }
        }
    }), n
}

function Tk(s, e, t) {
    Yi(e.items, i => {
        for (const n of i.groups) n.items = n.items.filter(o => {
            const r = typeof o == "string" && !t.has(o);
            return r && !e.isUsingDefaultConfig && L("menu-bar-item-unavailable", {
                menuBarConfig: s,
                parentMenuConfig: Ve(i),
                componentName: o
            }), !r
        })
    })
}

function Zf(s, e) {
    const t = e.isUsingDefaultConfig;
    let i = !1;
    if (e.items = e.items.filter(n => n.groups.length ? !0 : (Ho(s, n, t), !1)), !e.items.length) {
        Ho(s, s, t);
        return
    }
    Yi(e.items, n => {
        n.groups = n.groups.filter(o => o.items.length ? !0 : (i = !0, !1));
        for (const o of n.groups) o.items = o.items.filter(r => Qf(r) && !r.groups.length ? (Ho(s, r, t), i = !0, !1) : !0)
    }), i && Zf(s, e)
}

function Ho(s, e, t) {
    t || L("menu-bar-menu-empty", {menuBarConfig: s, emptyMenuConfig: e})
}

function Ak(s, e) {
    const t = e.t, i = {
        File: t({string: "File", id: "MENU_BAR_MENU_FILE"}),
        Edit: t({string: "Edit", id: "MENU_BAR_MENU_EDIT"}),
        View: t({string: "View", id: "MENU_BAR_MENU_VIEW"}),
        Insert: t({string: "Insert", id: "MENU_BAR_MENU_INSERT"}),
        Format: t({string: "Format", id: "MENU_BAR_MENU_FORMAT"}),
        Tools: t({string: "Tools", id: "MENU_BAR_MENU_TOOLS"}),
        Help: t({string: "Help", id: "MENU_BAR_MENU_HELP"}),
        Text: t({string: "Text", id: "MENU_BAR_MENU_TEXT"}),
        Font: t({string: "Font", id: "MENU_BAR_MENU_FONT"})
    };
    Yi(s.items, n => {
        n.label in i && (n.label = i[n.label])
    })
}

function Yi(s, e) {
    if (Array.isArray(s)) for (const i of s) t(i);

    function t(i) {
        e(i);
        for (const n of i.groups) for (const o of n.items) Qf(o) && t(o)
    }
}

function xk(s) {
    return typeof s == "object" && "menu" in s
}

function Ik(s) {
    return typeof s == "object" && "group" in s
}

function Sk(s) {
    return s.startsWith("start") ? "start" : s.startsWith("end") ? "end" : s.startsWith("after") ? "after" : "before"
}

function Pk(s) {
    const e = s.match(/^[^:]+:(.+)/);
    return e ? e[1] : null
}

function Jf(s) {
    return typeof s == "string" ? s : s.menuId
}

function Qf(s) {
    return typeof s == "object" && "menuId" in s
}

class Rk extends H() {
    editor;
    componentFactory;
    focusTracker;
    tooltipManager;
    poweredBy;
    evaluationBadge;
    ariaLiveAnnouncer;
    isReady = !1;
    _editableElementsMap = new Map;
    _focusableToolbarDefinitions = [];
    _extraMenuBarElements = [];
    _lastFocusedForeignElement = null;
    _domEmitter;

    constructor(e) {
        super();
        const t = e.editing.view;
        this.editor = e, this.componentFactory = new rk(e), this.focusTracker = new se, this.tooltipManager = new ye(e), this.poweredBy = new fk(e), this.evaluationBadge = new gk(e), this.ariaLiveAnnouncer = new wk(e), this._initViewportOffset(this._readViewportOffsetFromConfig()), this.once("ready", () => {
            this._bindBodyCollectionWithFocusTracker(), this.isReady = !0
        }), this.listenTo(t.document, "layoutChanged", this.update.bind(this)), this.listenTo(t, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this)), this._initFocusTracking(), this._initVisualViewportSupport()
    }

    get element() {
        return null
    }

    update() {
        this.fire("update")
    }

    destroy() {
        this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy(), this.evaluationBadge.destroy();
        for (const e of this._editableElementsMap.values()) e.ckeditorInstance = null, this.editor.keystrokes.stopListening(e);
        this._editableElementsMap = new Map, this._focusableToolbarDefinitions = [], this._domEmitter && this._domEmitter.stopListening()
    }

    setEditableElement(e, t) {
        this._editableElementsMap.set(e, t), t.ckeditorInstance || (t.ckeditorInstance = this.editor), this.focusTracker.add(t);
        const i = () => {
            this.editor.editing.view.getDomRoot(e) || this.editor.keystrokes.listenTo(t)
        };
        this.isReady ? i() : this.once("ready", i)
    }

    removeEditableElement(e) {
        const t = this._editableElementsMap.get(e);
        t && (this._editableElementsMap.delete(e), this.editor.keystrokes.stopListening(t), this.focusTracker.remove(t), t.ckeditorInstance = null)
    }

    getEditableElement(e = "main") {
        return this._editableElementsMap.get(e)
    }

    getEditableElementsNames() {
        return this._editableElementsMap.keys()
    }

    addToolbar(e, t = {}) {
        e.isRendered ? (this.focusTracker.add(e), this.editor.keystrokes.listenTo(e.element)) : e.once("render", () => {
            this.focusTracker.add(e), this.editor.keystrokes.listenTo(e.element)
        }), this._focusableToolbarDefinitions.push({toolbarView: e, options: t})
    }

    extendMenuBar(e) {
        this._extraMenuBarElements.push(e)
    }

    get _editableElements() {
        return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {editorUI: this}), this._editableElementsMap
    }

    initMenuBar(e) {
        const t = e.element;
        this.focusTracker.add(t), this.editor.keystrokes.listenTo(t);
        const i = kk(this.editor.config.get("menuBar") || {});
        e.fillFromConfig(i, this.componentFactory, this._extraMenuBarElements), this.editor.keystrokes.set("Esc", (n, o) => {
            t.contains(this.editor.ui.focusTracker.focusedElement) && (this._lastFocusedForeignElement ? (this._lastFocusedForeignElement.focus(), this._lastFocusedForeignElement = null) : this.editor.editing.view.focus(), o())
        }), this.editor.keystrokes.set("Alt+F9", (n, o) => {
            t.contains(this.editor.ui.focusTracker.focusedElement) || (this._saveLastFocusedForeignElement(), e.isFocusBorderEnabled = !0, e.focus(), o())
        })
    }

    _readViewportOffsetFromConfig() {
        const e = this.editor, t = e.config.get("ui.viewportOffset");
        if (t) return t;
        const i = e.config.get("toolbar.viewportTopOffset");
        return i ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), {top: i}) : {top: 0}
    }

    _initFocusTracking() {
        const e = this.editor;
        let t;
        e.keystrokes.set("Alt+F10", (i, n) => {
            this._saveLastFocusedForeignElement();
            const o = this._getCurrentFocusedToolbarDefinition();
            (!o || !t) && (t = this._getFocusableCandidateToolbarDefinitions());
            for (let r = 0; r < t.length; r++) {
                const a = t.shift();
                if (t.push(a), a !== o && this._focusFocusableCandidateToolbar(a)) {
                    o && o.options.afterBlur && o.options.afterBlur();
                    break
                }
            }
            n()
        }), e.keystrokes.set("Esc", (i, n) => {
            const o = this._getCurrentFocusedToolbarDefinition();
            o && (this._lastFocusedForeignElement ? (this._lastFocusedForeignElement.focus(), this._lastFocusedForeignElement = null) : e.editing.view.focus(), o.options.afterBlur && o.options.afterBlur(), n())
        })
    }

    _saveLastFocusedForeignElement() {
        const e = this.focusTracker.focusedElement;
        Array.from(this._editableElementsMap.values()).includes(e) && !Array.from(this.editor.editing.view.domRoots.values()).includes(e) && (this._lastFocusedForeignElement = e)
    }

    _getFocusableCandidateToolbarDefinitions() {
        const e = [];
        for (const t of this._focusableToolbarDefinitions) {
            const {toolbarView: i, options: n} = t;
            (ft(i.element) || n.beforeFocus) && e.push(t)
        }
        return e.sort((t, i) => zc(t) - zc(i)), e
    }

    _getCurrentFocusedToolbarDefinition() {
        for (const e of this._focusableToolbarDefinitions) if (e.toolbarView.element && e.toolbarView.element.contains(this.focusTracker.focusedElement)) return e;
        return null
    }

    _focusFocusableCandidateToolbar(e) {
        const {toolbarView: t, options: {beforeFocus: i}} = e;
        return i && i(), ft(t.element) ? (t.focus(), !0) : !1
    }

    _handleScrollToTheSelection(e, t) {
        const i = {top: 0, bottom: 0, left: 0, right: 0, ...this.viewportOffset};
        t.viewportOffset.top += i.top, t.viewportOffset.bottom += i.bottom, t.viewportOffset.left += i.left, t.viewportOffset.right += i.right
    }

    _bindBodyCollectionWithFocusTracker() {
        const e = this.view.body;
        for (const t of e) this.focusTracker.add(t.element);
        e.on("add", (t, i) => {
            this.focusTracker.add(i.element)
        }), e.on("remove", (t, i) => {
            this.focusTracker.remove(i.element)
        })
    }

    _initViewportOffset(e) {
        this.on("set:viewportOffset", (t, i, n) => {
            const o = this._getVisualViewportTopOffset(n);
            n.visualTop !== o && (t.return = {...n, visualTop: o})
        }), this.set("viewportOffset", e)
    }

    _initVisualViewportSupport() {
        if (!C.window.visualViewport) return;
        const e = () => {
            const t = this._getVisualViewportTopOffset(this.viewportOffset);
            this.viewportOffset.visualTop !== t && (this.viewportOffset = {...this.viewportOffset, visualTop: t})
        };
        this._domEmitter = new (xe()), this._domEmitter.listenTo(C.window.visualViewport, "scroll", e), this._domEmitter.listenTo(C.window.visualViewport, "resize", e)
    }

    _getVisualViewportTopOffset(e) {
        const t = _s().top, i = e.top || 0;
        return t > i ? 0 : i - t
    }
}

function zc(s) {
    const {toolbarView: e, options: t} = s;
    let i = 10;
    return ft(e.element) && i--, t.isContextual && (i -= 2), i
}

class Vk extends T {
    body;
    menuBarView;
    toolbar;

    constructor(e) {
        super(e), this.body = new Qe(e)
    }

    render() {
        super.render(), this.body.attachToDom()
    }

    destroy() {
        return this.body.detachFromDom(), super.destroy()
    }
}

class Ok extends Vk {
    top;
    main;
    _voiceLabelView;

    constructor(e) {
        super(e), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"],
                role: "application",
                dir: e.uiLanguageDirection,
                lang: e.uiLanguage,
                "aria-labelledby": this._voiceLabelView.id
            },
            children: [this._voiceLabelView, {
                tag: "div",
                attributes: {class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation"},
                children: this.top
            }, {tag: "div", attributes: {class: ["ck", "ck-editor__main"], role: "presentation"}, children: this.main}]
        })
    }

    _createVoiceLabel() {
        const e = this.t, t = new no;
        return t.text = e("Rich Text Editor"), t.extendTemplate({attributes: {class: "ck-voice-label"}}), t
    }
}

class Mk extends T {
    name = null;
    _editingView;
    _editableElement;
    _hasExternalElement;

    constructor(e, t, i) {
        super(e), this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"],
                lang: e.contentLanguage,
                dir: e.contentLanguageDirection
            }
        }), this.set("isFocused", !1), this._editableElement = i, this._hasExternalElement = !!this._editableElement, this._editingView = t
    }

    render() {
        super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses()
    }

    destroy() {
        this._hasExternalElement && this.template.revert(this._editableElement), super.destroy()
    }

    get hasExternalElement() {
        return this._hasExternalElement
    }

    _updateIsFocusedClasses() {
        const e = this._editingView;
        e.isRenderingInProgress ? i(this) : t(this);

        function t(n) {
            e.change(o => {
                const r = e.document.getRoot(n.name);
                o.addClass(n.isFocused ? "ck-focused" : "ck-blurred", r), o.removeClass(n.isFocused ? "ck-blurred" : "ck-focused", r)
            })
        }

        function i(n) {
            e.once("change:isRenderingInProgress", (o, r, a) => {
                a ? i(n) : t(n)
            })
        }
    }
}

class Bk extends Mk {
    _options;

    constructor(e, t, i, n = {}) {
        super(e, t, i), this._options = n, this.extendTemplate({
            attributes: {
                role: "textbox",
                class: "ck-editor__editable_inline"
            }
        })
    }

    render() {
        super.render();
        const e = this._editingView;
        e.change(t => {
            const i = e.document.getRoot(this.name);
            t.setAttribute("aria-label", this.getEditableAriaLabel(), i)
        })
    }

    getEditableAriaLabel() {
        const e = this.locale.t, t = this._options.label, i = this._editableElement, n = this.name;
        if (typeof t == "string") return t;
        if (typeof t == "object") return t[n];
        if (typeof t == "function") return t(this);
        if (i) {
            const o = i.getAttribute("aria-label");
            if (o) return o
        }
        return e("Rich Text Editor. Editing area: %0", n)
    }
}

class Hs extends T {
    children;

    constructor(e, t = {}) {
        super(e);
        const i = this.bindTemplate;
        this.set("class", ["ck", "ck-form__row", ...U(t.class || [])]), this.children = this.createCollection(), t.children && t.children.forEach(n => this.children.add(n)), this.set("_role", null), this.set("_ariaLabelledBy", null), t.labelView && this.set({
            _role: "group",
            _ariaLabelledBy: t.labelView.id
        }), this.setTemplate({
            tag: "div",
            attributes: {
                class: i.to("class", n => n.join(" ")),
                role: i.to("_role"),
                "aria-labelledby": i.to("_ariaLabelledBy")
            },
            children: this.children
        })
    }
}

class Hc extends cf {
    static get pluginName() {
        return "Notification"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        this.on("show:warning", (e, t) => {
            window.alert(t.message)
        }, {priority: "lowest"})
    }

    showSuccess(e, t = {}) {
        this._showNotification({message: e, type: "success", namespace: t.namespace, title: t.title})
    }

    showInfo(e, t = {}) {
        this._showNotification({message: e, type: "info", namespace: t.namespace, title: t.title})
    }

    showWarning(e, t = {}) {
        this._showNotification({message: e, type: "warning", namespace: t.namespace, title: t.title})
    }

    _showNotification(e) {
        const t = e.namespace ? `show:${e.type}:${e.namespace}` : `show:${e.type}`;
        this.fire(t, {message: e.message, type: e.type, title: e.title || ""})
    }
}

class qi extends H() {
    constructor(e, t) {
        super(), t && Hd(this, t), e && this.set(e)
    }
}

const os = Hn("px");

class ii extends w {
    positionLimiter;
    visibleStack;
    _viewToStack = new Map;
    _idToStack = new Map;
    _view = null;
    _rotatorView = null;
    _fakePanelsView = null;

    static get pluginName() {
        return "ContextualBalloon"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), this.positionLimiter = () => {
            const t = this.editor.editing.view, n = t.document.selection.editableElement;
            return n ? t.domConverter.mapViewToDom(n.root) : null
        }, this.decorate("getPositionOptions"), this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", !1)
    }

    destroy() {
        super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy()
    }

    get view() {
        return this._view || this._createPanelView(), this._view
    }

    hasView(e) {
        return Array.from(this._viewToStack.keys()).includes(e)
    }

    add(e) {
        if (this._view || this._createPanelView(), this.hasView(e.view)) throw new p("contextualballoon-add-view-exist", [this, e]);
        const t = e.stackId || "main";
        if (!this._idToStack.has(t)) {
            this._idToStack.set(t, new Map([[e.view, e]])), this._viewToStack.set(e.view, this._idToStack.get(t)), this._numberOfStacks = this._idToStack.size, (!this._visibleStack || e.singleViewMode) && this.showStack(t);
            return
        }
        const i = this._idToStack.get(t);
        e.singleViewMode && this.showStack(t), i.set(e.view, e), this._viewToStack.set(e.view, i), i === this._visibleStack && this._showView(e)
    }

    remove(e) {
        if (!this.hasView(e)) throw new p("contextualballoon-remove-view-not-exist", [this, e]);
        const t = this._viewToStack.get(e);
        this._singleViewMode && this.visibleView === e && (this._singleViewMode = !1), this.visibleView === e && (t.size === 1 ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(t.values())[t.size - 2])), t.size === 1 ? (this._idToStack.delete(this._getStackId(t)), this._numberOfStacks = this._idToStack.size) : t.delete(e), this._viewToStack.delete(e)
    }

    updatePosition(e) {
        e && (this._visibleStack.get(this.visibleView).position = e), this.view.pin(this.getPositionOptions()), this._fakePanelsView.updatePosition()
    }

    getPositionOptions() {
        let e = Array.from(this._visibleStack.values()).pop().position;
        return e && (e.limiter || (e = Object.assign({}, e, {limiter: this.positionLimiter})), e = Object.assign({}, e, {
            viewportOffsetConfig: {
                ...this.editor.ui.viewportOffset,
                top: this.editor.ui.viewportOffset.visualTop
            }
        })), e
    }

    showStack(e) {
        this.visibleStack = e;
        const t = this._idToStack.get(e);
        if (!t) throw new p("contextualballoon-showstack-stack-not-exist", this);
        this._visibleStack !== t && this._showView(Array.from(t.values()).pop())
    }

    _createPanelView() {
        this._view = new Be(this.editor.locale), this.editor.ui.view.body.add(this._view), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView()
    }

    get _visibleStack() {
        return this._viewToStack.get(this.visibleView)
    }

    _getStackId(e) {
        return Array.from(this._idToStack.entries()).find(i => i[1] === e)[0]
    }

    _showNextStack() {
        const e = Array.from(this._idToStack.values());
        let t = e.indexOf(this._visibleStack) + 1;
        e[t] || (t = 0), this.showStack(this._getStackId(e[t]))
    }

    _showPrevStack() {
        const e = Array.from(this._idToStack.values());
        let t = e.indexOf(this._visibleStack) - 1;
        e[t] || (t = e.length - 1), this.showStack(this._getStackId(e[t]))
    }

    _createRotatorView() {
        const e = new Fk(this.editor.locale), t = this.editor.locale.t;
        return this.view.content.add(e), e.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (i, n) => !n && i > 1), e.on("change:isNavigationVisible", () => this.updatePosition(), {priority: "low"}), e.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (i, n) => {
            if (n < 2) return "";
            const o = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
            return t("%0 of %1", [o, n])
        }), e.buttonNextView.on("execute", () => {
            e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack()
        }), e.buttonPrevView.on("execute", () => {
            e.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack()
        }), e
    }

    _createFakePanelsView() {
        const e = new Lk(this.editor.locale, this.view);
        return e.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t, i) => !i && t >= 2 ? Math.min(t - 1, 2) : 0), e.listenTo(this.view, "change:top", () => e.updatePosition()), e.listenTo(this.view, "change:left", () => e.updatePosition()), this.editor.ui.view.body.add(e), e
    }

    _showView({view: e, balloonClassName: t = "", withArrow: i = !0, singleViewMode: n = !1}) {
        this.view.class = t, this.view.withArrow = i, this._rotatorView.showView(e), this.visibleView = e, this.view.pin(this.getPositionOptions()), this._fakePanelsView.updatePosition(), n && (this._singleViewMode = !0)
    }
}

class Fk extends T {
    focusTracker;
    buttonPrevView;
    buttonNextView;
    content;

    constructor(e) {
        super(e);
        const t = e.t, i = this.bindTemplate;
        this.set("isNavigationVisible", !0), this.focusTracker = new se, this.buttonPrevView = this._createButtonView(t("Previous"), Ht), this.buttonNextView = this._createButtonView(t("Next"), gf), this.content = this.createCollection(), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-balloon-rotator"], "z-index": "-1"},
            children: [{
                tag: "div",
                attributes: {class: ["ck-balloon-rotator__navigation", i.to("isNavigationVisible", n => n ? "" : "ck-hidden")]},
                children: [this.buttonPrevView, {
                    tag: "span",
                    attributes: {class: ["ck-balloon-rotator__counter"]},
                    children: [{text: i.to("counter")}]
                }, this.buttonNextView]
            }, {tag: "div", attributes: {class: "ck-balloon-rotator__content"}, children: this.content}]
        })
    }

    render() {
        super.render(), this.focusTracker.add(this.element)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy()
    }

    showView(e) {
        this.hideView(), this.content.add(e)
    }

    hideView() {
        this.content.clear()
    }

    _createButtonView(e, t) {
        const i = new I(this.locale);
        return i.set({label: e, icon: t, tooltip: !0}), i
    }
}

class Lk extends T {
    content;
    _balloonPanelView;

    constructor(e, t) {
        super(e);
        const i = this.bindTemplate;
        this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = t, this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck-fake-panel", i.to("numberOfPanels", n => n ? "" : "ck-hidden")],
                style: {
                    top: i.to("top", os),
                    left: i.to("left", os),
                    width: i.to("width", os),
                    height: i.to("height", os)
                }
            },
            children: this.content
        }), this.on("change:numberOfPanels", (n, o, r, a) => {
            r > a ? this._addPanels(r - a) : this._removePanels(a - r), this.updatePosition()
        })
    }

    _addPanels(e) {
        for (; e--;) {
            const t = new T;
            t.setTemplate({tag: "div"}), this.content.add(t), this.registerChild(t)
        }
    }

    _removePanels(e) {
        for (; e--;) {
            const t = this.content.last;
            this.content.remove(t), this.deregisterChild(t), t.destroy()
        }
    }

    updatePosition() {
        if (this.numberOfPanels) {
            const {top: e, left: t} = this._balloonPanelView, {
                width: i,
                height: n
            } = new R(this._balloonPanelView.element);
            Object.assign(this, {top: e, left: t, width: i, height: n})
        }
    }
}

const bi = Hn("px");

class Dk extends T {
    content;
    contentPanelElement;
    _contentPanelPlaceholder;

    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.set("isActive", !1), this.set("isSticky", !1), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheBottomOfLimiter", !1), this.set("_stickyTopOffset", null), this.set("_stickyBottomOffset", null), this.content = this.createCollection(), this._contentPanelPlaceholder = new Te({
            tag: "div",
            attributes: {
                class: ["ck", "ck-sticky-panel__placeholder"],
                style: {
                    display: t.to("isSticky", i => i ? "block" : "none"),
                    height: t.to("isSticky", i => i ? bi(this._contentPanelRect.height) : null)
                }
            }
        }).render(), this.contentPanelElement = new Te({
            tag: "div",
            attributes: {
                class: ["ck", "ck-sticky-panel__content", t.if("isSticky", "ck-sticky-panel__content_sticky"), t.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")],
                style: {
                    width: t.to("isSticky", i => i ? bi(this._contentPanelPlaceholder.getBoundingClientRect().width) : null),
                    top: t.to("_stickyTopOffset", i => i && bi(i)),
                    bottom: t.to("_stickyBottomOffset", i => i && bi(i)),
                    marginLeft: t.to("_marginLeft")
                }
            },
            children: this.content
        }).render(), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-sticky-panel"]},
            children: [this._contentPanelPlaceholder, this.contentPanelElement]
        })
    }

    render() {
        super.render(), this.checkIfShouldBeSticky(), this.listenTo(C.document, "scroll", () => {
            this.checkIfShouldBeSticky()
        }, {useCapture: !0}), this.listenTo(this, "change:isActive", () => {
            this.checkIfShouldBeSticky()
        }), C.window.visualViewport && (this.listenTo(C.window.visualViewport, "scroll", () => {
            this.checkIfShouldBeSticky()
        }), this.listenTo(C.window.visualViewport, "resize", () => {
            this.checkIfShouldBeSticky()
        }))
    }

    checkIfShouldBeSticky() {
        if (!this.limiterElement || !this.isActive) {
            this._unstick();
            return
        }
        const e = new R(this.limiterElement);
        let t = e.getVisible();
        if (t) {
            const o = new R(C.window);
            o.top += this.viewportTopOffset, o.height -= this.viewportTopOffset, t = t.getIntersection(o)
        }
        const {left: i, top: n} = _s();
        if (e.moveBy(i, n), t && t.moveBy(i, n), t && e.top < t.top) if (this._contentPanelRect.height + this.limiterBottomOffset > t.height) {
            const o = Math.max(e.bottom - t.bottom, 0) + this.limiterBottomOffset;
            this._contentPanelRect.height + o + 1 < e.height ? this._stickToBottomOfLimiter(o) : this._unstick()
        } else this._contentPanelRect.height + this.limiterBottomOffset < e.height ? this._stickToTopOfAncestors(t.top) : this._unstick(); else this._unstick()
    }

    _stickToTopOfAncestors(e) {
        this.isSticky = !0, this._isStickyToTheBottomOfLimiter = !1, this._stickyTopOffset = e, this._stickyBottomOffset = null, this._marginLeft = bi(-C.window.scrollX + _s().left)
    }

    _stickToBottomOfLimiter(e) {
        this.isSticky = !0, this._isStickyToTheBottomOfLimiter = !0, this._stickyTopOffset = null, this._stickyBottomOffset = e, this._marginLeft = bi(-C.window.scrollX + _s().left)
    }

    _unstick() {
        this.isSticky = !1, this._isStickyToTheBottomOfLimiter = !1, this._stickyTopOffset = null, this._stickyBottomOffset = null, this._marginLeft = null
    }

    get _contentPanelRect() {
        return new R(this.contentPanelElement)
    }
}

class Nk extends Qi {
    arrowView;

    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.set({
            withText: !0,
            role: "menuitem"
        }), this.arrowView = this._createArrowView(), this.extendTemplate({
            attributes: {
                class: ["ck-menu-bar__menu__button"],
                "aria-haspopup": !0,
                "aria-expanded": this.bindTemplate.to("isOn", i => String(i)),
                "data-cke-tooltip-disabled": t.to("isOn")
            }, on: {mouseenter: t.to("mouseenter")}
        })
    }

    render() {
        super.render(), this.children.add(this.arrowView)
    }

    _createArrowView() {
        const e = new ot;
        return e.content = io, e.extendTemplate({attributes: {class: "ck-menu-bar__menu__button__arrow"}}), e
    }
}

class zk extends T {
    children;

    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.set("isVisible", !1), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-reset", "ck-menu-bar__menu__panel", t.to("position", i => `ck-menu-bar__menu__panel_position_${i}`), t.if("isVisible", "ck-hidden", i => !i)],
                tabindex: "-1"
            },
            children: this.children,
            on: {
                selectstart: t.to(i => {
                    i.target.tagName.toLocaleLowerCase() !== "input" && i.preventDefault()
                })
            }
        })
    }

    focus(e = 1) {
        this.children.length && (e === 1 ? this.children.first.focus() : this.children.last.focus())
    }
}

class Ne extends T {
    buttonView;
    panelView;
    focusTracker;
    keystrokes;

    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.buttonView = new Nk(e), this.buttonView.delegate("mouseenter").to(this), this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled"), this.panelView = new zk(e), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new ue, this.focusTracker = new se, this.set("isOpen", !1), this.set("isEnabled", !0), this.set("panelPosition", "w"), this.set("class", void 0), this.set("parentMenuView", null), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-menu-bar__menu", t.to("class"), t.if("isEnabled", "ck-disabled", i => !i), t.if("parentMenuView", "ck-menu-bar__menu_top-level", i => !i)]},
            children: [this.buttonView, this.panelView]
        })
    }

    render() {
        super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.keystrokes.listenTo(this.element), Rt.closeOnEscKey(this), this._repositionPanelOnOpen()
    }

    _attachBehaviors() {
        this.parentMenuView ? (Rt.openOnButtonClick(this), Rt.openOnArrowRightKey(this), Rt.closeOnArrowLeftKey(this), Rt.openAndFocusOnEnterKeyPress(this), Rt.closeOnParentClose(this)) : (this._propagateArrowKeystrokeEvents(), Rt.openAndFocusPanelOnArrowDownKey(this), Rt.toggleOnButtonClick(this))
    }

    _propagateArrowKeystrokeEvents() {
        this.keystrokes.set("arrowright", (e, t) => {
            this.fire("arrowright"), t()
        }), this.keystrokes.set("arrowleft", (e, t) => {
            this.fire("arrowleft"), t()
        })
    }

    _repositionPanelOnOpen() {
        this.on("change:isOpen", (e, t, i) => {
            if (!i) return;
            const n = Ne._getOptimalPosition({
                element: this.panelView.element,
                target: this.buttonView.element,
                fitInViewport: !0,
                positions: this._panelPositions
            });
            this.panelView.position = n ? n.name : this._defaultMenuPositionName
        })
    }

    focus() {
        this.buttonView.focus()
    }

    get _panelPositions() {
        const {
            southEast: e,
            southWest: t,
            northEast: i,
            northWest: n,
            westSouth: o,
            eastSouth: r,
            westNorth: a,
            eastNorth: l
        } = vk;
        return this.locale.uiLanguageDirection === "ltr" ? this.parentMenuView ? [r, l, o, a] : [e, t, i, n] : this.parentMenuView ? [o, a, r, l] : [t, e, n, i]
    }

    get _defaultMenuPositionName() {
        return this.locale.uiLanguageDirection === "ltr" ? this.parentMenuView ? "es" : "se" : this.parentMenuView ? "ws" : "sw"
    }

    static _getOptimalPosition = Zr
}

class $t extends ui {
    constructor(e) {
        super(e), this.role = "menu", this.items.on("change", this._setItemsCheckSpace.bind(this))
    }

    _setItemsCheckSpace() {
        const e = Array.from(this.items).some(t => {
            const i = Uc(t);
            return i && i.isToggleable
        });
        this.items.forEach(t => {
            const i = Uc(t);
            i && (i.hasCheckSpace = e)
        })
    }
}

function Uc(s) {
    return s instanceof Ke ? s.children.map(e => Hk(e) ? e.buttonView : e).find(e => e instanceof Qi) : null
}

function Hk(s) {
    return typeof s == "object" && "buttonView" in s && s.buttonView instanceof I
}

class Yf extends Ey {
    constructor(e) {
        super(e), this.set({
            withText: !0,
            withKeystroke: !0,
            tooltip: !1,
            role: "menuitem"
        }), this.extendTemplate({attributes: {class: ["ck-menu-bar__menu__item__button"]}})
    }
}

const $c = ["mouseenter", "arrowleft", "arrowright", "change:isOpen"];

class Uk extends T {
    children;
    menus = [];

    constructor(e) {
        super(e);
        const t = e.t, i = this.bindTemplate;
        this.set({
            isOpen: !1,
            isFocusBorderEnabled: !1
        }), this._setupIsOpenUpdater(), this.children = this.createCollection(), this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-menu-bar", i.if("isFocusBorderEnabled", "ck-menu-bar_focus-border-enabled")],
                "aria-label": t("Editor menu bar"),
                role: "menubar"
            },
            children: this.children
        })
    }

    fillFromConfig(e, t, i = []) {
        const n = this.locale, r = Ck({
            normalizedConfig: e,
            locale: n,
            componentFactory: t,
            extraItems: i
        }).items.map(a => this._createMenu({componentFactory: t, menuDefinition: a}));
        this.children.addMany(r)
    }

    render() {
        super.render(), wi.toggleMenusAndFocusItemsOnHover(this), wi.closeMenusWhenTheBarCloses(this), wi.closeMenuWhenAnotherOnTheSameLevelOpens(this), wi.focusCycleMenusOnArrows(this), wi.closeOnClickOutside(this), wi.enableFocusHighlightOnInteraction(this)
    }

    focus() {
        this.children.first && this.children.first.focus()
    }

    close() {
        for (const e of this.children) e.isOpen = !1
    }

    disable() {
        for (const e of this.children) e.isEnabled = !1
    }

    enable() {
        for (const e of this.children) e.isEnabled = !0
    }

    registerMenu(e, t = null) {
        t ? (e.delegate(...$c).to(t), e.parentMenuView = t) : e.delegate(...$c).to(this, i => "menu:" + i), e._attachBehaviors(), this.menus.push(e)
    }

    _createMenu({componentFactory: e, menuDefinition: t, parentMenuView: i}) {
        const n = this.locale, o = new Ne(n);
        return this.registerMenu(o, i), o.buttonView.set({label: t.label}), o.once("change:isOpen", () => {
            const r = new $t(n);
            r.ariaLabel = t.label, o.panelView.children.add(r), r.items.addMany(this._createMenuItems({
                menuDefinition: t,
                parentMenuView: o,
                componentFactory: e
            }))
        }), o
    }

    _createMenuItems({menuDefinition: e, parentMenuView: t, componentFactory: i}) {
        const n = this.locale, o = [];
        for (const r of e.groups) {
            for (const a of r.items) {
                const l = new St(n, t);
                if (tt(a)) l.children.add(this._createMenu({
                    componentFactory: i,
                    menuDefinition: a,
                    parentMenuView: t
                })); else {
                    const c = this._createMenuItemContentFromFactory({
                        componentName: a,
                        componentFactory: i,
                        parentMenuView: t
                    });
                    if (!c) continue;
                    l.children.add(c)
                }
                o.push(l)
            }
            r !== e.groups[e.groups.length - 1] && o.push(new so(n))
        }
        return o
    }

    _createMenuItemContentFromFactory({componentName: e, parentMenuView: t, componentFactory: i}) {
        const n = i.create(e);
        return n instanceof Ne || n instanceof K || n instanceof Yf ? (this._registerMenuTree(n, t), n.on("execute", () => {
            this.close()
        }), n) : (L("menu-bar-component-unsupported", {componentName: e, componentView: n}), null)
    }

    _registerMenuTree(e, t) {
        if (!(e instanceof Ne)) {
            e.delegate("mouseenter").to(t);
            return
        }
        this.registerMenu(e, t);
        const i = e.panelView.children.filter(o => o instanceof $t)[0];
        if (!i) {
            e.delegate("mouseenter").to(t);
            return
        }
        const n = i.items.filter(o => o instanceof Ke);
        for (const o of n) this._registerMenuTree(o.children.get(0), e)
    }

    _setupIsOpenUpdater() {
        let e;
        this.on("menu:change:isOpen", (t, i, n) => {
            clearTimeout(e), n ? this.isOpen = !0 : e = setTimeout(() => {
                this.isOpen = Array.from(this.children).some(o => o.isOpen)
            }, 0)
        })
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const _a = ["left", "right", "center", "justify"];

function Xf(s) {
    return _a.includes(s)
}

function em(s, e) {
    return e.contentLanguageDirection == "rtl" ? s === "right" : s === "left"
}

function tm(s) {
    const e = s.map(i => {
        let n;
        return typeof i == "string" ? n = {name: i} : n = i, n
    }).filter(i => {
        const n = _a.includes(i.name);
        return n || L("alignment-config-name-not-recognized", {option: i}), n
    }), t = e.filter(i => !!i.className).length;
    if (t && t < e.length) throw new p("alignment-config-classnames-are-missing", {configuredOptions: s});
    return e.forEach((i, n, o) => {
        const r = o.slice(n + 1);
        if (r.some(l => l.name == i.name)) throw new p("alignment-config-name-already-defined", {
            option: i,
            configuredOptions: s
        });
        if (i.className && r.some(c => c.className == i.className)) throw new p("alignment-config-classname-already-defined", {
            option: i,
            configuredOptions: s
        })
    }), e
}

const va = "alignment";

class $k extends O {
    refresh() {
        const t = this.editor.locale, i = re(this.editor.model.document.selection.getSelectedBlocks());
        this.isEnabled = !!i && this._canBeAligned(i), this.isEnabled && i.hasAttribute("alignment") ? this.value = i.getAttribute("alignment") : this.value = t.contentLanguageDirection === "rtl" ? "right" : "left"
    }

    execute(e = {}) {
        const t = this.editor, i = t.locale, n = t.model, o = n.document, r = e.value;
        n.change(a => {
            const l = Array.from(o.selection.getSelectedBlocks()).filter(d => this._canBeAligned(d)),
                c = l[0].getAttribute("alignment");
            em(r, i) || c === r || !r ? Wk(l, a) : qk(l, a, r)
        })
    }

    _canBeAligned(e) {
        return this.editor.model.schema.checkAttribute(e, va)
    }
}

function Wk(s, e) {
    for (const t of s) e.removeAttribute(va, t)
}

function qk(s, e, t) {
    for (const i of s) e.setAttribute(va, t, i)
}

class jk extends w {
    static get pluginName() {
        return "AlignmentEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), e.config.define("alignment", {options: _a.map(t => ({name: t}))})
    }

    init() {
        const e = this.editor, t = e.locale, i = e.model.schema,
            o = tm(e.config.get("alignment.options")).filter(c => Xf(c.name) && !em(c.name, t)),
            r = o.some(c => !!c.className);
        i.extend("$block", {allowAttributes: "alignment"}), e.model.schema.setAttributeProperties("alignment", {isFormatting: !0}), r ? e.conversion.attributeToAttribute(Jk(o)) : e.conversion.for("downcast").attributeToAttribute(Gk(o));
        const a = Kk(o);
        for (const c of a) e.conversion.for("upcast").attributeToAttribute(c);
        const l = Zk(o);
        for (const c of l) e.conversion.for("upcast").attributeToAttribute(c);
        e.commands.add("alignment", new $k(e))
    }
}

function Gk(s) {
    const e = {};
    for (const {name: i} of s) e[i] = {key: "style", value: {"text-align": i}};
    return {model: {key: "alignment", values: s.map(i => i.name)}, view: e}
}

function Kk(s) {
    const e = [];
    for (const {name: t} of s) e.push({
        view: {key: "style", value: {"text-align": t}},
        model: {key: "alignment", value: t}
    });
    return e
}

function Zk(s) {
    const e = [];
    for (const {name: t} of s) e.push({view: {key: "align", value: t}, model: {key: "alignment", value: t}});
    return e
}

function Jk(s) {
    const e = {};
    for (const i of s) e[i.name] = {key: "class", value: i.className};
    return {model: {key: "alignment", values: s.map(i => i.name)}, view: e}
}

const an = new Map([["left", uf], ["right", jv], ["center", Wv], ["justify", qv]]);

class Qk extends w {
    get localizedOptionTitles() {
        const e = this.editor.t;
        return {left: e("Align left"), right: e("Align right"), center: e("Align center"), justify: e("Justify")}
    }

    static get pluginName() {
        return "AlignmentUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = tm(e.config.get("alignment.options"));
        t.map(i => i.name).filter(Xf).forEach(i => this._addButton(i)), this._addToolbarDropdown(t), this._addMenuBarMenu(t)
    }

    _addButton(e) {
        this.editor.ui.componentFactory.add(`alignment:${e}`, i => this._createButton(i, e))
    }

    _createButton(e, t, i = {}) {
        const n = this.editor, o = n.commands.get("alignment"), r = new I(e);
        return r.set({
            label: this.localizedOptionTitles[t],
            icon: an.get(t),
            tooltip: !0,
            isToggleable: !0, ...i
        }), r.bind("isEnabled").to(o), r.bind("isOn").to(o, "value", a => a === t), this.listenTo(r, "execute", () => {
            n.execute("alignment", {value: t}), n.editing.view.focus()
        }), r
    }

    _addToolbarDropdown(e) {
        const t = this.editor;
        t.ui.componentFactory.add("alignment", n => {
            const o = Ae(n), r = n.uiLanguageDirection === "rtl" ? "w" : "e", a = n.t;
            qn(o, () => e.map(u => this._createButton(n, u.name, {tooltipPosition: r})), {
                enableActiveItemFocusOnDropdownOpen: !0,
                isVertical: !0,
                ariaLabel: a("Text alignment toolbar")
            }), o.buttonView.set({
                label: a("Text alignment"),
                tooltip: !0
            }), o.extendTemplate({attributes: {class: "ck-alignment-dropdown"}});
            const l = n.contentLanguageDirection === "rtl" ? an.get("right") : an.get("left"),
                c = t.commands.get("alignment");
            return o.buttonView.bind("icon").to(c, "value", u => an.get(u) || l), o.bind("isEnabled").to(c, "isEnabled"), this.listenTo(o, "execute", () => {
                t.editing.view.focus()
            }), o
        })
    }

    _addMenuBarMenu(e) {
        const t = this.editor;
        t.ui.componentFactory.add("menuBar:alignment", i => {
            const n = t.commands.get("alignment"), o = i.t, r = new Ne(i), a = new $t(i);
            r.bind("isEnabled").to(n), a.set({
                ariaLabel: o("Text alignment"),
                role: "menu"
            }), r.buttonView.set({label: o("Text alignment")});
            for (const l of e) {
                const c = new St(i, r), u = new K(i);
                u.delegate("execute").to(r), u.set({
                    label: this.localizedOptionTitles[l.name],
                    icon: an.get(l.name),
                    role: "menuitemcheckbox",
                    isToggleable: !0
                }), u.on("execute", () => {
                    t.execute("alignment", {value: l.name}), t.editing.view.focus()
                }), u.bind("isOn").to(n, "value", d => d === l.name), u.bind("isEnabled").to(n, "isEnabled"), c.children.add(u), a.items.add(c)
            }
            return r.panelView.children.add(a), r
        })
    }
}

class Yk extends w {
    static get requires() {
        return [jk, Qk]
    }

    static get pluginName() {
        return "Alignment"
    }

    static get isOfficialPlugin() {
        return !0
    }
}/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class im {
    model;
    limit;
    _isLocked;
    _size;
    _batch = null;
    _changeCallback;
    _selectionChangeCallback;

    constructor(e, t = 20) {
        this.model = e, this._size = 0, this.limit = t, this._isLocked = !1, this._changeCallback = (i, n) => {
            n.isLocal && n.isUndoable && n !== this._batch && this._reset(!0)
        }, this._selectionChangeCallback = () => {
            this._reset()
        }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback)
    }

    get batch() {
        return this._batch || (this._batch = this.model.createBatch({isTyping: !0})), this._batch
    }

    get size() {
        return this._size
    }

    input(e) {
        this._size += e, this._size >= this.limit && this._reset(!0)
    }

    get isLocked() {
        return this._isLocked
    }

    lock() {
        this._isLocked = !0
    }

    unlock() {
        this._isLocked = !1
    }

    destroy() {
        this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback)
    }

    _reset(e = !1) {
        (!this.isLocked || e) && (this._batch = null, this._size = 0)
    }
}

class Xk extends O {
    _buffer;

    constructor(e, t) {
        super(e), this._buffer = new im(e.model, t), this._isEnabledBasedOnSelection = !1
    }

    get buffer() {
        return this._buffer
    }

    destroy() {
        super.destroy(), this._buffer.destroy()
    }

    execute(e = {}) {
        const t = this.editor.model, i = t.document, n = e.text || "", o = n.length;
        let r = i.selection;
        if (e.selection ? r = e.selection : e.range && (r = t.createSelection(e.range)), !t.canEditAt(r)) return;
        const a = e.resultRange;
        t.enqueueChange(this._buffer.batch, l => {
            this._buffer.lock();
            const c = Array.from(i.selection.getAttributes());
            t.deleteContent(r), n && t.insertContent(l.createText(n, c), r), a ? l.setSelection(a) : r.is("documentSelection") || l.setSelection(r), this._buffer.unlock(), this._buffer.input(o)
        })
    }
}

const nm = ["insertText", "insertReplacementText"], eC = [...nm, "insertCompositionText"];

class tC extends gt {
    focusObserver;

    constructor(e) {
        super(e), this.focusObserver = e.getObserver(Ls);
        const t = x.isAndroid ? eC : nm, i = e.document;
        i.on("beforeinput", (n, o) => {
            if (!this.isEnabled) return;
            const {data: r, targetRanges: a, inputType: l, domEvent: c, isComposing: u} = o;
            if (!t.includes(l)) return;
            this.focusObserver.flush();
            const d = new xt(i, "insertText");
            i.fire(d, new ei(e, c, {
                text: r,
                selection: e.createSelection(a),
                isComposing: u
            })), d.stop.called && n.stop()
        }), x.isAndroid || i.on("compositionend", (n, {data: o, domEvent: r}) => {
            this.isEnabled && o && i.fire("insertText", new ei(e, r, {text: o, isComposing: !0}))
        }, {priority: "low"})
    }

    observe() {
    }

    stopObserving() {
    }
}

class sm extends w {
    _typingQueue;

    static get pluginName() {
        return "Input"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.model, i = e.editing.view, n = e.editing.mapper, o = t.document.selection;
        this._typingQueue = new iC(e), i.addObserver(tC);
        const r = new Xk(e, e.config.get("typing.undoStep") || 20);
        e.commands.add("insertText", r), e.commands.add("input", r), this.listenTo(i.document, "beforeinput", () => {
            this._typingQueue.flush("next beforeinput")
        }, {priority: "high"}), this.listenTo(i.document, "insertText", (a, l) => {
            const {text: c, selection: u} = l;
            if (i.document.selection.isFake && u && i.document.selection.isSimilar(u) && l.preventDefault(), u && Array.from(u.getRanges()).some(m => !m.isCollapsed) && l.preventDefault(), !r.isEnabled) {
                l.preventDefault();
                return
            }
            let d;
            u ? d = Array.from(u.getRanges()).map(m => n.toModelRange(m)).map(m => da(m, t.schema) || m) : d = Array.from(o.getRanges());
            let h = c;
            if (x.isAndroid) {
                const m = Array.from(d[0].getItems()).reduce((g, _) => g + (_.is("$textProxy") ? _.data : ""), "");
                if (m && (m.length <= h.length ? h.startsWith(m) && (h = h.substring(m.length), d[0].start = d[0].start.getShiftedBy(m.length)) : m.startsWith(h) && (d[0].start = d[0].start.getShiftedBy(h.length), h = "")), h.length == 0 && d[0].isCollapsed) return
            }
            const f = {text: h, selection: t.createSelection(d)};
            this._typingQueue.push(f, !!l.isComposing), l.domEvent.defaultPrevented && this._typingQueue.flush("beforeinput default prevented")
        }), x.isAndroid ? this.listenTo(i.document, "keydown", (a, l) => {
            o.isCollapsed || l.keyCode != 229 || !i.document.isComposing || Wc(t, r)
        }) : this.listenTo(i.document, "compositionstart", () => {
            o.isCollapsed || Wc(t, r)
        }, {priority: "high"}), this.listenTo(i.document, "mutations", (a, {mutations: l}) => {
            if (this._typingQueue.hasAffectedElements()) for (const {node: c} of l) {
                const u = sC(c, n), d = n.toModelElement(u);
                if (this._typingQueue.isElementAffected(d)) {
                    this._typingQueue.flush("mutations");
                    return
                }
            }
        }), this.listenTo(i.document, "compositionend", () => {
            this._typingQueue.flush("before composition end")
        }, {priority: "high"}), this.listenTo(i.document, "compositionend", () => {
            this._typingQueue.flush("after composition end");
            const a = [];
            if (this._typingQueue.hasAffectedElements()) for (const l of this._typingQueue.flushAffectedElements()) {
                const c = n.toViewElement(l);
                c && a.push({type: "children", node: c})
            }
            (a.length || !x.isAndroid) && i.document.fire("mutations", {mutations: a})
        }, {priority: "lowest"})
    }

    destroy() {
        super.destroy(), this._typingQueue.destroy()
    }
}

class iC {
    editor;
    flushDebounced = it(() => this.flush("timeout"), 50);
    _queue = [];
    _isComposing = !1;
    _affectedElements = new Set;

    constructor(e) {
        this.editor = e
    }

    destroy() {
        for (this.flushDebounced.cancel(), this._affectedElements.clear(); this._queue.length;) this.shift()
    }

    get length() {
        return this._queue.length
    }

    push(e, t) {
        const i = {text: e.text};
        if (e.selection) {
            i.selectionRanges = [];
            for (const n of e.selection.getRanges()) i.selectionRanges.push(Ce.fromRange(n)), this._affectedElements.add(n.start.parent)
        }
        this._queue.push(i), this._isComposing ||= t, this.flushDebounced()
    }

    shift() {
        const e = this._queue.shift(), t = {text: e.text};
        if (e.selectionRanges) {
            const i = e.selectionRanges.map(n => nC(n)).filter(n => !!n);
            i.length && (t.selection = this.editor.model.createSelection(i))
        }
        return t
    }

    flush(e) {
        const t = this.editor, i = t.model, n = t.editing.view;
        if (this.flushDebounced.cancel(), !this._queue.length) return;
        const r = t.commands.get("insertText").buffer;
        i.enqueueChange(r.batch, () => {
            for (r.lock(); this._queue.length;) {
                const a = this.shift();
                t.execute("insertText", a)
            }
            r.unlock(), this._isComposing || this._affectedElements.clear(), this._isComposing = !1
        }), n.scrollToTheSelection()
    }

    isElementAffected(e) {
        return this._affectedElements.has(e)
    }

    hasAffectedElements() {
        return this._affectedElements.size > 0
    }

    flushAffectedElements() {
        const e = Array.from(this._affectedElements);
        return this._affectedElements.clear(), e
    }
}

function Wc(s, e) {
    if (!e.isEnabled) return;
    const t = e.buffer;
    t.lock(), s.enqueueChange(t.batch, () => {
        s.deleteContent(s.document.selection)
    }), t.unlock()
}

function nC(s) {
    const e = s.toRange();
    return s.detach(), e.root.rootName == "$graveyard" ? null : e
}

function sC(s, e) {
    let t = s.is("$text") ? s.parent : s;
    for (; !e.toModelElement(t);) t = t.parent;
    return t
}

class qc extends O {
    direction;
    _buffer;

    constructor(e, t) {
        super(e), this.direction = t, this._buffer = new im(e.model, e.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = !1
    }

    get buffer() {
        return this._buffer
    }

    execute(e = {}) {
        const t = this.editor.model, i = t.document;
        t.enqueueChange(this._buffer.batch, n => {
            this._buffer.lock();
            const o = n.createSelection(e.selection || i.selection);
            if (!t.canEditAt(o)) return;
            const r = e.sequence || 1, a = o.isCollapsed;
            if (o.isCollapsed && t.modifySelection(o, {
                direction: this.direction,
                unit: e.unit,
                treatEmojiAsSingleUnit: !0
            }), this._shouldEntireContentBeReplacedWithParagraph(r)) {
                this._replaceEntireContentWithParagraph(n);
                return
            }
            if (this._shouldReplaceFirstBlockWithParagraph(o, r)) {
                this.editor.execute("paragraph", {selection: o});
                return
            }
            if (o.isCollapsed) return;
            let l = 0;
            o.getFirstRange().getMinimalFlatRanges().forEach(c => {
                l += lr(c.getWalker({singleCharacters: !0, ignoreElementEnd: !0, shallow: !0}))
            }), t.deleteContent(o, {
                doNotResetEntireContent: a,
                direction: this.direction
            }), this._buffer.input(l), n.setSelection(o), this._buffer.unlock()
        })
    }

    _shouldEntireContentBeReplacedWithParagraph(e) {
        if (e > 1) return !1;
        const t = this.editor.model, n = t.document.selection, o = t.schema.getLimitElement(n);
        if (!(n.isCollapsed && n.containsEntireContent(o)) || !t.schema.checkChild(o, "paragraph")) return !1;
        const a = o.getChild(0);
        return !(a && a.is("element", "paragraph"))
    }

    _replaceEntireContentWithParagraph(e) {
        const t = this.editor.model, n = t.document.selection, o = t.schema.getLimitElement(n),
            r = e.createElement("paragraph");
        e.remove(e.createRangeIn(o)), e.insert(r, o), e.setSelection(r, 0)
    }

    _shouldReplaceFirstBlockWithParagraph(e, t) {
        const i = this.editor.model;
        if (t > 1 || this.direction != "backward" || !e.isCollapsed) return !1;
        const n = e.getFirstPosition(), o = i.schema.getLimitElement(n), r = o.getChild(0);
        return !(n.parent != r || !e.containsEntireContent(r) || !i.schema.checkChild(o, "paragraph") || r.name == "paragraph")
    }
}

const oC = "character", jc = "word", rC = "codePoint", Bt = "selection", Ii = "backward", gn = "forward", om = {
    deleteContent: {unit: Bt, direction: Ii},
    deleteContentBackward: {unit: rC, direction: Ii},
    deleteWordBackward: {unit: jc, direction: Ii},
    deleteHardLineBackward: {unit: Bt, direction: Ii},
    deleteSoftLineBackward: {unit: Bt, direction: Ii},
    deleteContentForward: {unit: oC, direction: gn},
    deleteWordForward: {unit: jc, direction: gn},
    deleteHardLineForward: {unit: Bt, direction: gn},
    deleteSoftLineForward: {unit: Bt, direction: gn}
};

class aC extends gt {
    constructor(e) {
        super(e);
        const t = e.document;
        let i = 0;
        t.on("keydown", () => {
            i++
        }), t.on("keyup", () => {
            i = 0
        }), t.on("beforeinput", (n, o) => {
            if (!this.isEnabled) return;
            const {targetRanges: r, domEvent: a, inputType: l} = o, c = om[l];
            if (!c) return;
            const u = {direction: c.direction, unit: c.unit, sequence: i};
            u.unit == Bt && (u.selectionToRemove = e.createSelection(r[0])), l === "deleteContentBackward" && (x.isAndroid && (u.sequence = 1), cC(r) && (u.unit = Bt, u.selectionToRemove = e.createSelection(r)));
            const d = new ri(t, "delete", r[0]);
            t.fire(d, new ei(e, a, u)), d.stop.called && n.stop()
        }), x.isBlink && lC(this)
    }

    observe() {
    }

    stopObserving() {
    }
}

function lC(s) {
    const e = s.view, t = e.document;
    let i = null, n = !1;
    t.on("keydown", (a, {keyCode: l}) => {
        i = l, n = !1
    }), t.on("keyup", (a, {keyCode: l, domEvent: c}) => {
        const u = t.selection, d = s.isEnabled && l == i && o(l) && !u.isCollapsed && !n;
        if (i = null, d) {
            const h = u.getFirstRange(), f = new ri(t, "delete", h),
                m = {unit: Bt, direction: r(l), selectionToRemove: u};
            t.fire(f, new ei(e, c, m))
        }
    }), t.on("beforeinput", (a, {inputType: l}) => {
        const c = om[l];
        o(i) && c && c.direction == r(i) && (n = !0)
    }, {priority: "high"}), t.on("beforeinput", (a, {inputType: l, data: c}) => {
        i == M.delete && l == "insertText" && c == "" && a.stop()
    }, {priority: "high"});

    function o(a) {
        return a == M.backspace || a == M.delete
    }

    function r(a) {
        return a == M.backspace ? Ii : gn
    }
}

function cC(s) {
    if (s.length != 1 || s[0].isCollapsed) return !1;
    const e = s[0].getWalker({direction: "backward", singleCharacters: !0, ignoreElementEnd: !0});
    let t = 0;
    for (const {nextPosition: i, item: n} of e) {
        if (i.parent.is("$text")) {
            const o = i.parent.data, r = i.offset;
            if (ta(o, r) || ia(o, r) || ph(o, r)) continue;
            t++
        } else (n.is("containerElement") || n.is("emptyElement")) && t++;
        if (t > 1) return !0
    }
    return !1
}

class mt extends w {
    _undoOnBackspace;

    static get pluginName() {
        return "Delete"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.editing.view, i = t.document, n = e.model.document;
        t.addObserver(aC), this._undoOnBackspace = !1;
        const o = new qc(e, "forward");
        e.commands.add("deleteForward", o), e.commands.add("forwardDelete", o), e.commands.add("delete", new qc(e, "backward")), this.listenTo(i, "delete", (r, a) => {
            i.isComposing || a.preventDefault();
            const {direction: l, sequence: c, selectionToRemove: u, unit: d} = a,
                h = l === "forward" ? "deleteForward" : "delete", f = {sequence: c};
            if (d == "selection") {
                const m = Array.from(u.getRanges()).map(g => e.editing.mapper.toModelRange(g)).map(g => da(g, e.model.schema) || g);
                f.selection = e.model.createSelection(m)
            } else f.unit = d;
            e.execute(h, f), t.scrollToTheSelection()
        }, {priority: "low"}), this.listenTo(i, "keydown", (r, a) => {
            if (i.isComposing || a.keyCode != M.backspace || !n.selection.isCollapsed) return;
            const l = e.model.schema.getLimitElement(n.selection), c = e.model.createPositionAt(l, 0);
            if (c.isTouching(n.selection.getFirstPosition())) {
                a.preventDefault();
                const u = e.model.schema.getNearestSelectionRange(c, "forward");
                if (!u) return;
                const d = t.createSelection(e.editing.mapper.toViewRange(u)), h = d.getFirstRange(),
                    f = new ri(document, "delete", h),
                    m = {unit: "selection", direction: "backward", selectionToRemove: d};
                i.fire(f, new ei(t, a.domEvent, m))
            }
        }), this.editor.plugins.has("UndoEditing") && (this.listenTo(i, "delete", (r, a) => {
            this._undoOnBackspace && a.direction == "backward" && a.sequence == 1 && a.unit == "codePoint" && (this._undoOnBackspace = !1, e.execute("undo"), a.preventDefault(), r.stop())
        }, {context: "$capture"}), this.listenTo(n, "change", () => {
            this._undoOnBackspace = !1
        }))
    }

    requestUndoOnBackspace() {
        this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = !0)
    }
}

class uC extends w {
    static get requires() {
        return [sm, mt]
    }

    static get pluginName() {
        return "Typing"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function rm(s, e) {
    let t = s.start;
    return {
        text: Array.from(s.getWalker({ignoreElementEnd: !1})).reduce((n, {item: o}) => o.is("$text") || o.is("$textProxy") ? n + o.data : (t = e.createPositionAfter(o), ""), ""),
        range: e.createRange(t, s.end)
    }
}

class ya extends H() {
    model;
    testCallback;
    _hasMatch;

    constructor(e, t) {
        super(), this.model = e, this.testCallback = t, this._hasMatch = !1, this.set("isEnabled", !0), this.on("change:isEnabled", () => {
            this.isEnabled ? this._startListening() : (this.stopListening(e.document.selection), this.stopListening(e.document))
        }), this._startListening()
    }

    get hasMatch() {
        return this._hasMatch
    }

    _startListening() {
        const t = this.model.document;
        this.listenTo(t.selection, "change:range", (i, {directChange: n}) => {
            if (n) {
                if (!t.selection.isCollapsed) {
                    this.hasMatch && (this.fire("unmatched"), this._hasMatch = !1);
                    return
                }
                this._evaluateTextBeforeSelection("selection")
            }
        }), this.listenTo(t, "change:data", (i, n) => {
            n.isUndo || !n.isLocal || this._evaluateTextBeforeSelection("data", {batch: n})
        })
    }

    _evaluateTextBeforeSelection(e, t = {}) {
        const i = this.model, o = i.document.selection,
            r = i.createRange(i.createPositionAt(o.focus.parent, 0), o.focus), {text: a, range: l} = rm(r, i),
            c = this.testCallback(a);
        if (!c && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!c, c) {
            const u = Object.assign(t, {text: a, range: l});
            typeof c == "object" && Object.assign(u, c), this.fire(`matched:${e}`, u)
        }
    }
}

class Gc extends w {
    attributes;
    _overrideUid;
    _isNextGravityRestorationSkipped = !1;

    static get pluginName() {
        return "TwoStepCaretMovement"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), this.attributes = new Set, this._overrideUid = null
    }

    init() {
        const e = this.editor, t = e.model, i = e.editing.view, n = e.locale, o = t.document.selection;
        this.listenTo(i.document, "arrowKey", (r, a) => {
            if (!o.isCollapsed || a.shiftKey || a.altKey || a.ctrlKey) return;
            const l = a.keyCode == M.arrowright, c = a.keyCode == M.arrowleft;
            if (!l && !c) return;
            const u = n.contentLanguageDirection;
            let d = !1;
            u === "ltr" && l || u === "rtl" && c ? d = this._handleForwardMovement(a) : d = this._handleBackwardMovement(a), d === !0 && r.stop()
        }, {context: "$text", priority: "highest"}), this.listenTo(o, "change:range", (r, a) => {
            if (this._isNextGravityRestorationSkipped) {
                this._isNextGravityRestorationSkipped = !1;
                return
            }
            this._isGravityOverridden && (!a.directChange && qe(o.getFirstPosition(), this.attributes) || this._restoreGravity())
        }), this._enableClickingAfterNode(), this._enableInsertContentSelectionAttributesFixer(), this._handleDeleteContentAfterNode()
    }

    registerAttribute(e) {
        this.attributes.add(e)
    }

    _handleForwardMovement(e) {
        const t = this.attributes, i = this.editor.model, n = i.document.selection, o = n.getFirstPosition();
        return this._isGravityOverridden || o.isAtStart && bt(n, t) ? !1 : qe(o, t) ? (e && cn(e), bt(n, t) && qe(o, t, !0) ? ln(i, t) : this._overrideGravity(), !0) : !1
    }

    _handleBackwardMovement(e) {
        const t = this.attributes, i = this.editor.model, n = i.document.selection, o = n.getFirstPosition();
        return this._isGravityOverridden ? (e && cn(e), this._restoreGravity(), qe(o, t, !0) ? ln(i, t) : rs(i, t, o), !0) : o.isAtStart ? bt(n, t) ? (e && cn(e), rs(i, t, o), !0) : !1 : !bt(n, t) && qe(o, t, !0) ? (e && cn(e), rs(i, t, o), !0) : Kc(o, t) ? o.isAtEnd && !bt(n, t) && qe(o, t) ? (e && cn(e), rs(i, t, o), !0) : (this._isNextGravityRestorationSkipped = !0, this._overrideGravity(), !1) : !1
    }

    _enableClickingAfterNode() {
        const e = this.editor, t = e.model, i = t.document.selection, n = e.editing.view.document;
        e.editing.view.addObserver(to), e.editing.view.addObserver(J0);
        let o = !1, r = !1;
        this.listenTo(n, "touchstart", () => {
            r = !1, o = !0
        }), this.listenTo(n, "mousedown", () => {
            r = !0
        }), this.listenTo(n, "selectionChange", () => {
            const a = this.attributes;
            if (!r && !o || (r = !1, o = !1, !i.isCollapsed) || !bt(i, a)) return;
            const l = i.getFirstPosition();
            qe(l, a) && (l.isAtStart || qe(l, a, !0) ? ln(t, a) : this._isGravityOverridden || this._overrideGravity())
        })
    }

    _enableInsertContentSelectionAttributesFixer() {
        const t = this.editor.model, i = t.document.selection, n = this.attributes;
        this.listenTo(t, "insertContent", () => {
            const o = i.getFirstPosition();
            bt(i, n) && qe(o, n) && ln(t, n)
        }, {priority: "low"})
    }

    _handleDeleteContentAfterNode() {
        const e = this.editor, t = e.model, i = t.document.selection, n = e.editing.view;
        let o = !1, r = !1;
        this.listenTo(n.document, "delete", (a, l) => {
            o = l.direction === "backward"
        }, {priority: "high"}), this.listenTo(t, "deleteContent", () => {
            if (!o) return;
            const a = i.getFirstPosition();
            r = bt(i, this.attributes) && !Kc(a, this.attributes)
        }, {priority: "high"}), this.listenTo(t, "deleteContent", () => {
            o && (o = !1, !r && e.model.enqueueChange(() => {
                const a = i.getFirstPosition();
                bt(i, this.attributes) && qe(a, this.attributes) && (a.isAtStart || qe(a, this.attributes, !0) ? ln(t, this.attributes) : this._isGravityOverridden || this._overrideGravity())
            }))
        }, {priority: "low"})
    }

    get _isGravityOverridden() {
        return !!this._overrideUid
    }

    _overrideGravity() {
        this._overrideUid = this.editor.model.change(e => e.overrideSelectionGravity())
    }

    _restoreGravity() {
        this.editor.model.change(e => {
            e.restoreSelectionGravity(this._overrideUid), this._overrideUid = null
        })
    }
}

function bt(s, e) {
    for (const t of e) if (s.hasAttribute(t)) return !0;
    return !1
}

function rs(s, e, t) {
    const i = t.nodeBefore;
    s.change(n => {
        if (i) {
            const o = [], r = s.schema.isObject(i) && s.schema.isInline(i);
            for (const [a, l] of i.getAttributes()) s.schema.checkAttribute("$text", a) && (!r || s.schema.getAttributeProperties(a).copyFromObject !== !1) && o.push([a, l]);
            n.setSelectionAttribute(o)
        } else n.removeSelectionAttribute(e)
    })
}

function ln(s, e) {
    s.change(t => {
        t.removeSelectionAttribute(e)
    })
}

function cn(s) {
    s.preventDefault()
}

function Kc(s, e) {
    const t = s.getShiftedBy(-1);
    return qe(t, e)
}

function qe(s, e, t = !1) {
    const {nodeBefore: i, nodeAfter: n} = s;
    for (const o of e) {
        const r = i ? i.getAttribute(o) : void 0, a = n ? n.getAttribute(o) : void 0;
        if (!(t && (r === void 0 || a === void 0)) && a !== r) return !0
    }
    return !1
}

const Zc = {
    copyright: {from: "(c)", to: "©"},
    registeredTrademark: {from: "(r)", to: "®"},
    trademark: {from: "(tm)", to: "™"},
    oneHalf: {from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null]},
    oneThird: {from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null]},
    twoThirds: {from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null]},
    oneForth: {from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null]},
    threeQuarters: {from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null]},
    lessThanOrEqual: {from: "<=", to: "≤"},
    greaterThanOrEqual: {from: ">=", to: "≥"},
    notEqual: {from: "!=", to: "≠"},
    arrowLeft: {from: "<-", to: "←"},
    arrowRight: {from: "->", to: "→"},
    horizontalEllipsis: {from: "...", to: "…"},
    enDash: {from: /(^| )(--)( )$/, to: [null, "–", null]},
    emDash: {from: /(^| )(---)( )$/, to: [null, "—", null]},
    quotesPrimary: {from: _i('"'), to: [null, "“", null, "”"]},
    quotesSecondary: {from: _i("'"), to: [null, "‘", null, "’"]},
    quotesPrimaryEnGb: {from: _i("'"), to: [null, "‘", null, "’"]},
    quotesSecondaryEnGb: {from: _i('"'), to: [null, "“", null, "”"]},
    quotesPrimaryPl: {from: _i('"'), to: [null, "„", null, "”"]},
    quotesSecondaryPl: {from: _i("'"), to: [null, "‚", null, "’"]}
}, Jc = {
    symbols: ["copyright", "registeredTrademark", "trademark"],
    mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"],
    typography: ["horizontalEllipsis", "enDash", "emDash"],
    quotes: ["quotesPrimary", "quotesSecondary"]
}, dC = ["symbols", "mathematical", "typography", "quotes"];

class hC extends w {
    static get requires() {
        return ["Delete", "Input"]
    }

    static get pluginName() {
        return "TextTransformation"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), e.config.define("typing", {transformations: {include: dC}})
    }

    init() {
        const t = this.editor.model.document.selection;
        t.on("change:range", () => {
            this.isEnabled = !t.anchor.parent.is("element", "codeBlock")
        }), this._enableTransformationWatchers()
    }

    _enableTransformationWatchers() {
        const e = this.editor, t = e.model, i = e.plugins.get("Delete"), n = pC(e.config.get("typing.transformations")),
            o = a => {
                for (const l of n) if (l.from.test(a)) return {normalizedTransformation: l}
            }, r = new ya(e.model, o);
        r.on("matched:data", (a, l) => {
            if (!l.batch.isTyping) return;
            const {from: c, to: u} = l.normalizedTransformation, d = c.exec(l.text), h = u(d.slice(1)), f = l.range;
            let m = d.index;
            t.enqueueChange(g => {
                for (let _ = 1; _ < d.length; _++) {
                    const v = d[_], E = h[_ - 1];
                    if (E == null) {
                        m += v.length;
                        continue
                    }
                    const V = f.start.getShiftedBy(m), N = t.createRange(V, V.getShiftedBy(v.length)), Z = gC(V);
                    t.insertContent(g.createText(E, Z), N), m += E.length
                }
                t.enqueueChange(() => {
                    i.requestUndoOnBackspace()
                })
            })
        }), r.bind("isEnabled").to(this)
    }
}

function fC(s) {
    return typeof s == "string" ? new RegExp(`(${$d(s)})$`) : s
}

function mC(s) {
    return typeof s == "string" ? () => [s] : s instanceof Array ? () => s : s
}

function gC(s) {
    return (s.textNode ? s.textNode : s.nodeAfter).getAttributes()
}

function _i(s) {
    return new RegExp(`(^|\\s)(${s})([^${s}]*)(${s})$`)
}

function pC(s) {
    const e = s.extra || [], t = s.remove || [], i = o => !t.includes(o), n = s.include.concat(e).filter(i);
    return wC(n).filter(i).map(o => typeof o == "string" && Zc[o] ? Zc[o] : o).filter(o => typeof o == "object").map(o => ({
        from: fC(o.from),
        to: mC(o.to)
    }))
}

function wC(s) {
    const e = new Set;
    for (const t of s) if (typeof t == "string" && Jc[t]) for (const i of Jc[t]) e.add(i); else e.add(t);
    return Array.from(e)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function ro(s, e, t, i) {
    return i.createRange(Qc(s, e, t, !0, i), Qc(s, e, t, !1, i))
}

function Qc(s, e, t, i, n) {
    let o = s.textNode || (i ? s.nodeBefore : s.nodeAfter), r = null;
    for (; o && o.getAttribute(e) == t;) r = o, o = i ? o.previousSibling : o.nextSibling;
    return r ? n.createPositionAt(r, i ? "before" : "after") : s
}

function bC(s, e, t, i) {
    const n = s.editing.view, o = new Set;
    n.document.registerPostFixer(r => {
        const a = s.model.document.selection;
        let l = !1;
        if (a.hasAttribute(e)) {
            const c = ro(a.getFirstPosition(), e, a.getAttribute(e), s.model), u = s.editing.mapper.toViewRange(c);
            for (const d of u.getItems()) d.is("element", t) && !d.hasClass(i) && (r.addClass(i, d), o.add(d), l = !0)
        }
        return l
    }), s.conversion.for("editingDowncast").add(r => {
        r.on("insert", a, {priority: "highest"}), r.on("remove", a, {priority: "highest"}), r.on("attribute", a, {priority: "highest"}), r.on("selection", a, {priority: "highest"});

        function a() {
            n.change(l => {
                for (const c of o.values()) l.removeClass(i, c), o.delete(c)
            })
        }
    })
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Vt(s, e, t, i) {
    let n, o = null;
    typeof i == "function" ? n = i : (o = s.commands.get(i), n = () => {
        s.execute(i)
    }), s.model.document.on("change:data", (r, a) => {
        if (o && !o.isEnabled || !e.isEnabled) return;
        const l = re(s.model.document.selection.getRanges());
        if (!l.isCollapsed || a.isUndo || !a.isLocal) return;
        const c = Array.from(s.model.document.differ.getChanges()), u = c[0];
        if (c.length != 1 || u.type !== "insert" || u.name != "$text" || u.length != 1) return;
        const d = u.position.parent;
        if (d.is("element", "codeBlock") || d.is("element", "listItem") && typeof i != "function" && !["numberedList", "bulletedList", "todoList"].includes(i) || o && o.value === !0) return;
        const h = d.getChild(0), f = s.model.createRangeOn(h);
        if (!f.containsRange(l) && !l.end.isEqual(f.end)) return;
        const m = t.exec(h.data.substr(0, l.end.offset));
        m && s.model.enqueueChange(g => {
            const _ = g.createPositionAt(d, 0), v = g.createPositionAt(d, m[0].length), E = new Ce(_, v);
            if (n({match: m}) !== !1) {
                g.remove(E);
                const N = s.model.document.selection.getFirstRange(), Z = g.createRangeIn(d);
                d.isEmpty && !Z.isEqual(N) && !Z.containsRange(N, !0) && g.remove(d)
            }
            E.detach(), s.model.enqueueChange(() => {
                s.plugins.get("Delete").requestUndoOnBackspace()
            })
        })
    })
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function vi(s, e, t, i) {
    let n, o;
    t instanceof RegExp ? n = t : o = t, o = o || (r => {
        let a;
        const l = [], c = [];
        for (; (a = n.exec(r)) !== null && !(a && a.length < 4);) {
            let {index: u, "1": d, "2": h, "3": f} = a;
            const m = d + h + f;
            u += a[0].length - m.length;
            const g = [u, u + d.length], _ = [u + d.length + h.length, u + d.length + h.length + f.length];
            l.push(g), l.push(_), c.push([u + d.length, u + d.length + h.length])
        }
        return {remove: l, format: c}
    }), s.model.document.on("change:data", (r, a) => {
        if (a.isUndo || !a.isLocal || !e.isEnabled) return;
        const l = s.model, c = l.document.selection;
        if (!c.isCollapsed) return;
        const u = Array.from(l.document.differ.getChanges()), d = u[0];
        if (u.length != 1 || d.type !== "insert" || d.name != "$text" || d.length != 1) return;
        const h = c.focus, f = h.parent, {text: m, range: g} = _C(l.createRange(l.createPositionAt(f, 0), h), l),
            _ = o(m), v = Yc(g.start, _.format, l), E = Yc(g.start, _.remove, l);
        v.length && E.length && l.enqueueChange(V => {
            if (i(V, v) !== !1) {
                for (const Z of E.reverse()) V.remove(Z);
                l.enqueueChange(() => {
                    s.plugins.get("Delete").requestUndoOnBackspace()
                })
            }
        })
    })
}

function Yc(s, e, t) {
    return e.filter(i => i[0] !== void 0 && i[1] !== void 0).map(i => t.createRange(s.getShiftedBy(i[0]), s.getShiftedBy(i[1])))
}

function _C(s, e) {
    let t = s.start;
    return {
        text: Array.from(s.getItems()).reduce((n, o) => !(o.is("$text") || o.is("$textProxy")) || o.getAttribute("code") ? (t = e.createPositionAfter(o), "") : n + o.data, ""),
        range: e.createRange(t, s.end)
    }
}

class vC extends w {
    static get requires() {
        return [mt]
    }

    static get pluginName() {
        return "Autoformat"
    }

    static get isOfficialPlugin() {
        return !0
    }

    afterInit() {
        const e = this.editor, t = this.editor.t;
        this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats(), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: t("Revert autoformatting action"),
                keystroke: "Backspace"
            }]
        })
    }

    _addListAutoformats() {
        const e = this.editor.commands;
        e.get("bulletedList") && Vt(this.editor, this, /^[*-]\s$/, "bulletedList"), e.get("numberedList") && Vt(this.editor, this, /^1[.|)]\s$/, "numberedList"), e.get("todoList") && Vt(this.editor, this, /^\[\s?\]\s$/, "todoList"), e.get("checkTodoList") && Vt(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
            this.editor.execute("todoList"), this.editor.execute("checkTodoList")
        })
    }

    _addBasicStylesAutoformats() {
        const e = this.editor.commands;
        if (e.get("bold")) {
            const t = as(this.editor, "bold");
            vi(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t), vi(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t)
        }
        if (e.get("italic")) {
            const t = as(this.editor, "italic");
            vi(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t), vi(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t)
        }
        if (e.get("code")) {
            const t = as(this.editor, "code");
            vi(this.editor, this, /(`)([^`]+)(`)$/g, t)
        }
        if (e.get("strikethrough")) {
            const t = as(this.editor, "strikethrough");
            vi(this.editor, this, /(~~)([^~]+)(~~)$/g, t)
        }
    }

    _addHeadingAutoformats() {
        const e = this.editor.commands.get("heading");
        e && e.modelElements.filter(t => t.match(/^heading[1-6]$/)).forEach(t => {
            const i = t[7], n = new RegExp(`^(#{${i}})\\s$`);
            Vt(this.editor, this, n, () => {
                if (!e.isEnabled || e.value === t) return !1;
                this.editor.execute("heading", {value: t})
            })
        })
    }

    _addBlockQuoteAutoformats() {
        this.editor.commands.get("blockQuote") && Vt(this.editor, this, /^>\s$/, "blockQuote")
    }

    _addCodeBlockAutoformats() {
        const e = this.editor, t = e.model.document.selection;
        e.commands.get("codeBlock") && Vt(e, this, /^```$/, () => {
            if (t.getFirstPosition().parent.is("element", "listItem")) return !1;
            this.editor.execute("codeBlock", {usePreviousLanguageChoice: !0})
        })
    }

    _addHorizontalLineAutoformats() {
        this.editor.commands.get("horizontalLine") && Vt(this.editor, this, /^---$/, "horizontalLine")
    }
}

function as(s, e) {
    return (t, i) => {
        if (!s.commands.get(e).isEnabled) return !1;
        const o = s.model.schema.getValidRanges(i, e);
        for (const r of o) t.setAttribute(e, !0, r);
        t.removeSelectionAttribute(e)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class yC extends w {
    adapter;
    _debouncedSave;
    _lastDocumentVersion;
    _savePromise;
    _domEmitter;
    _config;
    _pendingActions;
    _makeImmediateSave;
    _action = null;

    static get pluginName() {
        return "Autosave"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Hi]
    }

    constructor(e) {
        super(e);
        const t = e.config.get("autosave") || {}, i = t.waitingTime || 1e3;
        this.set("state", "synchronized"), this._debouncedSave = it(this._save.bind(this), i), this._lastDocumentVersion = e.model.document.version, this._savePromise = null, this._domEmitter = new (xe()), this._config = t, this._pendingActions = e.plugins.get(Hi), this._makeImmediateSave = !1
    }

    init() {
        const e = this.editor, t = e.model.document;
        this.listenTo(e, "ready", () => {
            this.listenTo(t, "change:data", (i, n) => {
                this._saveCallbacks.length && n.isLocal && (this.state === "synchronized" && (this.state = "waiting", this._setPendingAction()), this.state === "waiting" && this._debouncedSave())
            })
        }), this.listenTo(e, "destroy", () => this._flush(), {priority: "highest"});/* istanbul ignore next -- @preserve */
        this._domEmitter.listenTo(window, "beforeunload", (i, n) => {
            this._pendingActions.hasAny && (n.returnValue = this._pendingActions.first.message)
        })
    }

    destroy() {
        this._domEmitter.stopListening(), super.destroy()
    }

    save() {
        return this._debouncedSave.cancel(), this._save()
    }

    _flush() {
        this._debouncedSave.flush()
    }

    _save() {
        return this._savePromise ? (this._makeImmediateSave = this.editor.model.document.version > this._lastDocumentVersion, this._savePromise) : (this._setPendingAction(), this.state = "saving", this._lastDocumentVersion = this.editor.model.document.version, this._savePromise = Promise.resolve().then(() => Promise.all(this._saveCallbacks.map(e => e(this.editor)))).finally(() => {
            this._savePromise = null
        }).then(() => {
            if (this._makeImmediateSave) return this._makeImmediateSave = !1, this._save();
            this.editor.model.document.version > this._lastDocumentVersion ? (this.state = "waiting", this._debouncedSave()) : (this.state = "synchronized", this._pendingActions.remove(this._action), this._action = null)
        }).catch(e => {
            throw this.state = "error", this.state = "saving", this._debouncedSave(), e
        }), this._savePromise)
    }

    _setPendingAction() {
        const e = this.editor.t;
        this._action || (this._action = this._pendingActions.add(e("Saving changes")))
    }

    get _saveCallbacks() {
        const e = [];
        return this.adapter && this.adapter.save && e.push(this.adapter.save), this._config.save && e.push(this._config.save), e
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class ao extends O {
    attributeKey;

    constructor(e, t) {
        super(e), this.attributeKey = t
    }

    refresh() {
        const e = this.editor.model, t = e.document;
        this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey)
    }

    execute(e = {}) {
        const t = this.editor.model, n = t.document.selection, o = e.forceValue === void 0 ? !this.value : e.forceValue;
        t.change(r => {
            if (n.isCollapsed) o ? r.setSelectionAttribute(this.attributeKey, !0) : r.removeSelectionAttribute(this.attributeKey); else {
                const a = t.schema.getValidRanges(n.getRanges(), this.attributeKey);
                for (const l of a) o ? r.setAttribute(this.attributeKey, o, l) : r.removeAttribute(this.attributeKey, l)
            }
        })
    }

    _getValueFromFirstAllowedNode() {
        const e = this.editor.model, t = e.schema, i = e.document.selection;
        if (i.isCollapsed) return i.hasAttribute(this.attributeKey);
        for (const n of i.getRanges()) for (const o of n.getItems()) if (t.checkAttribute(o, this.attributeKey)) return o.hasAttribute(this.attributeKey);
        return !1
    }
}

const yi = "bold";

class kC extends w {
    static get pluginName() {
        return "BoldEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = this.editor.t;
        e.model.schema.extend("$text", {allowAttributes: yi}), e.model.schema.setAttributeProperties(yi, {
            isFormatting: !0,
            copyOnEnter: !0
        }), e.conversion.attributeToElement({
            model: yi, view: "strong", upcastAlso: ["b", i => {
                const n = i.getStyle("font-weight");
                return n && (n == "bold" || Number(n) >= 600) ? {name: !0, styles: ["font-weight"]} : null
            }]
        }), e.commands.add(yi, new ao(e, yi)), e.keystrokes.set("CTRL+B", yi), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: t("Bold text"),
                keystroke: "CTRL+B"
            }]
        })
    }
}

function lo({editor: s, commandName: e, plugin: t, icon: i, label: n, keystroke: o}) {
    return r => {
        const a = s.commands.get(e), l = new r(s.locale);
        return l.set({
            label: n,
            icon: i,
            keystroke: o,
            isToggleable: !0
        }), l.bind("isEnabled").to(a, "isEnabled"), l.bind("isOn").to(a, "value"), l instanceof K ? l.set({role: "menuitemcheckbox"}) : l.set({tooltip: !0}), t.listenTo(l, "execute", () => {
            s.execute(e), s.editing.view.focus()
        }), l
    }
}

const Uo = "bold";

class CC extends w {
    static get pluginName() {
        return "BoldUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.locale.t,
            i = lo({editor: e, commandName: Uo, plugin: this, icon: df, label: t("Bold"), keystroke: "CTRL+B"});
        e.ui.componentFactory.add(Uo, () => i(I)), e.ui.componentFactory.add("menuBar:" + Uo, () => i(K))
    }
}

class EC extends w {
    static get requires() {
        return [kC, CC]
    }

    static get pluginName() {
        return "Bold"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

const ki = "italic";

class TC extends w {
    static get pluginName() {
        return "ItalicEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = this.editor.t;
        e.model.schema.extend("$text", {allowAttributes: ki}), e.model.schema.setAttributeProperties(ki, {
            isFormatting: !0,
            copyOnEnter: !0
        }), e.conversion.attributeToElement({
            model: ki,
            view: "i",
            upcastAlso: ["em", {styles: {"font-style": "italic"}}]
        }), e.commands.add(ki, new ao(e, ki)), e.keystrokes.set("CTRL+I", ki), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: t("Italic text"),
                keystroke: "CTRL+I"
            }]
        })
    }
}

const $o = "italic";

class AC extends w {
    static get pluginName() {
        return "ItalicUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.locale.t,
            i = lo({editor: e, commandName: $o, plugin: this, icon: r1, keystroke: "CTRL+I", label: t("Italic")});
        e.ui.componentFactory.add($o, () => i(I)), e.ui.componentFactory.add("menuBar:" + $o, () => i(K))
    }
}

class xC extends w {
    static get requires() {
        return [TC, AC]
    }

    static get pluginName() {
        return "Italic"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

const un = "strikethrough";

class IC extends w {
    static get pluginName() {
        return "StrikethroughEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = this.editor.t;
        e.model.schema.extend("$text", {allowAttributes: un}), e.model.schema.setAttributeProperties(un, {
            isFormatting: !0,
            copyOnEnter: !0
        }), e.conversion.attributeToElement({
            model: un,
            view: "s",
            upcastAlso: ["del", "strike", {styles: {"text-decoration": "line-through"}}]
        }), e.commands.add(un, new ao(e, un)), e.keystrokes.set("CTRL+SHIFT+X", "strikethrough"), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: t("Strikethrough text"),
                keystroke: "CTRL+SHIFT+X"
            }]
        })
    }
}

const Wo = "strikethrough";

class SC extends w {
    static get pluginName() {
        return "StrikethroughUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.locale.t, i = lo({
            editor: e,
            commandName: Wo,
            plugin: this,
            icon: S1,
            keystroke: "CTRL+SHIFT+X",
            label: t("Strikethrough")
        });
        e.ui.componentFactory.add(Wo, () => i(I)), e.ui.componentFactory.add("menuBar:" + Wo, () => i(K))
    }
}

class PC extends w {
    static get requires() {
        return [IC, SC]
    }

    static get pluginName() {
        return "Strikethrough"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

const dn = "underline";

class RC extends w {
    static get pluginName() {
        return "UnderlineEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = this.editor.t;
        e.model.schema.extend("$text", {allowAttributes: dn}), e.model.schema.setAttributeProperties(dn, {
            isFormatting: !0,
            copyOnEnter: !0
        }), e.conversion.attributeToElement({
            model: dn,
            view: "u",
            upcastAlso: {styles: {"text-decoration": "underline"}}
        }), e.commands.add(dn, new ao(e, dn)), e.keystrokes.set("CTRL+U", "underline"), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: t("Underline text"),
                keystroke: "CTRL+U"
            }]
        })
    }
}

const qo = "underline";

class VC extends w {
    static get pluginName() {
        return "UnderlineUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.locale.t,
            i = lo({editor: e, commandName: qo, plugin: this, icon: B1, label: t("Underline"), keystroke: "CTRL+U"});
        e.ui.componentFactory.add(qo, () => i(I)), e.ui.componentFactory.add("menuBar:" + qo, () => i(K))
    }
}

class OC extends w {
    static get requires() {
        return [RC, VC]
    }

    static get pluginName() {
        return "Underline"
    }

    static get isOfficialPlugin() {
        return !0
    }
}/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function* am(s, e) {
    for (const t of e) t && s.getAttributeProperties(t[0]).copyOnEnter && (yield t)
}

class MC extends O {
    execute() {
        this.editor.model.change(e => {
            this.enterBlock(e), this.fire("afterExecute", {writer: e})
        })
    }

    enterBlock(e) {
        const t = this.editor.model, i = t.document.selection, n = t.schema, o = i.isCollapsed, r = i.getFirstRange(),
            a = r.start.parent, l = r.end.parent;
        if (n.isLimit(a) || n.isLimit(l)) return !o && a == l && t.deleteContent(i), !1;
        if (o) {
            const c = am(e.model.schema, i.getAttributes());
            return Xc(e, r.start), e.setSelectionAttribute(c), !0
        } else {
            const c = !(r.start.isAtStart && r.end.isAtEnd), u = a == l;
            if (t.deleteContent(i, {leaveUnmerged: c}), c) {
                if (u) return Xc(e, i.focus), !0;
                e.setSelection(l, 0)
            }
        }
        return !1
    }
}

function Xc(s, e) {
    s.split(e), s.setSelection(e.parent.nextSibling, 0)
}

const BC = {insertParagraph: {isSoft: !1}, insertLineBreak: {isSoft: !0}};

class lm extends gt {
    constructor(e) {
        super(e);
        const t = this.document;
        let i = !1;
        t.on("keydown", (n, o) => {
            i = o.shiftKey
        }), t.on("beforeinput", (n, o) => {
            if (!this.isEnabled) return;
            let r = o.inputType;
            x.isSafari && i && r == "insertParagraph" && (r = "insertLineBreak");
            const a = o.domEvent, l = BC[r];
            if (!l) return;
            const c = new ri(t, "enter", o.targetRanges[0]);
            t.fire(c, new ei(e, a, {isSoft: l.isSoft})), c.stop.called && n.stop()
        })
    }

    observe() {
    }

    stopObserving() {
    }
}

class Gn extends w {
    static get pluginName() {
        return "Enter"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.editing.view, i = t.document, n = this.editor.t;
        t.addObserver(lm), e.commands.add("enter", new MC(e)), this.listenTo(i, "enter", (o, r) => {
            i.isComposing || r.preventDefault(), !r.isSoft && (e.execute("enter"), t.scrollToTheSelection())
        }, {priority: "low"}), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: n("Insert a hard break (a new paragraph)"),
                keystroke: "Enter"
            }]
        })
    }
}

class FC extends O {
    execute() {
        const e = this.editor.model, t = e.document;
        e.change(i => {
            DC(e, i, t.selection), this.fire("afterExecute", {writer: i})
        })
    }

    refresh() {
        const e = this.editor.model, t = e.document;
        this.isEnabled = LC(e.schema, t.selection)
    }
}

function LC(s, e) {
    if (e.rangeCount > 1) return !1;
    const t = e.anchor;
    if (!t || !s.checkChild(t, "softBreak")) return !1;
    const i = e.getFirstRange(), n = i.start.parent, o = i.end.parent;
    return !((Ar(n, s) || Ar(o, s)) && n !== o)
}

function DC(s, e, t) {
    const i = t.isCollapsed, n = t.getFirstRange(), o = n.start.parent, r = n.end.parent, a = o == r;
    if (i) {
        const l = am(s.schema, t.getAttributes());
        eu(s, e, n.end), e.removeSelectionAttribute(t.getAttributeKeys()), e.setSelectionAttribute(l)
    } else {
        const l = !(n.start.isAtStart && n.end.isAtEnd);
        s.deleteContent(t, {leaveUnmerged: l}), a ? eu(s, e, t.focus) : l && e.setSelection(r, 0)
    }
}

function eu(s, e, t) {
    const i = e.createElement("softBreak");
    s.insertContent(i, t), e.setSelection(i, "after")
}

function Ar(s, e) {
    return s.is("rootElement") ? !1 : e.isLimit(s) || Ar(s.parent, e)
}

class NC extends w {
    static get pluginName() {
        return "ShiftEnter"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.model.schema, i = e.conversion, n = e.editing.view, o = n.document,
            r = this.editor.t;
        t.register("softBreak", {
            allowWhere: "$text",
            isInline: !0
        }), i.for("upcast").elementToElement({
            model: "softBreak",
            view: "br"
        }), i.for("downcast").elementToElement({
            model: "softBreak",
            view: (a, {writer: l}) => l.createEmptyElement("br")
        }), n.addObserver(lm), e.commands.add("shiftEnter", new FC(e)), this.listenTo(o, "enter", (a, l) => {
            o.isComposing || l.preventDefault(), l.isSoft && (e.execute("shiftEnter"), n.scrollToTheSelection())
        }, {priority: "low"}), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: r("Insert a soft break (a <code>&lt;br&gt;</code> element)"),
                keystroke: "Shift+Enter"
            }]
        })
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class zC extends O {
    refresh() {
        this.value = this._getValue(), this.isEnabled = this._checkEnabled()
    }

    execute(e = {}) {
        const t = this.editor.model, i = t.schema, n = t.document.selection, o = Array.from(n.getSelectedBlocks()),
            r = e.forceValue === void 0 ? !this.value : e.forceValue;
        t.change(a => {
            if (!r) this._removeQuote(a, o.filter(ls)); else {
                const l = o.filter(c => ls(c) || iu(i, c));
                this._applyQuote(a, l)
            }
        })
    }

    _getValue() {
        const e = this.editor.model.document.selection, t = re(e.getSelectedBlocks());
        return !!(t && ls(t))
    }

    _checkEnabled() {
        if (this.value) return !0;
        const e = this.editor.model.document.selection, t = this.editor.model.schema, i = re(e.getSelectedBlocks());
        return i ? iu(t, i) : !1
    }

    _removeQuote(e, t) {
        tu(e, t).reverse().forEach(i => {
            if (i.start.isAtStart && i.end.isAtEnd) {
                e.unwrap(i.start.parent);
                return
            }
            if (i.start.isAtStart) {
                const o = e.createPositionBefore(i.start.parent);
                e.move(i, o);
                return
            }
            i.end.isAtEnd || e.split(i.end);
            const n = e.createPositionAfter(i.end.parent);
            e.move(i, n)
        })
    }

    _applyQuote(e, t) {
        const i = [];
        tu(e, t).reverse().forEach(n => {
            let o = ls(n.start);
            o || (o = e.createElement("blockQuote"), e.wrap(n, o)), i.push(o)
        }), i.reverse().reduce((n, o) => n.nextSibling == o ? (e.merge(e.createPositionAfter(n)), n) : o)
    }
}

function ls(s) {
    return s.parent.name == "blockQuote" ? s.parent : null
}

function tu(s, e) {
    let t, i = 0;
    const n = [];
    for (; i < e.length;) {
        const o = e[i], r = e[i + 1];
        t || (t = s.createPositionBefore(o)), (!r || o.nextSibling != r) && (n.push(s.createRange(t, s.createPositionAfter(o))), t = null), i++
    }
    return n
}

function iu(s, e) {
    const t = s.checkChild(e.parent, "blockQuote"), i = s.checkChild(["$root", "blockQuote"], e);
    return t && i
}

class HC extends w {
    static get pluginName() {
        return "BlockQuoteEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Gn, mt]
    }

    init() {
        const e = this.editor, t = e.model.schema;
        e.commands.add("blockQuote", new zC(e)), t.register("blockQuote", {inheritAllFrom: "$container"}), e.conversion.elementToElement({
            model: "blockQuote",
            view: "blockquote"
        }), e.model.document.registerPostFixer(r => {
            const a = e.model.document.differ.getChanges();
            for (const l of a) if (l.type == "insert") {
                const c = l.position.nodeAfter;
                if (!c) continue;
                if (c.is("element", "blockQuote") && c.isEmpty) return r.remove(c), !0;
                if (c.is("element", "blockQuote") && !t.checkChild(l.position, c)) return r.unwrap(c), !0;
                if (c.is("element")) {
                    const u = r.createRangeIn(c);
                    for (const d of u.getItems()) if (d.is("element", "blockQuote") && !t.checkChild(r.createPositionBefore(d), d)) return r.unwrap(d), !0
                }
            } else if (l.type == "remove") {
                const c = l.position.parent;
                if (c.is("element", "blockQuote") && c.isEmpty) return r.remove(c), !0
            }
            return !1
        });
        const i = this.editor.editing.view.document, n = e.model.document.selection, o = e.commands.get("blockQuote");
        this.listenTo(i, "enter", (r, a) => {
            if (!n.isCollapsed || !o.value) return;
            n.getLastPosition().parent.isEmpty && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), r.stop())
        }, {context: "blockquote"}), this.listenTo(i, "delete", (r, a) => {
            if (a.direction != "backward" || !n.isCollapsed || !o.value) return;
            const l = n.getLastPosition().parent;
            l.isEmpty && !l.previousSibling && (e.execute("blockQuote"), e.editing.view.scrollToTheSelection(), a.preventDefault(), r.stop())
        }, {context: "blockquote"})
    }
}

class UC extends w {
    static get pluginName() {
        return "BlockQuoteUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        e.ui.componentFactory.add("blockQuote", () => {
            const t = this._createButton(I);
            return t.set({tooltip: !0}), t
        }), e.ui.componentFactory.add("menuBar:blockQuote", () => {
            const t = this._createButton(K);
            return t.set({role: "menuitemcheckbox"}), t
        })
    }

    _createButton(e) {
        const t = this.editor, i = t.locale, n = t.commands.get("blockQuote"), o = new e(t.locale), r = i.t;
        return o.set({
            label: r("Block quote"),
            icon: C1,
            isToggleable: !0
        }), o.bind("isEnabled").to(n, "isEnabled"), o.bind("isOn").to(n, "value"), this.listenTo(o, "execute", () => {
            t.execute("blockQuote"), t.editing.view.focus()
        }), o
    }
}

class $C extends w {
    static get requires() {
        return [HC, UC]
    }

    static get pluginName() {
        return "BlockQuote"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class WC extends W() {
    _stack = [];

    add(e, t) {
        const i = this._stack, n = i[0];
        this._insertDescriptor(e);
        const o = i[0];
        n !== o && !jo(n, o) && this.fire("change:top", {oldDescriptor: n, newDescriptor: o, writer: t})
    }

    remove(e, t) {
        const i = this._stack, n = i[0];
        this._removeDescriptor(e);
        const o = i[0];
        n !== o && !jo(n, o) && this.fire("change:top", {oldDescriptor: n, newDescriptor: o, writer: t})
    }

    _insertDescriptor(e) {
        const t = this._stack, i = t.findIndex(o => o.id === e.id);
        if (jo(e, t[i])) return;
        i > -1 && t.splice(i, 1);
        let n = 0;
        for (; t[n] && qC(t[n], e);) n++;
        t.splice(n, 0, e)
    }

    _removeDescriptor(e) {
        const t = this._stack, i = t.findIndex(n => n.id === e);
        i > -1 && t.splice(i, 1)
    }
}

function jo(s, e) {
    return s && e && s.priority == e.priority && Us(s.classes) == Us(e.classes)
}

function qC(s, e) {
    return s.priority > e.priority ? !0 : s.priority < e.priority ? !1 : Us(s.classes) > Us(e.classes)
}

function Us(s) {
    return Array.isArray(s) ? s.sort().join(",") : s
}

const jC = "ck-widget", nu = "ck-widget_selected";

function ie(s) {
    return s.is("element") ? !!s.getCustomProperty("widget") : !1
}

function Xi(s, e, t = {}) {
    if (!s.is("containerElement")) throw new p("widget-to-widget-wrong-element-type", null, {element: s});
    return e.setAttribute("contenteditable", "false", s), e.addClass(jC, s), e.setCustomProperty("widget", !0, s), s.getFillerOffset = QC, e.setCustomProperty("widgetLabel", [], s), t.label && ZC(s, t.label), t.hasSelectionHandle && YC(s, e), cm(s, e), s
}

function GC(s, e, t) {
    if (e.classes && t.addClass(U(e.classes), s), e.attributes) for (const i in e.attributes) t.setAttribute(i, e.attributes[i], s)
}

function KC(s, e, t) {
    if (e.classes && t.removeClass(U(e.classes), s), e.attributes) for (const i in e.attributes) t.removeAttribute(i, s)
}

function cm(s, e, t = GC, i = KC) {
    const n = new WC;
    n.on("change:top", (a, l) => {
        l.oldDescriptor && i(s, l.oldDescriptor, l.writer), l.newDescriptor && t(s, l.newDescriptor, l.writer)
    });
    const o = (a, l, c) => n.add(l, c), r = (a, l, c) => n.remove(l, c);
    e.setCustomProperty("addHighlight", o, s), e.setCustomProperty("removeHighlight", r, s)
}

function ZC(s, e) {
    s.getCustomProperty("widgetLabel").push(e)
}

function JC(s) {
    return s.getCustomProperty("widgetLabel").reduce((t, i) => typeof i == "function" ? t ? t + ". " + i() : i() : t ? t + ". " + i : i, "")
}

function um(s, e, t = {}) {
    return e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], s), t.withAriaRole !== !1 && e.setAttribute("role", "textbox", s), e.setAttribute("tabindex", "-1", s), t.label && e.setAttribute("aria-label", t.label, s), e.setAttribute("contenteditable", s.isReadOnly ? "false" : "true", s), s.on("change:isReadOnly", (i, n, o) => {
        e.setAttribute("contenteditable", o ? "false" : "true", s)
    }), s.on("change:isFocused", (i, n, o) => {
        o ? e.addClass("ck-editor__nested-editable_focused", s) : e.removeClass("ck-editor__nested-editable_focused", s)
    }), cm(s, e), s
}

function ka(s, e) {
    const t = s.getSelectedElement();
    if (t) {
        const i = Mt(s);
        if (i) return e.createRange(e.createPositionAt(t, i))
    }
    return e.schema.findOptimalInsertionRange(s)
}

function QC() {
    return null
}

function YC(s, e) {
    const t = e.createUIElement("div", {class: "ck ck-widget__selection-handle"}, function (i) {
        const n = this.toDomElement(i), o = new ot;
        return o.set("content", Qv), o.render(), n.appendChild(o.element), n
    });
    e.insert(e.createPositionAt(s, 0), t), e.addClass(["ck-widget_with-selection-handle"], s)
}

function Ca(s) {
    const e = a => {
        const {width: l, paddingLeft: c, paddingRight: u} = a.ownerDocument.defaultView.getComputedStyle(a);
        return parseFloat(l) - (parseFloat(c) || 0) - (parseFloat(u) || 0)
    }, t = s.parentElement;
    if (!t) return 0;
    let i = e(t);
    const n = 5;
    let o = 0, r = t;
    for (; isNaN(i);) {
        if (r = r.parentElement, ++o > n) return 0;
        i = e(r)
    }
    return i
}

function XC(s, e = new R(s)) {
    const t = Ca(s);
    return t ? e.width / t * 100 : 0
}

const vt = "widget-type-around";

function Zt(s, e, t) {
    return !!s && ie(s) && !t.isInline(e)
}

function eE(s) {
    return s.closest(".ck-widget__type-around__button")
}

function tE(s) {
    return s.classList.contains("ck-widget__type-around__button_before") ? "before" : "after"
}

function iE(s, e) {
    const t = s.closest(".ck-widget");
    return e.mapDomToView(t)
}

function Mt(s) {
    return s.getAttribute(vt)
}

const dm = ["before", "after"], nE = new DOMParser().parseFromString(T1, "image/svg+xml").firstChild,
    su = "ck-widget__type-around_disabled";

class sE extends w {
    _currentFakeCaretModelElement = null;

    static get pluginName() {
        return "WidgetTypeAround"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Gn, mt]
    }

    init() {
        const e = this.editor, t = e.editing.view;
        this.on("change:isEnabled", (i, n, o) => {
            t.change(r => {
                for (const a of t.document.roots) o ? r.removeClass(su, a) : r.addClass(su, a)
            }), o || e.model.change(r => {
                r.removeSelectionAttribute(vt)
            })
        }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration()
    }

    destroy() {
        super.destroy(), this._currentFakeCaretModelElement = null
    }

    _insertParagraph(e, t) {
        const i = this.editor, n = i.editing.view, o = i.model.schema.getAttributesWithProperty(e, "copyOnReplace", !0);
        i.execute("insertParagraph", {
            position: i.model.createPositionAt(e, t),
            attributes: o
        }), n.focus(), n.scrollToTheSelection()
    }

    _listenToIfEnabled(e, t, i, n) {
        this.listenTo(e, t, (...o) => {
            this.isEnabled && i(...o)
        }, n)
    }

    _insertParagraphAccordingToFakeCaretPosition() {
        const i = this.editor.model.document.selection, n = Mt(i);
        if (!n) return !1;
        const o = i.getSelectedElement();
        return this._insertParagraph(o, n), !0
    }

    _enableTypeAroundUIInjection() {
        const e = this.editor, t = e.model.schema, i = e.locale.t,
            n = {before: i("Insert paragraph before block"), after: i("Insert paragraph after block")};
        e.editing.downcastDispatcher.on("insert", (o, r, a) => {
            const l = a.mapper.toViewElement(r.item);
            l && Zt(l, r.item, t) && (oE(a.writer, n, l), l.getCustomProperty("widgetLabel").push(() => this.isEnabled ? i("Press Enter to type after or press Shift + Enter to type before the widget") : ""))
        }, {priority: "low"})
    }

    _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
        const e = this.editor, t = e.model, i = t.document.selection, n = t.schema, o = e.editing.view;
        this._listenToIfEnabled(o.document, "arrowKey", (a, l) => {
            this._handleArrowKeyPress(a, l)
        }, {context: [ie, "$text"], priority: "high"}), this._listenToIfEnabled(i, "change:range", (a, l) => {
            l.directChange && e.model.change(c => {
                c.removeSelectionAttribute(vt)
            })
        }), this._listenToIfEnabled(t.document, "change:data", () => {
            const a = i.getSelectedElement();
            if (a) {
                const l = e.editing.mapper.toViewElement(a);
                if (Zt(l, a, n)) return
            }
            e.model.change(l => {
                l.removeSelectionAttribute(vt)
            })
        }), this._listenToIfEnabled(e.editing.downcastDispatcher, "selection", (a, l, c) => {
            const u = c.writer;
            if (this._currentFakeCaretModelElement) {
                const m = c.mapper.toViewElement(this._currentFakeCaretModelElement);
                m && (u.removeClass(dm.map(r), m), this._currentFakeCaretModelElement = null)
            }
            const d = l.selection.getSelectedElement();
            if (!d) return;
            const h = c.mapper.toViewElement(d);
            if (!Zt(h, d, n)) return;
            const f = Mt(l.selection);
            f && (u.addClass(r(f), h), this._currentFakeCaretModelElement = d)
        }), this._listenToIfEnabled(e.ui.focusTracker, "change:isFocused", (a, l, c) => {
            c || e.model.change(u => {
                u.removeSelectionAttribute(vt)
            })
        });

        function r(a) {
            return `ck-widget_type-around_show-fake-caret_${a}`
        }
    }

    _handleArrowKeyPress(e, t) {
        const i = this.editor, n = i.model, o = n.document.selection, r = n.schema, a = i.editing.view, l = t.keyCode,
            c = Yp(l, i.locale.contentLanguageDirection), u = a.document.selection.getSelectedElement(),
            d = i.editing.mapper.toModelElement(u);
        let h;
        Zt(u, d, r) ? h = this._handleArrowKeyPressOnSelectedWidget(c) : o.isCollapsed ? h = this._handleArrowKeyPressWhenSelectionNextToAWidget(c) : t.shiftKey || (h = this._handleArrowKeyPressWhenNonCollapsedSelection(c)), h && (t.preventDefault(), e.stop())
    }

    _handleArrowKeyPressOnSelectedWidget(e) {
        const i = this.editor.model, n = i.document.selection, o = Mt(n);
        return i.change(r => {
            if (o) {
                if (!(o === (e ? "after" : "before"))) return r.removeSelectionAttribute(vt), !0
            } else return r.setSelectionAttribute(vt, e ? "after" : "before"), !0;
            return !1
        })
    }

    _handleArrowKeyPressWhenSelectionNextToAWidget(e) {
        const t = this.editor, i = t.model, n = i.schema, o = t.plugins.get("Widget"),
            r = o._getObjectElementNextToSelection(e), a = t.editing.mapper.toViewElement(r);
        return Zt(a, r, n) ? (i.change(l => {
            o._setSelectionOverElement(r), l.setSelectionAttribute(vt, e ? "before" : "after")
        }), !0) : !1
    }

    _handleArrowKeyPressWhenNonCollapsedSelection(e) {
        const t = this.editor, i = t.model, n = i.schema, o = t.editing.mapper, r = i.document.selection,
            a = e ? r.getLastPosition().nodeBefore : r.getFirstPosition().nodeAfter, l = o.toViewElement(a);
        return Zt(l, a, n) ? (i.change(c => {
            c.setSelection(a, "on"), c.setSelectionAttribute(vt, e ? "after" : "before")
        }), !0) : !1
    }

    _enableInsertingParagraphsOnButtonClick() {
        const e = this.editor, t = e.editing.view;
        this._listenToIfEnabled(t.document, "mousedown", (i, n) => {
            const o = eE(n.domTarget);
            if (!o) return;
            const r = tE(o), a = iE(o, t.domConverter), l = e.editing.mapper.toModelElement(a);
            this._insertParagraph(l, r), n.preventDefault(), i.stop()
        })
    }

    _enableInsertingParagraphsOnEnterKeypress() {
        const e = this.editor, t = e.model.document.selection, i = e.editing.view;
        this._listenToIfEnabled(i.document, "enter", (n, o) => {
            if (n.eventPhase != "atTarget") return;
            const r = t.getSelectedElement(), a = e.editing.mapper.toViewElement(r), l = e.model.schema;
            let c;
            this._insertParagraphAccordingToFakeCaretPosition() ? c = !0 : Zt(a, r, l) && (this._insertParagraph(r, o.isSoft ? "before" : "after"), c = !0), c && (o.preventDefault(), n.stop())
        }, {context: ie})
    }

    _enableInsertingParagraphsOnTypingKeystroke() {
        const t = this.editor.editing.view.document;
        this._listenToIfEnabled(t, "insertText", (i, n) => {
            this._insertParagraphAccordingToFakeCaretPosition() && (n.selection = t.selection)
        }, {priority: "high"}), x.isAndroid ? this._listenToIfEnabled(t, "keydown", (i, n) => {
            n.keyCode == 229 && this._insertParagraphAccordingToFakeCaretPosition()
        }) : this._listenToIfEnabled(t, "compositionstart", () => {
            this._insertParagraphAccordingToFakeCaretPosition()
        }, {priority: "highest"})
    }

    _enableDeleteIntegration() {
        const e = this.editor, t = e.editing.view, i = e.model, n = i.schema;
        this._listenToIfEnabled(t.document, "delete", (o, r) => {
            if (o.eventPhase != "atTarget") return;
            const a = Mt(i.document.selection);
            if (!a) return;
            const l = r.direction, c = i.document.selection.getSelectedElement(), u = a === "before",
                d = l == "forward";
            if (u === d) e.execute("delete", {selection: i.createSelection(c, "on")}); else {
                const f = n.getNearestSelectionRange(i.createPositionAt(c, a), l);
                if (f) if (!f.isCollapsed) i.change(m => {
                    m.setSelection(f), e.execute(d ? "deleteForward" : "delete")
                }); else {
                    const m = i.createSelection(f.start);
                    if (i.modifySelection(m, {direction: l}), !m.focus.isEqual(f.start)) i.change(g => {
                        g.setSelection(f), e.execute(d ? "deleteForward" : "delete")
                    }); else {
                        const g = lE(n, f.start.parent);
                        i.deleteContent(i.createSelection(g, "on"), {doNotAutoparagraph: !0})
                    }
                }
            }
            r.preventDefault(), o.stop()
        }, {context: ie})
    }

    _enableInsertContentIntegration() {
        const e = this.editor, t = this.editor.model, i = t.document.selection;
        this._listenToIfEnabled(e.model, "insertContent", (n, [o, r]) => {
            if (r && !r.is("documentSelection")) return;
            const a = Mt(i);
            if (a) return n.stop(), t.change(l => {
                const c = i.getSelectedElement(), u = t.createPositionAt(c, a), d = l.createSelection(u),
                    h = t.insertContent(o, d);
                return l.setSelection(d), h
            })
        }, {priority: "high"})
    }

    _enableInsertObjectIntegration() {
        const e = this.editor, i = this.editor.model.document.selection;
        this._listenToIfEnabled(e.model, "insertObject", (n, o) => {
            const [, r, a = {}] = o;
            if (r && !r.is("documentSelection")) return;
            const l = Mt(i);
            l && (a.findOptimalPosition = l, o[3] = a)
        }, {priority: "high"})
    }

    _enableDeleteContentIntegration() {
        const e = this.editor, i = this.editor.model.document.selection;
        this._listenToIfEnabled(e.model, "deleteContent", (n, [o]) => {
            if (o && !o.is("documentSelection")) return;
            Mt(i) && n.stop()
        }, {priority: "high"})
    }
}

function oE(s, e, t) {
    const i = s.createUIElement("div", {class: "ck ck-reset_all ck-widget__type-around"}, function (n) {
        const o = this.toDomElement(n);
        return rE(o, e), aE(o), o
    });
    s.insert(s.createPositionAt(t, "end"), i)
}

function rE(s, e) {
    for (const t of dm) {
        const i = new Te({
            tag: "div",
            attributes: {
                class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${t}`],
                title: e[t],
                "aria-hidden": "true"
            },
            children: [s.ownerDocument.importNode(nE, !0)]
        });
        s.appendChild(i.render())
    }
}

function aE(s) {
    const e = new Te({tag: "div", attributes: {class: ["ck", "ck-widget__type-around__fake-caret"]}});
    s.appendChild(e.render())
}

function lE(s, e) {
    let t = e;
    for (const i of e.getAncestors({parentFirst: !0})) {
        if (i.childCount > 1 || s.isLimit(i)) break;
        t = i
    }
    return t
}

function cE(s) {
    const e = s.model;
    return (t, i) => {
        const n = i.keyCode == M.arrowup, o = i.keyCode == M.arrowdown, r = i.shiftKey, a = e.document.selection;
        if (!n && !o) return;
        const l = o;
        if (r && hE(a, l)) return;
        const c = uE(s, a, l);
        if (c) {
            if (c.isCollapsed) {
                if (a.isCollapsed) return;
                if (r) return
            }
            (c.isCollapsed || dE(s, c, l)) && (e.change(u => {
                const d = l ? c.end : c.start;
                if (r) {
                    const h = e.createSelection(a.anchor);
                    h.setFocus(d), u.setSelection(h)
                } else u.setSelection(d)
            }), t.stop(), i.preventDefault(), i.stopPropagation())
        }
    }
}

function uE(s, e, t) {
    const i = s.model;
    if (t) {
        const n = e.isCollapsed ? e.focus : e.getLastPosition(), o = ou(i, n, "forward");
        if (!o) return null;
        const r = i.createRange(n, o), a = ru(i.schema, r, "backward");
        return a ? i.createRange(n, a) : null
    } else {
        const n = e.isCollapsed ? e.focus : e.getFirstPosition(), o = ou(i, n, "backward");
        if (!o) return null;
        const r = i.createRange(o, n), a = ru(i.schema, r, "forward");
        return a ? i.createRange(a, n) : null
    }
}

function ou(s, e, t) {
    const i = s.schema, n = s.createRangeIn(e.root), o = t == "forward" ? "elementStart" : "elementEnd";
    for (const {previousPosition: r, item: a, type: l} of n.getWalker({startPosition: e, direction: t})) {
        if (i.isLimit(a) && !i.isInline(a)) return r;
        if (l == o && i.isBlock(a)) return null
    }
    return null
}

function ru(s, e, t) {
    const i = t == "backward" ? e.end : e.start;
    if (s.checkChild(i, "$text")) return i;
    for (const {nextPosition: n} of e.getWalker({direction: t})) if (s.checkChild(n, "$text")) return n;
    return null
}

function dE(s, e, t) {
    const i = s.model, n = s.view.domConverter;
    if (t) {
        const c = i.createSelection(e.start);
        i.modifySelection(c), !c.focus.isAtEnd && !e.start.isEqual(c.focus) && (e = i.createRange(c.focus, e.end))
    }
    const o = s.mapper.toViewRange(e), r = n.viewRangeToDom(o), a = R.getDomRangeRects(r);
    let l;
    for (const c of a) {
        if (l === void 0) {
            l = Math.round(c.bottom);
            continue
        }
        if (Math.round(c.top) >= l) return !1;
        l = Math.max(l, Math.round(c.bottom))
    }
    return !0
}

function hE(s, e) {
    return !s.isCollapsed && s.isBackward == e
}

class di extends w {
    _previouslySelected = new Set;

    static get pluginName() {
        return "Widget"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [sE, mt]
    }

    init() {
        const e = this.editor, t = e.editing.view, i = t.document, n = e.t;
        this.editor.editing.downcastDispatcher.on("selection", (o, r, a) => {
            const l = a.writer, c = r.selection;
            if (c.isCollapsed) return;
            const u = c.getSelectedElement();
            if (!u) return;
            const d = e.editing.mapper.toViewElement(u);
            ie(d) && a.consumable.consume(c, "selection") && l.setSelection(l.createRangeOn(d), {
                fake: !0,
                label: JC(d)
            })
        }), this.editor.editing.downcastDispatcher.on("selection", (o, r, a) => {
            this._clearPreviouslySelectedWidgets(a.writer);
            const l = a.writer, c = l.document.selection;
            let u = null;
            for (const d of c.getRanges()) for (const h of d) {
                const f = h.item;
                ie(f) && !gE(f, u) && (l.addClass(nu, f), this._previouslySelected.add(f), u = f)
            }
        }, {priority: "low"}), t.addObserver(to), this.listenTo(i, "mousedown", (...o) => this._onMousedown(...o)), this.listenTo(i, "arrowKey", (...o) => {
            this._handleSelectionChangeOnArrowKeyPress(...o)
        }, {context: [ie, "$text"]}), this.listenTo(i, "arrowKey", (...o) => {
            this._preventDefaultOnArrowKeyPress(...o)
        }, {context: "$root"}), this.listenTo(i, "arrowKey", cE(this.editor.editing), {context: "$text"}), this.listenTo(i, "delete", (o, r) => {
            this._handleDelete(r.direction == "forward") && (r.preventDefault(), o.stop())
        }, {context: "$root"}), this.listenTo(i, "tab", (o, r) => {
            o.eventPhase == "atTarget" && (r.shiftKey || this._selectFirstNestedEditable() && (r.preventDefault(), o.stop()))
        }, {context: ie, priority: "low"}), this.listenTo(i, "tab", (o, r) => {
            r.shiftKey && this._selectAncestorWidget() && (r.preventDefault(), o.stop())
        }, {priority: "low"}), this.listenTo(i, "keydown", (o, r) => {
            r.keystroke == M.esc && this._selectAncestorWidget() && (r.preventDefault(), o.stop())
        }, {priority: "low"}), e.accessibility.addKeystrokeInfoGroup({
            id: "widget",
            label: n("Keystrokes that can be used when a widget is selected (for example: image, table, etc.)"),
            keystrokes: [{
                label: n("Move focus from an editable area back to the parent widget"),
                keystroke: "Esc"
            }, {
                label: n("Insert a new paragraph directly after a widget"),
                keystroke: "Enter"
            }, {
                label: n("Insert a new paragraph directly before a widget"),
                keystroke: "Shift+Enter"
            }, {
                label: n("Move the caret to allow typing directly before a widget"),
                keystroke: [["arrowup"], ["arrowleft"]]
            }, {
                label: n("Move the caret to allow typing directly after a widget"),
                keystroke: [["arrowdown"], ["arrowright"]]
            }]
        })
    }

    _onMousedown(e, t) {
        const i = this.editor, n = i.editing.view, o = n.document;
        let r = t.target;
        if (!r) return;
        if (t.domEvent.detail >= 3) {
            this._selectBlockContent(r) && t.preventDefault();
            return
        }
        if (!ie(r)) {
            const l = fE(r);
            if (!l) return;
            if (ie(l)) r = l; else {
                const c = mE(n, t);
                if (c && ie(c)) r = c; else return
            }
        }
        x.isAndroid && t.preventDefault(), o.isFocused || n.focus();
        const a = i.editing.mapper.toModelElement(r);
        this._setSelectionOverElement(a)
    }

    _selectBlockContent(e) {
        const t = this.editor, i = t.model, n = t.editing.mapper, o = i.schema,
            r = n.findMappedViewAncestor(this.editor.editing.view.createPositionAt(e, 0)),
            a = pE(n.toModelElement(r), i.schema);
        return a ? (i.change(l => {
            const c = o.isLimit(a) ? null : wE(l.createPositionAfter(a), o), u = l.createPositionAt(a, 0),
                d = c ? l.createPositionAt(c, 0) : l.createPositionAt(a, "end");
            l.setSelection(l.createRange(u, d))
        }), !0) : !1
    }

    _handleSelectionChangeOnArrowKeyPress(e, t) {
        const i = t.keyCode, n = this.editor.model, o = n.schema, r = n.document.selection, a = r.getSelectedElement(),
            l = Yr(i, this.editor.locale.contentLanguageDirection), c = l == "down" || l == "right",
            u = l == "up" || l == "down";
        if (a && o.isObject(a)) {
            const h = c ? r.getLastPosition() : r.getFirstPosition(),
                f = o.getNearestSelectionRange(h, c ? "forward" : "backward");
            f && (n.change(m => {
                m.setSelection(f)
            }), t.preventDefault(), e.stop());
            return
        }
        if (!r.isCollapsed && !t.shiftKey) {
            const h = r.getFirstPosition(), f = r.getLastPosition(), m = h.nodeAfter, g = f.nodeBefore;
            (m && o.isObject(m) || g && o.isObject(g)) && (n.change(_ => {
                _.setSelection(c ? f : h)
            }), t.preventDefault(), e.stop());
            return
        }
        if (!r.isCollapsed) return;
        const d = this._getObjectElementNextToSelection(c);
        if (d && o.isObject(d)) {
            if (o.isInline(d) && u) return;
            this._setSelectionOverElement(d), t.preventDefault(), e.stop()
        }
    }

    _preventDefaultOnArrowKeyPress(e, t) {
        const i = this.editor.model, n = i.schema, o = i.document.selection.getSelectedElement();
        o && n.isObject(o) && (t.preventDefault(), e.stop())
    }

    _handleDelete(e) {
        const i = this.editor.model.document.selection;
        if (!this.editor.model.canEditAt(i) || !i.isCollapsed) return;
        const n = this._getObjectElementNextToSelection(e);
        if (n) return this.editor.model.change(o => {
            let r = i.anchor.parent;
            for (; r.isEmpty;) {
                const a = r;
                r = a.parent, o.remove(a)
            }
            this._setSelectionOverElement(n)
        }), !0
    }

    _setSelectionOverElement(e) {
        this.editor.model.change(t => {
            t.setSelection(t.createRangeOn(e))
        })
    }

    _getObjectElementNextToSelection(e) {
        const t = this.editor.model, i = t.schema, n = t.document.selection, o = t.createSelection(n);
        if (t.modifySelection(o, {direction: e ? "forward" : "backward"}), o.isEqual(n)) return null;
        const r = e ? o.focus.nodeBefore : o.focus.nodeAfter;
        return r && i.isObject(r) ? r : null
    }

    _clearPreviouslySelectedWidgets(e) {
        for (const t of this._previouslySelected) e.removeClass(nu, t);
        this._previouslySelected.clear()
    }

    _selectFirstNestedEditable() {
        const e = this.editor, i = this.editor.editing.view.document;
        for (const n of i.selection.getFirstRange().getItems()) if (n.is("editableElement")) {
            const o = e.editing.mapper.toModelElement(n);/* istanbul ignore next -- @preserve */
            if (!o) continue;
            const r = e.model.createPositionAt(o, 0), a = e.model.schema.getNearestSelectionRange(r, "forward");
            return e.model.change(l => {
                l.setSelection(a)
            }), !0
        }
        return !1
    }

    _selectAncestorWidget() {
        const e = this.editor, t = e.editing.mapper, n = e.editing.view.document.selection.getFirstPosition().parent,
            r = (n.is("$text") ? n.parent : n).findAncestor(ie);
        if (!r) return !1;
        const a = t.toModelElement(r);/* istanbul ignore next -- @preserve */
        return a ? (e.model.change(l => {
            l.setSelection(a, "on")
        }), !0) : !1
    }
}

function fE(s) {
    let e = s;
    for (; e;) {
        if (e.is("editableElement") || ie(e)) return e;
        e = e.parent
    }
    return null
}

function mE(s, e) {
    const t = oh(e.domEvent);
    let i = null;
    if (t ? i = s.domConverter.domRangeToView(t) : i = s.createRange(s.createPositionAt(e.target, 0)), !i) return null;
    const n = i.start;
    if (!n.parent) return null;
    let o = n.parent;
    return n.parent.is("editableElement") && (n.isAtEnd && n.nodeBefore ? o = n.nodeBefore : n.isAtStart && n.nodeAfter && (o = n.nodeAfter)), o.is("$text") ? o.parent : o
}

function gE(s, e) {
    return e ? Array.from(s.getAncestors()).includes(e) : !1
}

function pE(s, e) {
    for (const t of s.getAncestors({includeSelf: !0, parentFirst: !0})) {
        if (e.checkChild(t, "$text")) return t;
        if (e.isLimit(t) && !e.isObject(t)) break
    }
    return null
}

function wE(s, e) {
    const t = new Ct({startPosition: s});
    for (const {item: i} of t) {
        if (e.isLimit(i) || !i.is("element")) return null;
        if (e.checkChild(i, "$text")) return i
    }
    return null
}

class $s extends w {
    _toolbarDefinitions = new Map;
    _balloon;

    static get requires() {
        return [ii]
    }

    static get pluginName() {
        return "WidgetToolbarRepository"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        if (e.plugins.has("BalloonToolbar")) {
            const t = e.plugins.get("BalloonToolbar");
            this.listenTo(t, "show", i => {
                bE(e.editing.view.document.selection) && i.stop()
            }, {priority: "high"})
        }
        this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility()
        }), this.listenTo(e.ui, "update", () => {
            this._updateToolbarsVisibility()
        }), this.listenTo(e.ui.focusTracker, "change:isFocused", () => {
            this._updateToolbarsVisibility()
        }, {priority: "low"})
    }

    destroy() {
        super.destroy();
        for (const e of this._toolbarDefinitions.values()) e.view.destroy()
    }

    register(e, {
        ariaLabel: t,
        items: i,
        getRelatedElement: n,
        balloonClassName: o = "ck-toolbar-container",
        positions: r
    }) {
        if (!i.length) {
            L("widget-toolbar-no-items", {toolbarId: e});
            return
        }
        const a = this.editor, l = a.t, c = new oo(a.locale);
        if (c.ariaLabel = t || l("Widget toolbar"), this._toolbarDefinitions.has(e)) throw new p("widget-toolbar-duplicated", this, {toolbarId: e});
        const u = {view: c, getRelatedElement: n, balloonClassName: o, itemsConfig: i, positions: r, initialized: !1};
        a.ui.addToolbar(c, {
            isContextual: !0, beforeFocus: () => {
                const d = n(a.editing.view.document.selection);
                d && this._showToolbar(u, d)
            }, afterBlur: () => {
                this._hideToolbar(u)
            }
        }), this._toolbarDefinitions.set(e, u)
    }

    _updateToolbarsVisibility() {
        let e = 0, t = null, i = null;
        for (const n of this._toolbarDefinitions.values()) {
            const o = n.getRelatedElement(this.editor.editing.view.document.selection);
            if (!this.isEnabled || !o) this._isToolbarInBalloon(n) && this._hideToolbar(n); else if (!this.editor.ui.focusTracker.isFocused) this._isToolbarVisible(n) && this._hideToolbar(n); else {
                const r = o.getAncestors().length;
                r > e && (e = r, t = o, i = n)
            }
        }
        i && this._showToolbar(i, t)
    }

    _hideToolbar(e) {
        this._balloon.remove(e.view), this.stopListening(this._balloon, "change:visibleView")
    }

    _showToolbar(e, t) {
        this._isToolbarVisible(e) ? au(this.editor, t, e.positions) : this._isToolbarInBalloon(e) || (e.initialized || (e.initialized = !0, e.view.fillFromConfig(e.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({
            view: e.view,
            position: hm(this.editor, t, e.positions),
            balloonClassName: e.balloonClassName
        }), this.listenTo(this._balloon, "change:visibleView", () => {
            for (const i of this._toolbarDefinitions.values()) if (this._isToolbarVisible(i)) {
                const n = i.getRelatedElement(this.editor.editing.view.document.selection);
                au(this.editor, n, e.positions)
            }
        }))
    }

    _isToolbarVisible(e) {
        return this._balloon.visibleView === e.view
    }

    _isToolbarInBalloon(e) {
        return this._balloon.hasView(e.view)
    }
}

function au(s, e, t) {
    const i = s.plugins.get("ContextualBalloon"), n = hm(s, e, t);
    i.updatePosition(n)
}

function hm(s, e, t) {
    const i = s.editing.view, n = Be.defaultPositions;
    return {
        target: i.domConverter.mapViewToDom(e),
        positions: t || [n.northArrowSouth, n.northArrowSouthWest, n.northArrowSouthEast, n.southArrowNorth, n.southArrowNorthWest, n.southArrowNorthEast, n.viewportStickyNorth]
    }
}

function bE(s) {
    const e = s.getSelectedElement();
    return !!(e && ie(e))
}

class _E extends H() {
    _referenceCoordinates;
    _options;
    _originalWidth;
    _originalHeight;
    _originalWidthPercents;
    _aspectRatio;

    constructor(e) {
        super(), this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = e, this._referenceCoordinates = null
    }

    get originalWidth() {
        return this._originalWidth
    }

    get originalHeight() {
        return this._originalHeight
    }

    get originalWidthPercents() {
        return this._originalWidthPercents
    }

    get aspectRatio() {
        return this._aspectRatio
    }

    begin(e, t, i) {
        const n = new R(t);
        this.activeHandlePosition = kE(e), this._referenceCoordinates = vE(t, CE(this.activeHandlePosition)), this._originalWidth = n.width, this._originalHeight = n.height, this._aspectRatio = n.width / n.height;
        const o = i.style.width;
        o && o.match(/^\d+(\.\d*)?%$/) ? this._originalWidthPercents = parseFloat(o) : this._originalWidthPercents = XC(i, n)
    }

    update(e) {
        this.proposedWidth = e.width, this.proposedHeight = e.height, this.proposedWidthPercents = e.widthPercents, this.proposedHandleHostWidth = e.handleHostWidth, this.proposedHandleHostHeight = e.handleHostHeight
    }
}

function vE(s, e) {
    const t = new R(s), i = e.split("-"),
        n = {x: i[1] == "right" ? t.right : t.left, y: i[0] == "bottom" ? t.bottom : t.top};
    return n.x += s.ownerDocument.defaultView.scrollX, n.y += s.ownerDocument.defaultView.scrollY, n
}

function yE(s) {
    return `ck-widget__resizer__handle-${s}`
}

function kE(s) {
    const e = ["top-left", "top-right", "bottom-right", "bottom-left"];
    for (const t of e) if (s.classList.contains(yE(t))) return t
}

function CE(s) {
    const e = s.split("-"), t = {top: "bottom", bottom: "top", left: "right", right: "left"};
    return `${t[e[0]]}-${t[e[1]]}`
}

class EE extends T {
    constructor() {
        super();
        const e = this.bindTemplate;
        this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-size-view", e.to("_viewPosition", t => t ? `ck-orientation-${t}` : "")],
                style: {display: e.if("_isVisible", "none", t => !t)}
            },
            children: [{text: e.to("_label")}]
        })
    }

    _bindToState(e, t) {
        this.bind("_isVisible").to(t, "proposedWidth", t, "proposedHeight", (i, n) => i !== null && n !== null), this.bind("_label").to(t, "proposedHandleHostWidth", t, "proposedHandleHostHeight", t, "proposedWidthPercents", (i, n, o) => e.unit === "px" ? `${i}×${n}` : `${o}%`), this.bind("_viewPosition").to(t, "activeHandlePosition", t, "proposedHandleHostWidth", t, "proposedHandleHostHeight", (i, n, o) => n < 50 || o < 50 ? "above-center" : i)
    }

    _dismiss() {
        this.unbind(), this._isVisible = !1
    }
}

class lu extends H() {
    _state;
    _sizeView;
    _options;
    _viewResizerWrapper = null;
    _initialViewWidth;

    constructor(e) {
        super(), this._options = e, this.set("isEnabled", !0), this.set("isSelected", !1), this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (t, i) => t && i), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", t => {
            !this.state.proposedWidth && !this.state.proposedWidthPercents && (this._cleanup(), t.stop())
        }, {priority: "high"})
    }

    get state() {
        return this._state
    }

    show() {
        this._options.editor.editing.view.change(t => {
            t.removeClass("ck-hidden", this._viewResizerWrapper)
        })
    }

    hide() {
        this._options.editor.editing.view.change(t => {
            t.addClass("ck-hidden", this._viewResizerWrapper)
        })
    }

    attach() {
        const e = this, t = this._options.viewElement;
        this._options.editor.editing.view.change(n => {
            const o = n.createUIElement("div", {class: "ck ck-reset_all ck-widget__resizer"}, function (r) {
                const a = this.toDomElement(r);
                return e._appendHandles(a), e._appendSizeUI(a), a
            });
            n.insert(n.createPositionAt(t, "end"), o), n.addClass("ck-widget_with-resizer", t), this._viewResizerWrapper = o, this.isVisible || this.hide()
        }), this.on("change:isVisible", () => {
            this.isVisible ? (this.show(), this.redraw()) : this.hide()
        })
    }

    begin(e) {
        this._state = new _E(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(e, this._getHandleHost(), this._getResizeHost())
    }

    updateSize(e) {
        const t = this._proposeNewSize(e);
        this._options.editor.editing.view.change(c => {
            const u = this._options.unit || "%", d = (u === "%" ? t.widthPercents : t.width) + u;
            c.setStyle("width", d, this._options.viewElement)
        });
        const n = this._getHandleHost(), o = new R(n), r = Math.round(o.width), a = Math.round(o.height), l = new R(n);
        t.width = Math.round(l.width), t.height = Math.round(l.height), this.redraw(o), this.state.update({
            ...t,
            handleHostWidth: r,
            handleHostHeight: a
        })
    }

    commit() {
        const e = this._options.unit || "%",
            t = (e === "%" ? this.state.proposedWidthPercents : this.state.proposedWidth) + e;
        this._options.editor.editing.view.change(() => {
            this._cleanup(), this._options.onCommit(t)
        })
    }

    cancel() {
        this._cleanup()
    }

    destroy() {
        this.cancel()
    }

    redraw(e) {
        const t = this._domResizerWrapper;
        if (!xE(t)) return;
        const i = t.parentElement, n = this._getHandleHost(), o = this._viewResizerWrapper,
            r = [o.getStyle("width"), o.getStyle("height"), o.getStyle("left"), o.getStyle("top")];
        let a;
        if (i.isSameNode(n)) {
            const l = e || new R(n);
            a = [l.width + "px", l.height + "px", void 0, void 0]
        } else a = [n.offsetWidth + "px", n.offsetHeight + "px", n.offsetLeft + "px", n.offsetTop + "px"];
        _e(r, a) !== "same" && this._options.editor.editing.view.change(l => {
            l.setStyle({width: a[0], height: a[1], left: a[2], top: a[3]}, o)
        })
    }

    containsHandle(e) {
        return this._domResizerWrapper.contains(e)
    }

    static isResizeHandle(e) {
        return e.classList.contains("ck-widget__resizer__handle")
    }

    _cleanup() {
        this._sizeView._dismiss(), this._options.editor.editing.view.change(t => {
            t.setStyle("width", this._initialViewWidth, this._options.viewElement)
        })
    }

    _proposeNewSize(e) {
        const t = this.state, i = AE(e), n = this._options.isCentered ? this._options.isCentered(this) : !0, o = {
            x: t._referenceCoordinates.x - (i.x + t.originalWidth),
            y: i.y - t.originalHeight - t._referenceCoordinates.y
        };
        n && t.activeHandlePosition.endsWith("-right") && (o.x = i.x - (t._referenceCoordinates.x + t.originalWidth)), n && (o.x *= 2);
        let r = Math.abs(t.originalWidth + o.x), a = Math.abs(t.originalHeight + o.y);
        return (r / t.aspectRatio > a ? "width" : "height") == "width" ? a = r / t.aspectRatio : r = a * t.aspectRatio, {
            width: Math.round(r),
            height: Math.round(a),
            widthPercents: Math.min(Math.round(t.originalWidthPercents / t.originalWidth * r * 100) / 100, 100)
        }
    }

    _getResizeHost() {
        const e = this._domResizerWrapper.parentElement;
        return this._options.getResizeHost(e)
    }

    _getHandleHost() {
        const e = this._domResizerWrapper.parentElement;
        return this._options.getHandleHost(e)
    }

    get _domResizerWrapper() {
        return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper)
    }

    _appendHandles(e) {
        const t = ["top-left", "top-right", "bottom-right", "bottom-left"];
        for (const i of t) e.appendChild(new Te({
            tag: "div",
            attributes: {class: `ck-widget__resizer__handle ${TE(i)}`}
        }).render())
    }

    _appendSizeUI(e) {
        this._sizeView = new EE, this._sizeView.render(), e.appendChild(this._sizeView.element)
    }
}

function TE(s) {
    return `ck-widget__resizer__handle-${s}`
}

function AE(s) {
    return {x: s.pageX, y: s.pageY}
}

function xE(s) {
    return s && s.ownerDocument && s.ownerDocument.contains(s)
}

class Go extends w {
    _resizers = new Map;
    _observer;
    _redrawSelectedResizerThrottled;

    static get pluginName() {
        return "WidgetResize"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor.editing, t = C.window.document;
        this.set("selectedResizer", null), this.set("_activeResizer", null), e.view.addObserver(to), this._observer = new (xe()), this.listenTo(e.view.document, "mousedown", this._mouseDownListener.bind(this), {priority: "high"}), this._observer.listenTo(t, "mousemove", this._mouseMoveListener.bind(this)), this._observer.listenTo(t, "mouseup", this._mouseUpListener.bind(this)), this._redrawSelectedResizerThrottled = Ni(() => this.redrawSelectedResizer(), 200), this.editor.ui.on("update", this._redrawSelectedResizerThrottled), this.editor.model.document.on("change", () => {
            for (const [n, o] of this._resizers) n.isAttached() || (this._resizers.delete(n), o.destroy())
        }, {priority: "lowest"}), this._observer.listenTo(C.window, "resize", this._redrawSelectedResizerThrottled);
        const i = this.editor.editing.view.document.selection;
        i.on("change", () => {
            const n = i.getSelectedElement(), o = this.getResizerByViewElement(n) || null;
            o ? this.select(o) : this.deselect()
        })
    }

    redrawSelectedResizer() {
        this.selectedResizer && this.selectedResizer.isVisible && this.selectedResizer.redraw()
    }

    destroy() {
        super.destroy(), this._observer.stopListening();
        for (const e of this._resizers.values()) e.destroy();
        this._redrawSelectedResizerThrottled.cancel()
    }

    select(e) {
        this.deselect(), this.selectedResizer = e, this.selectedResizer.isSelected = !0
    }

    deselect() {
        this.selectedResizer && (this.selectedResizer.isSelected = !1), this.selectedResizer = null
    }

    attachTo(e) {
        const t = new lu(e), i = this.editor.plugins;
        if (t.attach(), i.has("WidgetToolbarRepository")) {
            const r = i.get("WidgetToolbarRepository");
            t.on("begin", () => {
                r.forceDisabled("resize")
            }, {priority: "lowest"}), t.on("cancel", () => {
                r.clearForceDisabled("resize")
            }, {priority: "highest"}), t.on("commit", () => {
                r.clearForceDisabled("resize")
            }, {priority: "highest"})
        }
        this._resizers.set(e.viewElement, t);
        const o = this.editor.editing.view.document.selection.getSelectedElement();
        return this.getResizerByViewElement(o) == t && this.select(t), t
    }

    getResizerByViewElement(e) {
        return this._resizers.get(e)
    }

    _getResizerByHandle(e) {
        for (const t of this._resizers.values()) if (t.containsHandle(e)) return t
    }

    _mouseDownListener(e, t) {
        const i = t.domTarget;
        lu.isResizeHandle(i) && (this._activeResizer = this._getResizerByHandle(i) || null, this._activeResizer && (this._activeResizer.begin(i), e.stop(), t.preventDefault()))
    }

    _mouseMoveListener(e, t) {
        this._activeResizer && this._activeResizer.updateSize(t)
    }

    _mouseUpListener() {
        this._activeResizer && (this._activeResizer.commit(), this._activeResizer = null)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class Fn extends Pt {
    domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"];

    constructor(e) {
        super(e);
        const t = this.document;
        this.listenTo(t, "paste", i("clipboardInput"), {priority: "low"}), this.listenTo(t, "drop", i("clipboardInput"), {priority: "low"}), this.listenTo(t, "dragover", i("dragging"), {priority: "low"});

        function i(n) {
            return (o, r) => {
                r.preventDefault();
                const a = r.dropRange ? [r.dropRange] : null, l = new xt(t, n);
                t.fire(l, {
                    dataTransfer: r.dataTransfer,
                    method: o.name,
                    targetRanges: a,
                    target: r.target,
                    domEvent: r.domEvent
                }), l.stop.called && r.stopPropagation()
            }
        }
    }

    onDomEvent(e) {
        const t = "clipboardData" in e ? e.clipboardData : e.dataTransfer, i = e.type == "drop" || e.type == "paste",
            n = {dataTransfer: new Sh(t, {cacheFiles: i})};
        if (e.type == "drop" || e.type == "dragover") {
            const o = oh(e);
            n.dropRange = o && this.view.domConverter.domRangeToView(o)
        }
        this.fire(e.type, e, n)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function IE(s) {
    return s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;"), (s.includes("</p><p>") || s.includes("<br>")) && (s = `<p>${s}</p>`), s
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function SE(s) {
    return s.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e, t) => t.length == 1 ? " " : t).replace(/<!--[\s\S]*?-->/g, "")
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const cu = ["figcaption", "li"], uu = ["ol", "ul"];

function fm(s, e) {
    if (e.is("$text") || e.is("$textProxy")) return e.data;
    if (e.is("element", "img") && e.hasAttribute("alt")) return e.getAttribute("alt");
    if (e.is("element", "br")) return `
`;
    let t = "", i = null;
    for (const n of e.getChildren()) t += PE(n, i) + fm(s, n), i = n;
    if (e.is("rawElement")) {
        const n = document.createElement("div");
        e.render(n, s), t += mm(n)
    }
    return t
}

function mm(s) {
    let e = "";
    if (s.nodeType === Node.TEXT_NODE) return s.textContent;
    if (s.tagName === "BR") return `
`;
    for (const t of s.childNodes) e += mm(t);
    return e
}

function PE(s, e) {
    return e ? s.is("element", "li") && !s.isEmpty && s.getChild(0).is("containerElement") || uu.includes(s.name) && uu.includes(e.name) ? `

` : !s.is("containerElement") && !e.is("containerElement") ? "" : cu.includes(s.name) || cu.includes(e.name) ? `
` : s.is("element") && s.getCustomProperty("dataPipeline:transparentRendering") || e.is("element") && e.getCustomProperty("dataPipeline:transparentRendering") ? "" : `

` : ""
}

class En extends w {
    _markersToCopy = new Map;

    static get pluginName() {
        return "ClipboardMarkersUtils"
    }

    static get isOfficialPlugin() {
        return !0
    }

    _registerMarkerToCopy(e, t) {
        this._markersToCopy.set(e, t)
    }

    _copySelectedFragmentWithMarkers(e, t, i = n => n.model.getSelectedContent(n.model.document.selection)) {
        return this.editor.model.change(n => {
            const o = n.model.document.selection;
            n.setSelection(t);
            const r = this._insertFakeMarkersIntoSelection(n, n.model.document.selection, e), a = i(n),
                l = this._removeFakeMarkersInsideElement(n, a);
            for (const [c, u] of Object.entries(r)) {
                l[c] ||= n.createRangeIn(a);
                for (const d of u) n.remove(d)
            }
            a.markers.clear();
            for (const [c, u] of Object.entries(l)) a.markers.set(c, u);
            return n.setSelection(o), a
        })
    }

    _pasteMarkersIntoTransformedElement(e, t) {
        const i = this._getPasteMarkersFromRangeMap(e);
        return this.editor.model.change(n => {
            const o = this._insertFakeMarkersElements(n, i), r = t(n), a = this._removeFakeMarkersInsideElement(n, r);
            for (const l of Object.values(o).flat()) n.remove(l);
            for (const [l, c] of Object.entries(a)) n.model.markers.has(l) || n.addMarker(l, {
                usingOperation: !0,
                affectsData: !0,
                range: c
            });
            return r
        })
    }

    _pasteFragmentWithMarkers(e) {
        const t = this._getPasteMarkersFromRangeMap(e.markers);
        e.markers.clear();
        for (const i of t) e.markers.set(i.name, i.range);
        return this.editor.model.insertContent(e)
    }

    _forceMarkersCopy(e, t, i = {allowedActions: "all", copyPartiallySelected: !0, duplicateOnPaste: !0}) {
        const n = this._markersToCopy.get(e);
        this._markersToCopy.set(e, i), t(), n ? this._markersToCopy.set(e, n) : this._markersToCopy.delete(e)
    }

    _isMarkerCopyable(e, t) {
        const i = this._getMarkerClipboardConfig(e);
        if (!i) return !1;
        if (!t) return !0;
        const {allowedActions: n} = i;
        return n === "all" || n.includes(t)
    }

    _hasMarkerConfiguration(e) {
        return !!this._getMarkerClipboardConfig(e)
    }

    _getMarkerClipboardConfig(e) {
        const [t] = e.split(":");
        return this._markersToCopy.get(t) || null
    }

    _insertFakeMarkersIntoSelection(e, t, i) {
        const n = this._getCopyableMarkersFromSelection(e, t, i);
        return this._insertFakeMarkersElements(e, n)
    }

    _getCopyableMarkersFromSelection(e, t, i) {
        const n = Array.from(t.getRanges()),
            o = new Set(n.flatMap(a => Array.from(e.model.markers.getMarkersIntersectingRange(a)))), r = a => {
                if (!this._isMarkerCopyable(a.name, i)) return !1;
                const {copyPartiallySelected: c} = this._getMarkerClipboardConfig(a.name);
                if (!c) {
                    const u = a.getRange();
                    return n.some(d => d.containsRange(u, !0))
                }
                return !0
            };
        return Array.from(o).filter(r).map(a => ({
            name: i === "dragstart" ? this._getUniqueMarkerName(a.name) : a.name,
            range: a.getRange()
        }))
    }

    _getPasteMarkersFromRangeMap(e, t = null) {
        const {model: i} = this.editor;
        return (e instanceof Map ? Array.from(e.entries()) : Object.entries(e)).flatMap(([o, r]) => {
            if (!this._hasMarkerConfiguration(o)) return [{name: o, range: r}];
            if (this._isMarkerCopyable(o, t)) {
                const a = this._getMarkerClipboardConfig(o),
                    l = i.markers.has(o) && i.markers.get(o).getRange().root.rootName === "$graveyard";
                return (a.duplicateOnPaste || l) && (o = this._getUniqueMarkerName(o)), [{name: o, range: r}]
            }
            return []
        })
    }

    _insertFakeMarkersElements(e, t) {
        const i = {}, n = t.flatMap(o => {
            const {start: r, end: a} = o.range;
            return [{position: r, marker: o, type: "start"}, {position: a, marker: o, type: "end"}]
        }).sort(({position: o}, {position: r}) => o.isBefore(r) ? 1 : -1);
        for (const {position: o, marker: r, type: a} of n) {
            const l = e.createElement("$marker", {"data-name": r.name, "data-type": a});
            i[r.name] || (i[r.name] = []), i[r.name].push(l), e.insert(l, o)
        }
        return i
    }

    _removeFakeMarkersInsideElement(e, t) {
        const n = this._getAllFakeMarkersFromElement(e, t).reduce((o, r) => {
            const a = r.markerElement && e.createPositionBefore(r.markerElement);
            let l = o[r.name], c = !1;
            return l?.start && l?.end && (this._getMarkerClipboardConfig(r.name).duplicateOnPaste ? o[this._getUniqueMarkerName(r.name)] = o[r.name] : c = !0, l = null), c || (o[r.name] = {
                ...l,
                [r.type]: a
            }), r.markerElement && e.remove(r.markerElement), o
        }, {});
        return Xg(n, o => new b(o.start || e.createPositionFromPath(t, [0]), o.end || e.createPositionAt(t, "end")))
    }

    _getAllFakeMarkersFromElement(e, t) {
        const i = Array.from(e.createRangeIn(t)).flatMap(({item: r}) => {
            if (!r.is("element", "$marker")) return [];
            const a = r.getAttribute("data-name"), l = r.getAttribute("data-type");
            return [{markerElement: r, name: a, type: l}]
        }), n = [], o = [];
        for (const r of i) r.type === "end" && (i.some(l => l.name === r.name && l.type === "start") || n.push({
            markerElement: null,
            name: r.name,
            type: "start"
        })), r.type === "start" && (i.some(l => l.name === r.name && l.type === "end") || o.unshift({
            markerElement: null,
            name: r.name,
            type: "end"
        }));
        return [...n, ...i, ...o]
    }

    _getUniqueMarkerName(e) {
        const t = e.split(":"), i = pe().substring(1, 6);
        return t.length === 3 ? `${t.slice(0, 2).join(":")}:${i}` : `${t.join(":")}:${i}`
    }
}

class $e extends w {
    static get pluginName() {
        return "ClipboardPipeline"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [En]
    }

    init() {
        this.editor.editing.view.addObserver(Fn), this._setupPasteDrop(), this._setupCopyCut()
    }

    _fireOutputTransformationEvent(e, t, i) {
        const n = this.editor.plugins.get("ClipboardMarkersUtils");
        this.editor.model.enqueueChange({isUndoable: i === "cut"}, () => {
            const o = n._copySelectedFragmentWithMarkers(i, t);
            this.fire("outputTransformation", {dataTransfer: e, content: o, method: i})
        })
    }

    _setupPasteDrop() {
        const e = this.editor, t = e.model, i = e.editing.view, n = i.document,
            o = this.editor.plugins.get("ClipboardMarkersUtils");
        this.listenTo(n, "clipboardInput", (r, a) => {
            a.method == "paste" && !e.model.canEditAt(e.model.document.selection) && r.stop()
        }, {priority: "highest"}), this.listenTo(n, "clipboardInput", (r, a) => {
            const l = a.dataTransfer;
            let c;
            if (a.content) c = a.content; else {
                let h = "";
                l.getData("text/html") ? h = SE(l.getData("text/html")) : l.getData("text/plain") && (h = IE(l.getData("text/plain"))), c = this.editor.data.htmlProcessor.toView(h)
            }
            const u = new xt(this, "inputTransformation"), d = l.getData("application/ckeditor5-editor-id") || null;
            this.fire(u, {
                content: c,
                dataTransfer: l,
                sourceEditorId: d,
                targetRanges: a.targetRanges,
                method: a.method
            }), u.stop.called && r.stop(), i.scrollToTheSelection()
        }, {priority: "low"}), this.listenTo(this, "inputTransformation", (r, a) => {
            if (a.content.isEmpty) return;
            const c = this.editor.data.toModel(a.content, "$clipboardHolder");
            c.childCount != 0 && (r.stop(), t.change(() => {
                this.fire("contentInsertion", {
                    content: c,
                    method: a.method,
                    sourceEditorId: a.sourceEditorId,
                    dataTransfer: a.dataTransfer,
                    targetRanges: a.targetRanges
                })
            }))
        }, {priority: "low"}), this.listenTo(this, "contentInsertion", (r, a) => {
            a.resultRange = o._pasteFragmentWithMarkers(a.content)
        }, {priority: "low"})
    }

    _setupCopyCut() {
        const e = this.editor, t = e.model.document, n = e.editing.view.document, o = (r, a) => {
            const l = a.dataTransfer;
            a.preventDefault(), this._fireOutputTransformationEvent(l, t.selection, r.name)
        };
        this.listenTo(n, "copy", o, {priority: "low"}), this.listenTo(n, "cut", (r, a) => {
            e.model.canEditAt(e.model.document.selection) ? o(r, a) : a.preventDefault()
        }, {priority: "low"}), this.listenTo(this, "outputTransformation", (r, a) => {
            const l = e.data.toView(a.content, {isClipboardPipeline: !0});
            n.fire("clipboardOutput", {dataTransfer: a.dataTransfer, content: l, method: a.method})
        }, {priority: "low"}), this.listenTo(n, "clipboardOutput", (r, a) => {
            a.content.isEmpty || (a.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(a.content)), a.dataTransfer.setData("text/plain", fm(e.data.htmlProcessor.domConverter, a.content)), a.dataTransfer.setData("application/ckeditor5-editor-id", this.editor.id)), a.method == "cut" && e.model.deleteContent(t.selection)
        }, {priority: "low"})
    }
}

const Ko = Hn("px");

class RE extends T {
    constructor() {
        super();
        const e = this.bindTemplate;
        this.set({isVisible: !1, left: null, top: null, width: null}), this.setTemplate({
            tag: "div",
            attributes: {
                class: ["ck", "ck-clipboard-drop-target-line", e.if("isVisible", "ck-hidden", t => !t)],
                style: {left: e.to("left", t => Ko(t)), top: e.to("top", t => Ko(t)), width: e.to("width", t => Ko(t))}
            }
        })
    }
}

class cs extends w {
    removeDropMarkerDelayed = Xr(() => this.removeDropMarker(), 40);
    _updateDropMarkerThrottled = Ni(e => this._updateDropMarker(e), 40);
    _reconvertMarkerThrottled = Ni(() => {
        this.editor.model.markers.has("drop-target") && this.editor.editing.reconvertMarker("drop-target")
    }, 0);
    _dropTargetLineView = new RE;
    _domEmitter = new (xe());
    _scrollables = new Map;

    static get pluginName() {
        return "DragDropTarget"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        this._setupDropMarker()
    }

    destroy() {
        this._domEmitter.stopListening();
        for (const {resizeObserver: e} of this._scrollables.values()) e.destroy();
        return this._updateDropMarkerThrottled.cancel(), this.removeDropMarkerDelayed.cancel(), this._reconvertMarkerThrottled.cancel(), super.destroy()
    }

    updateDropMarker(e, t, i, n, o, r) {
        this.removeDropMarkerDelayed.cancel();
        const a = du(this.editor, e, t, i, n, o, r);/* istanbul ignore next -- @preserve */
        if (a) {
            if (r && r.containsRange(a)) return this.removeDropMarker();
            this._updateDropMarkerThrottled(a)
        }
    }

    getFinalDropRange(e, t, i, n, o, r) {
        const a = du(this.editor, e, t, i, n, o, r);
        return this.removeDropMarker(), a
    }

    removeDropMarker() {
        const e = this.editor.model;
        this.removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), this._dropTargetLineView.isVisible = !1, e.markers.has("drop-target") && e.change(t => {
            t.removeMarker("drop-target")
        })
    }

    _setupDropMarker() {
        const e = this.editor;
        e.ui.view.body.add(this._dropTargetLineView), e.conversion.for("editingDowncast").markerToHighlight({
            model: "drop-target",
            view: {classes: ["ck-clipboard-drop-target-range"]}
        }), e.conversion.for("editingDowncast").markerToElement({
            model: "drop-target", view: (t, {writer: i}) => {
                if (e.model.schema.checkChild(t.markerRange.start, "$text")) return this._dropTargetLineView.isVisible = !1, this._createDropTargetPosition(i);
                t.markerRange.isCollapsed ? this._updateDropTargetLine(t.markerRange) : this._dropTargetLineView.isVisible = !1
            }
        })
    }

    _updateDropMarker(e) {
        const t = this.editor, i = t.model.markers;
        t.model.change(n => {
            i.has("drop-target") ? i.get("drop-target").getRange().isEqual(e) || n.updateMarker("drop-target", {range: e}) : n.addMarker("drop-target", {
                range: e,
                usingOperation: !1,
                affectsData: !1
            })
        })
    }

    _createDropTargetPosition(e) {
        return e.createUIElement("span", {class: "ck ck-clipboard-drop-target-position"}, function (t) {
            const i = this.toDomElement(t);
            return i.append("⁠", t.createElement("span"), "⁠"), i
        })
    }

    _updateDropTargetLine(e) {
        const t = this.editor.editing, i = e.start.nodeBefore, n = e.start.nodeAfter, o = e.start.parent,
            r = i ? t.mapper.toViewElement(i) : null, a = r ? t.view.domConverter.mapViewToDom(r) : null,
            l = n ? t.mapper.toViewElement(n) : null, c = l ? t.view.domConverter.mapViewToDom(l) : null,
            u = t.mapper.toViewElement(o);
        if (!u) return;
        const d = t.view.domConverter.mapViewToDom(u), h = this._getScrollableRect(u), {
                scrollX: f,
                scrollY: m
            } = C.window, g = a ? new R(a) : null, _ = c ? new R(c) : null, v = new R(d).excludeScrollbarsAndBorders(),
            E = g ? g.bottom : v.top, V = _ ? _.top : v.bottom, N = C.window.getComputedStyle(d),
            Z = E <= V ? (E + V) / 2 : V;
        if (h.top < Z && Z < h.bottom) {
            const A = v.left + parseFloat(N.paddingLeft), F = v.right - parseFloat(N.paddingRight),
                S = Math.max(A + f, h.left), P = Math.min(F + f, h.right);
            this._dropTargetLineView.set({isVisible: !0, left: S, top: Z + m, width: P - S})
        } else this._dropTargetLineView.isVisible = !1
    }

    _getScrollableRect(e) {
        const t = e.root.rootName;
        let i;
        if (this._scrollables.has(t)) i = this._scrollables.get(t).domElement; else {
            const n = this.editor.editing.view.domConverter.mapViewToDom(e);
            i = OE(n), this._domEmitter.listenTo(i, "scroll", this._reconvertMarkerThrottled, {usePassive: !0});
            const o = new Q(i, this._reconvertMarkerThrottled);
            this._scrollables.set(t, {domElement: i, resizeObserver: o})
        }
        return new R(i).excludeScrollbarsAndBorders()
    }
}

function du(s, e, t, i, n, o, r) {
    const a = s.model, l = s.editing.mapper;
    let u = hu(s, e);
    for (; u;) {
        if (!o) {
            if (a.schema.checkChild(u, "$text")) {
                if (t) {
                    const d = t[0].start, h = l.toModelPosition(d);
                    if (!r || Array.from(r.getItems({shallow: !0})).every(m => a.schema.checkChild(h, m))) {
                        if (a.schema.checkChild(h, "$text")) return a.createRange(h);
                        if (d) return us(s, hu(s, d.parent), i, n)
                    }
                }
            } else if (a.schema.isInline(u)) return us(s, u, i, n)
        }
        if (a.schema.isBlock(u)) return us(s, u, i, n);
        if (a.schema.checkChild(u, "$block")) {
            const d = Array.from(u.getChildren()).filter(m => m.is("element") && !VE(s, m));
            let h = 0, f = d.length;
            if (f == 0) return a.createRange(a.createPositionAt(u, "end"));
            for (; h < f - 1;) {
                const m = Math.floor((h + f) / 2);
                gm(s, d[m], i, n) == "before" ? f = m : h = m
            }
            return us(s, d[h], i, n)
        }
        u = u.parent
    }
    return null
}

function VE(s, e) {
    const t = s.editing.mapper, i = s.editing.view.domConverter, n = t.toViewElement(e);
    if (!n) return !0;
    const o = i.mapViewToDom(n);
    return C.window.getComputedStyle(o).float != "none"
}

function us(s, e, t, i) {
    const n = s.model;
    return n.createRange(n.createPositionAt(e, gm(s, e, t, i)))
}

function gm(s, e, t, i) {
    const n = s.editing.mapper, o = s.editing.view.domConverter, r = n.toViewElement(e), a = o.mapViewToDom(r),
        l = new R(a);
    return s.model.schema.isInline(e) ? t < (l.left + l.right) / 2 ? "before" : "after" : i < (l.top + l.bottom) / 2 ? "before" : "after"
}

function hu(s, e) {
    const t = s.editing.mapper, i = s.editing.view, n = t.toModelElement(e);
    if (n) return n;
    const o = i.createPositionBefore(e), r = t.findMappedViewAncestor(o);
    return t.toModelElement(r)
}

function OE(s) {
    let e = s;
    do {
        e = e.parentElement;
        const t = C.window.getComputedStyle(e).overflowY;
        if (t == "auto" || t == "scroll") break
    } while (e.tagName != "BODY");
    return e
}

class ME extends w {
    _isBlockDragging = !1;
    _domEmitter = new (xe());

    static get pluginName() {
        return "DragDropBlockToolbar"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        if (this.listenTo(e, "change:isReadOnly", (t, i, n) => {
            n ? (this.forceDisabled("readOnlyMode"), this._isBlockDragging = !1) : this.clearForceDisabled("readOnlyMode")
        }), x.isAndroid && this.forceDisabled("noAndroidSupport"), e.plugins.has("BlockToolbar")) {
            const i = e.plugins.get("BlockToolbar").buttonView.element;
            this._domEmitter.listenTo(i, "dragstart", (n, o) => this._handleBlockDragStart(o)), this._domEmitter.listenTo(C.document, "dragover", (n, o) => this._handleBlockDragging(o)), this._domEmitter.listenTo(C.document, "drop", (n, o) => this._handleBlockDragging(o)), this._domEmitter.listenTo(C.document, "dragend", () => this._handleBlockDragEnd(), {useCapture: !0}), this.isEnabled && i.setAttribute("draggable", "true"), this.on("change:isEnabled", (n, o, r) => {
                i.setAttribute("draggable", r ? "true" : "false")
            })
        }
    }

    destroy() {
        return this._domEmitter.stopListening(), super.destroy()
    }

    _handleBlockDragStart(e) {
        if (!this.isEnabled) return;
        const t = this.editor.model, i = t.document.selection, n = this.editor.editing.view,
            o = Array.from(i.getSelectedBlocks()),
            r = t.createRange(t.createPositionBefore(o[0]), t.createPositionAfter(o[o.length - 1]));
        t.change(a => a.setSelection(r)), this._isBlockDragging = !0, n.focus(), n.getObserver(Fn).onDomEvent(e)
    }

    _handleBlockDragging(e) {
        if (!this.isEnabled || !this._isBlockDragging) return;
        const t = e.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100), i = e.clientY,
            n = document.elementFromPoint(t, i), o = this.editor.editing.view;
        !n || !n.closest(".ck-editor__editable") || o.getObserver(Fn).onDomEvent({
            ...e,
            type: e.type,
            dataTransfer: e.dataTransfer,
            target: n,
            clientX: t,
            clientY: i,
            preventDefault: () => e.preventDefault(),
            stopPropagation: () => e.stopPropagation()
        })
    }

    _handleBlockDragEnd() {
        this._isBlockDragging = !1
    }
}

class BE extends w {
    _draggedRange;
    _draggingUid;
    _draggableElement;
    _clearDraggableAttributesDelayed = Xr(() => this._clearDraggableAttributes(), 40);
    _blockMode = !1;
    _domEmitter = new (xe());
    _previewContainer;

    static get pluginName() {
        return "DragDrop"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [$e, di, cs, ME]
    }

    init() {
        const e = this.editor, t = e.editing.view;
        this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, t.addObserver(Fn), t.addObserver(to), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDraggableAttributeHandling(), this.listenTo(e, "change:isReadOnly", (i, n, o) => {
            o ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode")
        }), this.on("change:isEnabled", (i, n, o) => {
            o || this._finalizeDragging(!1)
        }), x.isAndroid && this.forceDisabled("noAndroidSupport")
    }

    destroy() {
        return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._previewContainer && this._previewContainer.remove(), this._domEmitter.stopListening(), this._clearDraggableAttributesDelayed.cancel(), super.destroy()
    }

    _setupDragging() {
        const e = this.editor, t = e.model, i = e.editing.view, n = i.document, o = e.plugins.get(cs);
        this.listenTo(n, "dragstart", (r, a) => {
            if (a.target?.is("editableElement")) {
                a.preventDefault();
                return
            }
            if (this._prepareDraggedRange(a.target), !this._draggedRange) {
                a.preventDefault();
                return
            }
            this._draggingUid = pe(), a.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", a.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
            const l = t.createSelection(this._draggedRange.toRange());
            this.editor.plugins.get("ClipboardPipeline")._fireOutputTransformationEvent(a.dataTransfer, l, "dragstart");
            const {dataTransfer: u, domTarget: d, domEvent: h} = a, {clientX: f} = h;
            this._updatePreview({
                dataTransfer: u,
                domTarget: d,
                clientX: f
            }), a.stopPropagation(), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "")
        }, {priority: "low"}), this.listenTo(n, "dragend", (r, a) => {
            this._finalizeDragging(!a.dataTransfer.isCanceled && a.dataTransfer.dropEffect == "move")
        }, {priority: "low"}), this._domEmitter.listenTo(C.document, "dragend", () => {
            this._blockMode = !1
        }, {useCapture: !0}), this.listenTo(n, "dragenter", () => {
            this.isEnabled && i.focus()
        }), this.listenTo(n, "dragleave", () => {
            o.removeDropMarkerDelayed()
        }), this.listenTo(n, "dragging", (r, a) => {
            if (!this.isEnabled) {
                a.dataTransfer.dropEffect = "none";
                return
            }
            const {clientX: l, clientY: c} = a.domEvent;
            o.updateDropMarker(a.target, a.targetRanges, l, c, this._blockMode, this._draggedRange), this._draggedRange || (a.dataTransfer.dropEffect = "copy"), x.isGecko || (a.dataTransfer.effectAllowed == "copy" ? a.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(a.dataTransfer.effectAllowed) && (a.dataTransfer.dropEffect = "move")), r.stop()
        }, {priority: "low"})
    }

    _setupClipboardInputIntegration() {
        const e = this.editor, i = e.editing.view.document, n = e.plugins.get(cs);
        this.listenTo(i, "clipboardInput", (o, r) => {
            if (r.method != "drop") return;
            const {clientX: a, clientY: l} = r.domEvent,
                c = n.getFinalDropRange(r.target, r.targetRanges, a, l, this._blockMode, this._draggedRange);
            if (!c) {
                this._finalizeDragging(!1), o.stop();
                return
            }
            if (this._draggedRange && this._draggingUid != r.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = ""), fu(r.dataTransfer) == "move" && this._draggedRange && this._draggedRange.containsRange(c, !0)) {
                this._finalizeDragging(!1), o.stop();
                return
            }
            r.targetRanges = [e.editing.mapper.toViewRange(c)]
        }, {priority: "high"})
    }

    _setupContentInsertionIntegration() {
        const e = this.editor.plugins.get($e);
        e.on("contentInsertion", (t, i) => {
            if (!this.isEnabled || i.method !== "drop") return;
            const n = i.targetRanges.map(o => this.editor.editing.mapper.toModelRange(o));
            this.editor.model.change(o => o.setSelection(n))
        }, {priority: "high"}), e.on("contentInsertion", (t, i) => {
            if (!this.isEnabled || i.method !== "drop") return;
            const n = fu(i.dataTransfer) == "move", o = !i.resultRange || !i.resultRange.isCollapsed;
            this._finalizeDragging(o && n)
        }, {priority: "lowest"})
    }

    _setupDraggableAttributeHandling() {
        const e = this.editor, t = e.editing.view, i = t.document;
        this.listenTo(i, "mousedown", (n, o) => {
            if (x.isAndroid || !o) return;
            this._clearDraggableAttributesDelayed.cancel();
            let r = mu(o.target);
            if (x.isBlink && !e.isReadOnly && !r && !i.selection.isCollapsed) {
                const a = i.selection.getSelectedElement();
                (!a || !ie(a)) && (r = i.selection.editableElement)
            }
            r && (t.change(a => {
                a.setAttribute("draggable", "true", r)
            }), this._draggableElement = e.editing.mapper.toModelElement(r))
        }), this.listenTo(i, "mouseup", () => {
            x.isAndroid || this._clearDraggableAttributesDelayed()
        })
    }

    _clearDraggableAttributes() {
        const e = this.editor.editing;
        e.view.change(t => {
            this._draggableElement && this._draggableElement.root.rootName != "$graveyard" && t.removeAttribute("draggable", e.mapper.toViewElement(this._draggableElement)), this._draggableElement = null
        })
    }

    _finalizeDragging(e) {
        const t = this.editor, i = t.model;
        t.plugins.get(cs).removeDropMarker(), this._clearDraggableAttributes(), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop"), this._draggingUid = "", this._previewContainer && (this._previewContainer.remove(), this._previewContainer = void 0), this._draggedRange && (e && this.isEnabled && i.change(o => {
            const r = i.createSelection(this._draggedRange);
            i.deleteContent(r, {doNotAutoparagraph: !0});
            const a = r.getFirstPosition().parent;
            a.isEmpty && !i.schema.checkChild(a, "$text") && i.schema.checkChild(a, "paragraph") && o.insertElement("paragraph", a, 0)
        }), this._draggedRange.detach(), this._draggedRange = null)
    }

    _prepareDraggedRange(e) {
        const t = this.editor, i = t.model, n = i.document.selection, o = e ? mu(e) : null;
        if (o) {
            const c = t.editing.mapper.toModelElement(o);
            this._draggedRange = Ce.fromRange(i.createRangeOn(c)), this._blockMode = i.schema.isBlock(c), t.plugins.has("WidgetToolbarRepository") && t.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
            return
        }
        if (n.isCollapsed && !n.getFirstPosition().parent.isEmpty) return;
        const r = Array.from(n.getSelectedBlocks()), a = n.getFirstRange();
        if (r.length == 0) {
            this._draggedRange = Ce.fromRange(a);
            return
        }
        const l = pm(i, r);
        if (r.length > 1) this._draggedRange = Ce.fromRange(l), this._blockMode = !0; else if (r.length == 1) {
            const c = a.start.isTouching(l.start) && a.end.isTouching(l.end);
            this._draggedRange = Ce.fromRange(c ? l : a), this._blockMode = c
        }
        i.change(c => c.setSelection(this._draggedRange.toRange()))
    }

    _updatePreview({dataTransfer: e, domTarget: t, clientX: i}) {
        const n = this.editor.editing.view, o = n.document.selection.editableElement,
            r = n.domConverter.mapViewToDom(o), a = C.window.getComputedStyle(r);
        this._previewContainer ? this._previewContainer.firstElementChild && this._previewContainer.removeChild(this._previewContainer.firstElementChild) : (this._previewContainer = Oe(C.document, "div", {style: "position: fixed; left: -999999px;"}), C.document.body.appendChild(this._previewContainer));
        const l = new R(r);
        if (r.contains(t)) return;
        const c = parseFloat(a.paddingLeft), u = Oe(C.document, "div");
        u.className = "ck ck-content", u.style.width = a.width, u.style.paddingLeft = `${l.left - i + c}px`, x.isiOS && (u.style.backgroundColor = "white"), n.domConverter.setContentOf(u, e.getData("text/html")), e.setDragImage(u, 0, 0), this._previewContainer.appendChild(u)
    }
}

function fu(s) {
    return x.isGecko ? s.dropEffect : ["all", "copyMove"].includes(s.effectAllowed) ? "move" : "copy"
}

function mu(s) {
    if (s.is("editableElement")) return null;
    if (s.hasClass("ck-widget__selection-handle")) return s.findAncestor(ie);
    if (ie(s)) return s;
    const e = s.findAncestor(t => ie(t) || t.is("editableElement"));
    return ie(e) ? e : null
}

function pm(s, e) {
    const t = e[0], i = e[e.length - 1], n = t.getCommonAncestor(i), o = s.createPositionBefore(t),
        r = s.createPositionAfter(i);
    if (n && n.is("element") && !s.schema.isLimit(n)) {
        const a = s.createRangeOn(n), l = o.isTouching(a.start), c = r.isTouching(a.end);
        if (l && c) return pm(s, [n])
    }
    return s.createRange(o, r)
}

class FE extends w {
    static get pluginName() {
        return "PastePlainText"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [$e]
    }

    init() {
        const e = this.editor, t = e.model, i = e.editing.view, n = t.document.selection;
        i.addObserver(Fn), e.plugins.get($e).on("contentInsertion", (o, r) => {
            LE(r.content, t) && t.change(a => {
                const l = Array.from(n.getAttributes()).filter(([u]) => t.schema.getAttributeProperties(u).isFormatting);
                n.isCollapsed || t.deleteContent(n, {doNotAutoparagraph: !0}), l.push(...n.getAttributes());
                const c = a.createRangeIn(r.content);
                for (const u of c.getItems()) for (const d of l) t.schema.checkAttribute(u, d[0]) && a.setAttribute(d[0], d[1], u)
            })
        })
    }
}

function LE(s, e) {
    let t = e.createRangeIn(s);
    if (s.childCount == 1) {
        const i = s.getChild(0);
        i.is("element") && e.schema.isBlock(i) && !e.schema.isObject(i) && !e.schema.isLimit(i) && (t = e.createRangeIn(i))
    }
    for (const i of t.getItems()) if (!e.schema.isInline(i) || Array.from(i.getAttributeKeys()).find(o => e.schema.getAttributeProperties(o).isFormatting)) return !1;
    return !0
}

class Ea extends w {
    static get pluginName() {
        return "Clipboard"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [En, $e, BE, FE]
    }

    init() {
        const e = this.editor, t = this.editor.t;
        e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: t("Copy selected content"),
                keystroke: "CTRL+C"
            }, {label: t("Paste content"), keystroke: "CTRL+V"}, {
                label: t("Paste content as plain text"),
                keystroke: "CTRL+SHIFT+V"
            }]
        })
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class DE extends Rk {
    view;
    _toolbarConfig;
    _elementReplacer;

    constructor(e, t) {
        super(e), this.view = t, this._toolbarConfig = Uf(e.config.get("toolbar")), this._elementReplacer = new eh, this.listenTo(e.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this))
    }

    get element() {
        return this.view.element
    }

    init(e) {
        const t = this.editor, i = this.view, n = t.editing.view, o = i.editable, r = n.document.getRoot();
        o.name = r.rootName, i.render();
        const a = o.element;
        this.setEditableElement(o.name, a), i.editable.bind("isFocused").to(this.focusTracker), n.attachDomRoot(a), e && this._elementReplacer.replace(e, this.element), this._initPlaceholder(), this._initToolbar(), i.menuBarView && this.initMenuBar(i.menuBarView), this._initDialogPluginIntegration(), this._initContextualBalloonIntegration(), this.fire("ready")
    }

    destroy() {
        super.destroy();
        const e = this.view, t = this.editor.editing.view;
        this._elementReplacer.restore(), t.getDomRoot(e.editable.name) && t.detachDomRoot(e.editable.name), e.destroy()
    }

    _initToolbar() {
        const e = this.view;
        e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), e.stickyPanel.limiterElement = e.element, e.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({visualTop: t}) => t || 0), e.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(e.toolbar)
    }

    _initPlaceholder() {
        const e = this.editor, t = e.editing.view, i = t.document.getRoot(), n = e.sourceElement;
        let o;
        const r = e.config.get("placeholder");
        r && (o = typeof r == "string" ? r : r[this.view.editable.name]), !o && n && n.tagName.toLowerCase() === "textarea" && (o = n.getAttribute("placeholder")), o && (i.placeholder = o), wh({
            view: t,
            element: i,
            isDirectHost: !1,
            keepOnFocus: !0
        })
    }

    _initContextualBalloonIntegration() {
        if (!this.editor.plugins.has("ContextualBalloon")) return;
        const {stickyPanel: e} = this.view, t = this.editor.plugins.get("ContextualBalloon");
        t.on("getPositionOptions", n => {
            const o = n.return;
            if (!o || !e.isSticky || !e.element) return;
            const r = new R(e.element).height, a = typeof o.target == "function" ? o.target() : o.target,
                l = typeof o.limiter == "function" ? o.limiter() : o.limiter;
            if (a && l && new R(a).height >= new R(l).height - r) return;
            const c = {...o.viewportOffsetConfig}, u = (c.top || 0) + r;
            n.return = {...o, viewportOffsetConfig: {...c, top: u}}
        }, {priority: "low"});
        const i = () => {
            t.visibleView && t.updatePosition()
        };
        this.listenTo(e, "change:isSticky", i), this.listenTo(this.editor.ui, "change:viewportOffset", i)
    }

    _handleScrollToTheSelectionWithStickyPanel(e, t, i) {
        const n = this.view.stickyPanel;
        if (n.isSticky) {
            const o = new R(n.element).height;
            t.viewportOffset.top += o
        } else {
            const o = () => {
                this.editor.editing.view.scrollToTheSelection(i)
            };
            this.listenTo(n, "change:isSticky", o), setTimeout(() => {
                this.stopListening(n, "change:isSticky", o)
            }, 20)
        }
    }

    _initDialogPluginIntegration() {
        if (!this.editor.plugins.has("Dialog")) return;
        const e = this.view.stickyPanel, t = this.editor.plugins.get("Dialog");
        t.on("show", () => {
            const i = t.view;
            i.on("moveTo", (n, o) => {
                if (!e.isSticky || i.wasMoved || i.isModal) return;
                const r = new R(e.contentPanelElement);
                o[1] < r.bottom + Mn.defaultOffset && (o[1] = r.bottom + Mn.defaultOffset)
            }, {priority: "high"})
        }, {priority: "low"})
    }
}

class NE extends Ok {
    stickyPanel;
    toolbar;
    editable;

    constructor(e, t, i = {}) {
        super(e), this.stickyPanel = new Dk(e), this.toolbar = new oo(e, {shouldGroupWhenFull: i.shouldToolbarGroupWhenFull}), i.useMenuBar && (this.menuBarView = new Uk(e)), this.editable = new Bk(e, t, void 0, {label: i.label})
    }

    render() {
        super.render(), this.menuBarView ? this.stickyPanel.content.addMany([this.menuBarView, this.toolbar]) : this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable)
    }
}

class zE extends _r(Lv) {
    static get editorName() {
        return "ClassicEditor"
    }

    ui;

    constructor(e, t = {}) {
        if (!Cs(e) && t.initialData !== void 0) throw new p("editor-create-initial-data", null);
        super(t), this.config.define("menuBar.isVisible", !1), this.config.get("initialData") === void 0 && this.config.set("initialData", HE(e)), Cs(e) && (this.sourceElement = e), this.model.document.createRoot();
        const i = !this.config.get("toolbar.shouldNotGroupWhenFull"), n = this.config.get("menuBar"),
            o = new NE(this.locale, this.editing.view, {
                shouldToolbarGroupWhenFull: i,
                useMenuBar: n.isVisible,
                label: this.config.get("label")
            });
        this.ui = new DE(this, o), Nv(this)
    }

    destroy() {
        return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy()
    }

    static create(e, t = {}) {
        return new Promise(i => {
            const n = new this(e, t);
            i(n.initPlugins().then(() => n.ui.init(Cs(e) ? e : null)).then(() => n.data.init(n.config.get("initialData"))).then(() => n.fire("ready")).then(() => n))
        })
    }
}

function HE(s) {
    return Cs(s) ? Np(s) : s
}

function Cs(s) {
    return At(s)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class UE extends O {
    constructor(e) {
        super(e), this.affectsData = !1
    }

    execute() {
        const e = this.editor.model, t = e.document.selection;
        let i = e.schema.getLimitElement(t);
        if (t.containsEntireContent(i) || !gu(e.schema, i)) do if (i = i.parent, !i) return; while (!gu(e.schema, i));
        e.change(n => {
            n.setSelection(i, "in")
        })
    }
}

function gu(s, e) {
    return s.isLimit(e) && (s.checkChild(e, "$text") || s.checkChild(e, "paragraph"))
}

const $E = Qr("Ctrl+A");

class WE extends w {
    static get pluginName() {
        return "SelectAllEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.t, n = e.editing.view.document;
        e.commands.add("selectAll", new UE(e)), this.listenTo(n, "keydown", (o, r) => {
            zi(r) === $E && (e.execute("selectAll"), r.preventDefault())
        }), e.accessibility.addKeystrokeInfos({keystrokes: [{label: t("Select all"), keystroke: "CTRL+A"}]})
    }
}

class qE extends w {
    static get pluginName() {
        return "SelectAllUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        e.ui.componentFactory.add("selectAll", () => {
            const t = this._createButton(I);
            return t.set({tooltip: !0}), t
        }), e.ui.componentFactory.add("menuBar:selectAll", () => this._createButton(K))
    }

    _createButton(e) {
        const t = this.editor, i = t.locale, n = t.commands.get("selectAll"), o = new e(t.locale), r = i.t;
        return o.set({
            label: r("Select all"),
            icon: A1,
            keystroke: "Ctrl+A"
        }), o.bind("isEnabled").to(n, "isEnabled"), this.listenTo(o, "execute", () => {
            t.execute("selectAll"), t.editing.view.focus()
        }), o
    }
}

class jE extends w {
    static get requires() {
        return [WE, qE]
    }

    static get pluginName() {
        return "SelectAll"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class wm extends O {
    _stack = [];
    _createdBatches = new WeakSet;

    constructor(e) {
        super(e), this.refresh(), this._isEnabledBasedOnSelection = !1, this.listenTo(e.data, "set", (t, i) => {
            i[1] = {...i[1]};
            const n = i[1];
            n.batchType || (n.batchType = {isUndoable: !1})
        }, {priority: "high"}), this.listenTo(e.data, "set", (t, i) => {
            i[1].batchType.isUndoable || this.clearStack()
        })
    }

    refresh() {
        this.isEnabled = this._stack.length > 0
    }

    get createdBatches() {
        return this._createdBatches
    }

    addBatch(e) {
        const t = this.editor.model.document.selection,
            i = {ranges: t.hasOwnRange ? Array.from(t.getRanges()) : [], isBackward: t.isBackward};
        this._stack.push({batch: e, selection: i}), this.refresh()
    }

    clearStack() {
        this._stack = [], this.refresh()
    }

    _restoreSelection(e, t, i) {
        const n = this.editor.model, o = n.document, r = [], a = e.map(c => c.getTransformedByOperations(i)),
            l = a.flat();
        for (const c of a) {
            const u = c.filter(d => d.root != o.graveyard).filter(d => !KE(d, l));
            u.length && (GE(u), r.push(u[0]))
        }
        r.length && n.change(c => {
            c.setSelection(r, {backward: t})
        })
    }

    _undo(e, t) {
        const i = this.editor.model, n = i.document;
        this._createdBatches.add(t);
        const o = e.operations.slice().filter(r => r.isDocumentOperation);
        o.reverse();
        for (const r of o) {
            const a = r.baseVersion + 1, l = Array.from(n.history.getOperations(a)), u = o0([r.getReversed()], l, {
                useRelations: !0,
                document: this.editor.model.document,
                forceWeakRemove: !0
            }).operationsA;
            for (let d of u) {
                const h = d.affectedSelectable;
                h && !i.canEditAt(h) && (d = new de(d.baseVersion)), t.addOperation(d), i.applyOperation(d), n.history.setOperationAsUndone(r, d)
            }
        }
    }
}

function GE(s) {
    s.sort((e, t) => e.start.isBefore(t.start) ? -1 : 1);
    for (let e = 1; e < s.length; e++) {
        const i = s[e - 1].getJoined(s[e], !0);
        i && (e--, s.splice(e, 2, i))
    }
}

function KE(s, e) {
    return e.some(t => t !== s && t.containsRange(s, !0))
}

class ZE extends wm {
    execute(e = null) {
        const t = e ? this._stack.findIndex(o => o.batch == e) : this._stack.length - 1,
            i = this._stack.splice(t, 1)[0], n = this.editor.model.createBatch({isUndo: !0});
        this.editor.model.enqueueChange(n, () => {
            this._undo(i.batch, n);
            const o = this.editor.model.document.history.getOperations(i.batch.baseVersion);
            this._restoreSelection(i.selection.ranges, i.selection.isBackward, o)
        }), this.fire("revert", i.batch, n), this.refresh()
    }
}

class JE extends wm {
    execute() {
        const e = this._stack.pop(), t = this.editor.model.createBatch({isUndo: !0});
        this.editor.model.enqueueChange(t, () => {
            const n = e.batch.operations[e.batch.operations.length - 1].baseVersion + 1,
                o = this.editor.model.document.history.getOperations(n);
            this._restoreSelection(e.selection.ranges, e.selection.isBackward, o), this._undo(e.batch, t)
        }), this.refresh()
    }
}

class QE extends w {
    _undoCommand;
    _redoCommand;
    _batchRegistry = new WeakSet;

    static get pluginName() {
        return "UndoEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.t;
        this._undoCommand = new ZE(e), this._redoCommand = new JE(e), e.commands.add("undo", this._undoCommand), e.commands.add("redo", this._redoCommand), this.listenTo(e.model, "applyOperation", (i, n) => {
            const o = n[0];
            if (!o.isDocumentOperation) return;
            const r = o.batch, a = this._redoCommand.createdBatches.has(r), l = this._undoCommand.createdBatches.has(r);
            this._batchRegistry.has(r) || (this._batchRegistry.add(r), r.isUndoable && (a ? this._undoCommand.addBatch(r) : l || (this._undoCommand.addBatch(r), this._redoCommand.clearStack())))
        }, {priority: "highest"}), this.listenTo(this._undoCommand, "revert", (i, n, o) => {
            this._redoCommand.addBatch(o)
        }), e.keystrokes.set("CTRL+Z", "undo"), e.keystrokes.set("CTRL+Y", "redo"), e.keystrokes.set("CTRL+SHIFT+Z", "redo"), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: t("Undo"),
                keystroke: "CTRL+Z"
            }, {label: t("Redo"), keystroke: [["CTRL+Y"], ["CTRL+SHIFT+Z"]]}]
        })
    }
}

class YE extends w {
    static get pluginName() {
        return "UndoUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.locale, i = e.t, n = t.uiLanguageDirection == "ltr" ? rc : sc,
            o = t.uiLanguageDirection == "ltr" ? sc : rc;
        this._addButtonsToFactory("undo", i("Undo"), "CTRL+Z", n), this._addButtonsToFactory("redo", i("Redo"), "CTRL+Y", o)
    }

    _addButtonsToFactory(e, t, i, n) {
        const o = this.editor;
        o.ui.componentFactory.add(e, () => {
            const r = this._createButton(I, e, t, i, n);
            return r.set({tooltip: !0}), r
        }), o.ui.componentFactory.add("menuBar:" + e, () => this._createButton(K, e, t, i, n))
    }

    _createButton(e, t, i, n, o) {
        const r = this.editor, a = r.locale, l = r.commands.get(t), c = new e(a);
        return c.set({
            label: i,
            icon: o,
            keystroke: n
        }), c.bind("isEnabled").to(l, "isEnabled"), this.listenTo(c, "execute", () => {
            r.execute(t), r.editing.view.focus()
        }), c
    }
}

class Ta extends w {
    static get requires() {
        return [QE, YE]
    }

    static get pluginName() {
        return "Undo"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class XE extends w {
    static get requires() {
        return [Cy, Ea, Gn, jE, NC, uC, Ta]
    }

    static get pluginName() {
        return "Essentials"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class eT extends T {
    children;
    _findInputView;
    _replaceInputView;
    _findButtonView;
    _findPrevButtonView;
    _findNextButtonView;
    _advancedOptionsCollapsibleView;
    _matchCaseSwitchView;
    _wholeWordsOnlySwitchView;
    _replaceButtonView;
    _replaceAllButtonView;
    _inputsDivView;
    _actionButtonsDivView;
    _focusTracker;
    _keystrokes;
    _focusables;
    focusCycler;

    constructor(e) {
        super(e);
        const t = e.t;
        this.children = this.createCollection(), this.set("matchCount", 0), this.set("highlightOffset", 0), this.set("isDirty", !1), this.set("_areCommandsEnabled", {}), this.set("_resultsCounterText", ""), this.set("_matchCase", !1), this.set("_wholeWordsOnly", !1), this.bind("_searchResultsFound").to(this, "matchCount", this, "isDirty", (i, n) => i > 0 && !n), this._findInputView = this._createInputField(t("Find in text…")), this._findPrevButtonView = this._createButton({
            label: t("Previous result"),
            class: "ck-button-prev",
            icon: Ht,
            keystroke: "Shift+F3",
            tooltip: !0
        }), this._findNextButtonView = this._createButton({
            label: t("Next result"),
            class: "ck-button-next",
            icon: Ht,
            keystroke: "F3",
            tooltip: !0
        }), this._replaceInputView = this._createInputField(t("Replace with…"), "ck-labeled-field-replace"), this._inputsDivView = this._createInputsDiv(), this._matchCaseSwitchView = this._createMatchCaseSwitch(), this._wholeWordsOnlySwitchView = this._createWholeWordsOnlySwitch(), this._advancedOptionsCollapsibleView = this._createAdvancedOptionsCollapsible(), this._replaceAllButtonView = this._createButton({
            label: t("Replace all"),
            class: "ck-button-replaceall",
            withText: !0
        }), this._replaceButtonView = this._createButton({
            label: t("Replace"),
            class: "ck-button-replace",
            withText: !0
        }), this._findButtonView = this._createButton({
            label: t("Find"),
            class: "ck-button-find ck-button-action",
            withText: !0
        }), this._actionButtonsDivView = this._createActionButtonsDiv(), this._focusTracker = new se, this._keystrokes = new ue, this._focusables = new Ie, this.focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this._focusTracker,
            keystrokeHandler: this._keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"}
        }), this.children.addMany([this._inputsDivView, this._advancedOptionsCollapsibleView, this._actionButtonsDivView]), this.setTemplate({
            tag: "form",
            attributes: {class: ["ck", "ck-find-and-replace-form"], tabindex: "-1"},
            children: this.children
        })
    }

    render() {
        super.render(), li({view: this}), this._initFocusCycling(), this._initKeystrokeHandling()
    }

    destroy() {
        super.destroy(), this._focusTracker.destroy(), this._keystrokes.destroy()
    }

    focus(e) {
        e === -1 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst()
    }

    reset() {
        this._findInputView.errorText = null, this.isDirty = !0
    }

    get _textToFind() {
        return this._findInputView.fieldView.element.value
    }

    get _textToReplace() {
        return this._replaceInputView.fieldView.element.value
    }

    _createInputsDiv() {
        const e = this.locale, t = e.t, i = new T(e);
        return this._findInputView.fieldView.on("input", () => {
            this.isDirty = !0
        }), this._findPrevButtonView.delegate("execute").to(this, "findPrevious"), this._findNextButtonView.delegate("execute").to(this, "findNext"), this._findPrevButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", ({findPrevious: n}) => n), this._findNextButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", ({findNext: n}) => n), this._injectFindResultsCounter(), this._replaceInputView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", ({replace: n}, o) => n && o), this._replaceInputView.bind("infoText").to(this._replaceInputView, "isEnabled", this._replaceInputView, "isFocused", (n, o) => n || !o ? "" : t("Tip: Find some text first in order to replace it.")), i.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-find-and-replace-form__inputs"]},
            children: [this._findInputView, this._findPrevButtonView, this._findNextButtonView, this._replaceInputView]
        }), i
    }

    _onFindButtonExecute() {
        if (!this._textToFind) {
            const e = this.t;
            this._findInputView.errorText = e("Text to find must not be empty.");
            return
        }
        this.isDirty = !1, this.fire("findNext", {
            searchText: this._textToFind,
            matchCase: this._matchCase,
            wholeWords: this._wholeWordsOnly
        })
    }

    _injectFindResultsCounter() {
        const e = this.locale, t = e.t, i = this.bindTemplate, n = new T(this.locale);
        this.bind("_resultsCounterText").to(this, "highlightOffset", this, "matchCount", (r, a) => t("%0 of %1", [r, a])), n.setTemplate({
            tag: "span",
            attributes: {class: ["ck", "ck-results-counter", i.if("isDirty", "ck-hidden")]},
            children: [{text: i.to("_resultsCounterText")}]
        });
        const o = () => {
            const r = this._findInputView.fieldView.element;
            if (!r || !ft(r)) return;
            const a = new R(n.element).width, l = e.uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft";
            a ? r.style[l] = `calc( 2 * var(--ck-spacing-standard) + ${a}px )` : r.style[l] = ""
        };
        this.on("change:_resultsCounterText", o, {priority: "low"}), this.on("change:isDirty", o, {priority: "low"}), this._findInputView.template.children[0].children.push(n)
    }

    _createAdvancedOptionsCollapsible() {
        const e = this.locale.t, t = new Ff(this.locale, [this._matchCaseSwitchView, this._wholeWordsOnlySwitchView]);
        return t.set({label: e("Advanced options"), isCollapsed: !0}), t
    }

    _createActionButtonsDiv() {
        const e = new T(this.locale);
        return this._replaceButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", ({replace: t}, i) => t && i), this._replaceAllButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", ({replaceAll: t}, i) => t && i), this._replaceButtonView.on("execute", () => {
            this.fire("replace", {searchText: this._textToFind, replaceText: this._textToReplace})
        }), this._replaceAllButtonView.on("execute", () => {
            this.fire("replaceAll", {searchText: this._textToFind, replaceText: this._textToReplace}), this.focus()
        }), this._findButtonView.on("execute", this._onFindButtonExecute.bind(this)), e.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-find-and-replace-form__actions"]},
            children: [this._replaceAllButtonView, this._replaceButtonView, this._findButtonView]
        }), e
    }

    _createMatchCaseSwitch() {
        const e = this.locale.t, t = new Wi(this.locale);
        return t.set({
            label: e("Match case"),
            withText: !0
        }), t.bind("isOn").to(this, "_matchCase"), t.on("execute", () => {
            this._matchCase = !this._matchCase, this.isDirty = !0
        }), t
    }

    _createWholeWordsOnlySwitch() {
        const e = this.locale.t, t = new Wi(this.locale);
        return t.set({
            label: e("Whole words only"),
            withText: !0
        }), t.bind("isOn").to(this, "_wholeWordsOnly"), t.on("execute", () => {
            this._wholeWordsOnly = !this._wholeWordsOnly, this.isDirty = !0
        }), t
    }

    _initFocusCycling() {
        [this._findInputView, this._findPrevButtonView, this._findNextButtonView, this._replaceInputView, this._advancedOptionsCollapsibleView.buttonView, this._matchCaseSwitchView, this._wholeWordsOnlySwitchView, this._replaceAllButtonView, this._replaceButtonView, this._findButtonView].forEach(t => {
            this._focusables.add(t), this._focusTracker.add(t.element)
        })
    }

    _initKeystrokeHandling() {
        const e = i => i.stopPropagation(), t = i => {
            i.stopPropagation(), i.preventDefault()
        };
        this._keystrokes.listenTo(this.element), this._keystrokes.set("f3", i => {
            t(i), this._findNextButtonView.fire("execute")
        }), this._keystrokes.set("shift+f3", i => {
            t(i), this._findPrevButtonView.fire("execute")
        }), this._keystrokes.set("enter", i => {
            const n = i.target;
            n === this._findInputView.fieldView.element ? (this._areCommandsEnabled.findNext ? this._findNextButtonView.fire("execute") : this._findButtonView.fire("execute"), t(i)) : n === this._replaceInputView.fieldView.element && !this.isDirty && (this._replaceButtonView.fire("execute"), t(i))
        }), this._keystrokes.set("shift+enter", i => {
            i.target === this._findInputView.fieldView.element && (this._areCommandsEnabled.findPrevious ? this._findPrevButtonView.fire("execute") : this._findButtonView.fire("execute"), t(i))
        }), this._keystrokes.set("arrowright", e), this._keystrokes.set("arrowleft", e), this._keystrokes.set("arrowup", e), this._keystrokes.set("arrowdown", e)
    }

    _createButton(e) {
        const t = new I(this.locale);
        return t.set(e), t
    }

    _createInputField(e, t) {
        const i = new Ut(this.locale, ti);
        return i.label = e, i.class = t, i
    }
}

class tT extends w {
    static get requires() {
        return [Me]
    }

    static get pluginName() {
        return "FindAndReplaceUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    formView;

    constructor(e) {
        super(e), e.config.define("findAndReplace.uiType", "dialog"), this.formView = null
    }

    init() {
        const e = this.editor, t = e.config.get("findAndReplace.uiType") === "dropdown", i = e.commands.get("find"),
            n = this.editor.t;
        e.ui.componentFactory.add("findAndReplace", () => {
            let o;
            return t ? (o = this._createDropdown(), o.bind("isEnabled").to(i)) : o = this._createDialogButtonForToolbar(), e.keystrokes.set("Ctrl+F", (r, a) => {
                if (i.isEnabled) {
                    if (o instanceof Bn) {
                        const l = o.buttonView;
                        l.isOn || l.fire("execute")
                    } else o.isOn ? e.plugins.get("Dialog").view.focus() : o.fire("execute");
                    a()
                }
            }), o
        }), t || e.ui.componentFactory.add("menuBar:findAndReplace", () => this._createDialogButtonForMenuBar()), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: n("Find in the document"),
                keystroke: "CTRL+F"
            }]
        })
    }

    _createDropdown() {
        const e = this.editor, t = e.locale.t, i = Ae(e.locale);
        return i.once("change:isOpen", () => {
            this.formView = this._createFormView(), this.formView.children.add(new ci(e.locale, {label: t("Find and replace")}), 0), i.panelView.children.add(this.formView)
        }), i.on("change:isOpen", (n, o, r) => {
            r ? this._setupFormView() : this.fire("searchReseted")
        }, {priority: "low"}), i.buttonView.set({
            icon: Xl,
            label: t("Find and replace"),
            keystroke: "CTRL+F",
            tooltip: !0
        }), i
    }

    _createDialogButtonForToolbar() {
        const e = this.editor, t = this._createButton(I), i = e.plugins.get("Dialog");
        return t.set({tooltip: !0}), t.bind("isOn").to(i, "id", n => n === "findAndReplace"), t.on("execute", () => {
            t.isOn ? i.hide() : this._showDialog()
        }), t
    }

    _createDialogButtonForMenuBar() {
        const e = this._createButton(K), t = this.editor.plugins.get("Dialog"), i = this.editor.plugins.get("Dialog");
        return e.set({
            role: "menuitemcheckbox",
            isToggleable: !0
        }), e.bind("isOn").to(i, "id", n => n === "findAndReplace"), e.on("execute", () => {
            if (t.id === "findAndReplace") {
                t.hide();
                return
            }
            this._showDialog()
        }), e
    }

    _createButton(e) {
        const t = this.editor, i = t.commands.get("find"), n = new e(t.locale), o = t.locale.t;
        return n.bind("isEnabled").to(i), n.set({icon: Xl, label: o("Find and replace"), keystroke: "CTRL+F"}), n
    }

    _showDialog() {
        const e = this.editor, t = e.plugins.get("Dialog"), i = e.locale.t;
        this.formView || (this.formView = this._createFormView()), t.show({
            id: "findAndReplace",
            title: i("Find and replace"),
            content: this.formView,
            position: je.EDITOR_TOP_SIDE,
            onShow: () => {
                this._setupFormView()
            },
            onHide: () => {
                this.fire("searchReseted")
            }
        })
    }

    _createFormView() {
        const e = this.editor, t = new ($i(eT))(e.locale), i = e.commands,
            o = this.editor.plugins.get("FindAndReplaceEditing").state;
        t.bind("highlightOffset").to(o, "highlightedOffset"), t.listenTo(o.results, "change", () => {
            t.matchCount = o.results.length
        });
        const r = i.get("findNext"), a = i.get("findPrevious"), l = i.get("replace"), c = i.get("replaceAll");
        return t.bind("_areCommandsEnabled").to(r, "isEnabled", a, "isEnabled", l, "isEnabled", c, "isEnabled", (u, d, h, f) => ({
            findNext: u,
            findPrevious: d,
            replace: h,
            replaceAll: f
        })), t.delegate("findNext", "findPrevious", "replace", "replaceAll").to(this), t.on("change:isDirty", (u, d, h) => {
            h && this.fire("searchReseted")
        }), t
    }

    _setupFormView() {
        this.formView.disableCssTransitions(), this.formView.reset(), this.formView._findInputView.fieldView.select(), this.formView.enableCssTransitions()
    }
}

class iT extends O {
    _state;

    constructor(e, t) {
        super(e), this.isEnabled = !0, this.affectsData = !1, this._state = t
    }

    execute(e, {matchCase: t, wholeWords: i} = {}) {
        const {editor: n} = this, {model: o} = n, r = n.plugins.get("FindAndReplaceUtils");
        let a, l = "";
        typeof e == "string" ? a = (...d) => ({
            results: r.findByTextCallback(e, {matchCase: t, wholeWords: i})(...d),
            searchText: e
        }) : a = e;
        const c = a;
        a = (...d) => {
            const h = c(...d);
            return h && "searchText" in h && (l = h.searchText), h
        };
        const u = o.document.getRootNames().reduce((d, h) => r.updateFindResultFromRange(o.createRangeIn(o.document.getRoot(h)), o, a, d), null);
        return this._state.clear(o), this._state.results.addMany(u), this._state.highlightedResult = u.get(0), this._state.searchText = l, a && (this._state.lastSearchCallback = a), this._state.matchCase = !!t, this._state.matchWholeWords = !!i, {
            results: u,
            findCallback: a
        }
    }
}

class nT extends H() {
    constructor(e) {
        super(), this.set("results", new ce), this.set("highlightedResult", null), this.set("highlightedOffset", 0), this.set("searchText", ""), this.set("replaceText", ""), this.set("lastSearchCallback", null), this.set("matchCase", !1), this.set("matchWholeWords", !1), this.results.on("change", (t, {
            removed: i,
            index: n
        }) => {
            if (Array.from(i).length) {
                let o = !1;
                if (e.change(r => {
                    for (const a of i) this.highlightedResult === a && (o = !0), e.markers.has(a.marker.name) && r.removeMarker(a.marker)
                }), o) {
                    const r = n >= this.results.length ? 0 : n;
                    this.highlightedResult = this.results.get(r)
                }
            }
        }), this.on("change:highlightedResult", () => {
            this.refreshHighlightOffset(e)
        })
    }

    clear(e) {
        this.searchText = "", e.change(t => {
            if (this.highlightedResult) {
                const i = this.highlightedResult.marker.name.split(":")[1],
                    n = e.markers.get(`findResultHighlighted:${i}`);
                n && t.removeMarker(n)
            }
            [...this.results].forEach(({marker: i}) => {
                t.removeMarker(i)
            })
        }), this.results.clear()
    }

    refreshHighlightOffset(e) {
        const {highlightedResult: t, results: i} = this;
        t ? this.highlightedOffset = bm(e, [...i]).indexOf(t) + 1 : this.highlightedOffset = 0
    }
}

function bm(s, e) {
    const t = {before: -1, same: 0, after: 1, different: 1};
    return s.document.getRootNames().flatMap(i => e.filter(n => n.marker.getStart().root.rootName === i).sort((n, o) => t[n.marker.getStart().compareWith(o.marker.getStart())]))
}

class _m extends O {
    _state;

    constructor(e, t) {
        super(e), this.isEnabled = !0, this._state = t, this._isEnabledBasedOnSelection = !1
    }

    _replace(e, t) {
        const {model: i} = this.editor, n = t.marker.getRange();
        i.canEditAt(n) && i.change(o => {
            if (n.root.rootName === "$graveyard") {
                this._state.results.remove(t);
                return
            }
            let r = {};
            for (const a of n.getItems()) if (a.is("$text") || a.is("$textProxy")) {
                r = a.getAttributes();
                break
            }
            i.insertContent(o.createText(e, r), n), this._state.results.has(t) && this._state.results.remove(t)
        })
    }
}

class sT extends _m {
    execute(e, t) {
        const i = Math.max(this._state.highlightedOffset - 1, 0);
        if (this._replace(e, t), this._state.results.length) {
            const n = bm(this.editor.model, [...this._state.results]);
            this._state.highlightedResult = n[i % n.length]
        }
    }
}

class oT extends _m {
    execute(e, t) {
        const {editor: i} = this, {model: n} = i, o = i.plugins.get("FindAndReplaceUtils"),
            r = t instanceof ce ? t : n.document.getRootNames().reduce((a, l) => o.updateFindResultFromRange(n.createRangeIn(n.document.getRoot(l)), n, o.findByTextCallback(t, this._state), a), null);
        r.length && n.change(() => {
            [...r].forEach(a => {
                this._replace(e, a)
            })
        })
    }
}

class vm extends O {
    _state;

    constructor(e, t) {
        super(e), this.affectsData = !1, this._state = t, this.isEnabled = !1, this.listenTo(this._state.results, "change", () => {
            this.isEnabled = this._state.results.length > 1
        })
    }

    refresh() {
        this.isEnabled = this._state.results.length > 1
    }

    execute() {
        const e = this._state.results, t = e.getIndex(this._state.highlightedResult), i = t + 1 >= e.length ? 0 : t + 1;
        this._state.highlightedResult = this._state.results.get(i)
    }
}

class rT extends vm {
    execute() {
        const t = this._state.results.getIndex(this._state.highlightedResult),
            i = t - 1 < 0 ? this._state.results.length - 1 : t - 1;
        this._state.highlightedResult = this._state.results.get(i)
    }
}

class aT extends w {
    static get pluginName() {
        return "FindAndReplaceUtils"
    }

    static get isOfficialPlugin() {
        return !0
    }

    updateFindResultFromRange(e, t, i, n) {
        const o = n || new ce, r = a => o.find(l => {
            const {marker: c} = l, u = c.getRange(), d = a.getRange();
            return u.isEqual(d)
        });
        return t.change(a => {
            [...e].forEach(({type: l, item: c}) => {
                if (l === "elementStart" && t.schema.checkChild(c, "$text")) {
                    let u = i({item: c, text: this.rangeToText(t.createRangeIn(c))});
                    if (!u) return;
                    "results" in u && (u = u.results), u.forEach(d => {
                        const h = `findResult:${pe()}`, f = a.addMarker(h, {
                            usingOperation: !1,
                            affectsData: !1,
                            range: a.createRange(a.createPositionAt(c, d.start), a.createPositionAt(c, d.end))
                        }), m = lT(o, f);
                        r(f) || o.add({id: h, label: d.label, marker: f}, m)
                    })
                }
            })
        }), o
    }

    rangeToText(e) {
        return Array.from(e.getItems({shallow: !0})).reduce((t, i) => i.is("$text") || i.is("$textProxy") ? t + i.data : `${t}
`, "")
    }

    findByTextCallback(e, t) {
        let i = "gu";
        t.matchCase || (i += "i");
        let n = `(${$d(e)})`;
        if (t.wholeWords) {
            const a = "[^a-zA-ZÀ-ɏḀ-ỿ]";
            new RegExp("^" + a).test(e) || (n = `(^|${a}|_)${n}`), new RegExp(a + "$").test(e) || (n = `${n}(?=_|${a}|$)`)
        }
        const o = new RegExp(n, i);

        function r({text: a}) {
            return [...a.matchAll(o)].map(cT)
        }

        return r
    }
}

function lT(s, e) {
    const t = s.find(({marker: i}) => e.getStart().isBefore(i.getStart()));
    return t ? s.getIndex(t) : s.length
}

function cT(s) {
    const e = s.length - 1;
    let t = s.index;
    return s.length === 3 && (t += s[1].length), {label: s[e], start: t, end: t + s[e].length}
}

const uT = "ck-find-result_selected";

class dT extends w {
    static get requires() {
        return [aT]
    }

    static get pluginName() {
        return "FindAndReplaceEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    state;

    init() {
        this.state = new nT(this.editor.model), this.set("_isSearchActive", !1), this._defineConverters(), this._defineCommands(), this.listenTo(this.state, "change:highlightedResult", (i, n, o, r) => {
            const {model: a} = this.editor;
            a.change(l => {
                if (r) {
                    const c = r.marker.name.split(":")[1], u = a.markers.get(`findResultHighlighted:${c}`);
                    u && l.removeMarker(u)
                }
                if (o) {
                    const c = o.marker.name.split(":")[1];
                    l.addMarker(`findResultHighlighted:${c}`, {
                        usingOperation: !1,
                        affectsData: !1,
                        range: o.marker.getRange()
                    })
                }
            })
        });/* istanbul ignore next -- @preserve */
        const t = it(((i, n, o) => {
            if (o) {
                const r = this.editor.editing.view.domConverter,
                    a = this.editor.editing.mapper.toViewRange(o.marker.getRange());
                dh({target: r.viewRangeToDom(a), viewportOffset: 40})
            }
        }).bind(this), 32);
        this.listenTo(this.state, "change:highlightedResult", t, {priority: "low"}), this.listenTo(this.editor, "destroy", t.cancel), this.on("change:_isSearchActive", (i, n, o) => {
            o ? this.listenTo(this.editor.model.document, "change:data", this._onDocumentChange) : this.stopListening(this.editor.model.document, "change:data", this._onDocumentChange)
        })
    }

    find(e, t) {
        return this._isSearchActive = !0, this.editor.execute("find", e, t), this.state.results
    }

    stop() {
        this.state.clear(this.editor.model), this._isSearchActive = !1
    }

    _defineCommands() {
        this.editor.commands.add("find", new iT(this.editor, this.state)), this.editor.commands.add("findNext", new vm(this.editor, this.state)), this.editor.commands.add("findPrevious", new rT(this.editor, this.state)), this.editor.commands.add("replace", new sT(this.editor, this.state)), this.editor.commands.add("replaceAll", new oT(this.editor, this.state))
    }

    _defineConverters() {
        const {editor: e} = this;
        e.conversion.for("editingDowncast").markerToHighlight({
            model: "findResult", view: ({markerName: t}) => {
                const [, i] = t.split(":");
                return {name: "span", classes: ["ck-find-result"], attributes: {"data-find-result": i}}
            }
        }), e.conversion.for("editingDowncast").markerToHighlight({
            model: "findResultHighlighted",
            view: ({markerName: t}) => {
                const [, i] = t.split(":");
                return {name: "span", classes: [uT], attributes: {"data-find-result": i}}
            }
        })
    }

    _onDocumentChange = () => {
        const e = new Set, t = new Set, i = this.editor.model, {results: n} = this.state,
            o = i.document.differ.getChanges(), r = i.document.differ.getChangedMarkers();
        o.forEach(c => {
            c.position && (c.name === "$text" || c.position.nodeAfter && i.schema.isInline(c.position.nodeAfter) ? (e.add(c.position.parent), [...i.markers.getMarkersAtPosition(c.position)].forEach(u => {
                t.add(u.name)
            })) : c.type === "insert" && c.position.nodeAfter && e.add(c.position.nodeAfter))
        }), r.forEach(({name: c, data: {newRange: u}}) => {
            u && u.start.root.rootName === "$graveyard" && t.add(c)
        }), e.forEach(c => {
            [...i.markers.getMarkersIntersectingRange(i.createRangeIn(c))].forEach(d => t.add(d.name))
        }), t.forEach(c => {
            n.has(c) && (n.get(c) === this.state.highlightedResult && (this.state.highlightedResult = null), n.remove(c))
        });
        const a = [], l = this.editor.plugins.get("FindAndReplaceUtils");
        e.forEach(c => {
            const u = l.updateFindResultFromRange(i.createRangeOn(c), i, this.state.lastSearchCallback, n);
            a.push(...u)
        }), r.forEach(c => {
            if (c.data.newRange) {
                const u = l.updateFindResultFromRange(c.data.newRange, i, this.state.lastSearchCallback, n);
                a.push(...u)
            }
        }), !this.state.highlightedResult && a.length ? this.state.highlightedResult = a[0] : this.state.refreshHighlightOffset(i)
    }
}

class hT extends w {
    static get requires() {
        return [dT, tT]
    }

    static get pluginName() {
        return "FindAndReplace"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor.plugins.get("FindAndReplaceUI"), t = this.editor.plugins.get("FindAndReplaceEditing"),
            i = t.state;
        e.on("findNext", (n, o) => {
            o ? (i.searchText = o.searchText, t.find(o.searchText, o)) : this.editor.execute("findNext")
        }), e.on("findPrevious", (n, o) => {
            o && i.searchText !== o.searchText ? t.find(o.searchText) : this.editor.execute("findPrevious")
        }), e.on("replace", (n, o) => {
            i.searchText !== o.searchText && t.find(o.searchText);
            const r = i.highlightedResult;
            r && this.editor.execute("replace", o.replaceText, r)
        }), e.on("replaceAll", (n, o) => {
            i.searchText !== o.searchText && t.find(o.searchText), this.editor.execute("replaceAll", o.replaceText, i.results)
        }), e.on("searchReseted", () => {
            i.clear(this.editor.model), t.stop()
        })
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class co extends O {
    attributeKey;

    constructor(e, t) {
        super(e), this.attributeKey = t
    }

    refresh() {
        const e = this.editor.model, t = e.document;
        this.value = t.selection.getAttribute(this.attributeKey), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, this.attributeKey)
    }

    execute(e = {}) {
        const t = this.editor.model, n = t.document.selection, o = e.value, r = e.batch, a = l => {
            if (n.isCollapsed) o ? l.setSelectionAttribute(this.attributeKey, o) : l.removeSelectionAttribute(this.attributeKey); else {
                const c = t.schema.getValidRanges(n.getRanges(), this.attributeKey);
                for (const u of c) o ? l.setAttribute(this.attributeKey, o, u) : l.removeAttribute(this.attributeKey, u)
            }
        };
        r ? t.enqueueChange(r, l => {
            a(l)
        }) : t.change(l => {
            a(l)
        })
    }
}

const Se = "fontSize", Pe = "fontFamily", ct = "fontColor", kt = "fontBackgroundColor";

function ym(s, e) {
    const t = {model: {key: s, values: []}, view: {}, upcastAlso: {}};
    for (const i of e) t.model.values.push(i.model), t.view[i.model] = i.view, i.upcastAlso && (t.upcastAlso[i.model] = i.upcastAlso);
    return t
}

function km(s) {
    return e => mT(e.getStyle(s))
}

function Cm(s) {
    return (e, {writer: t}) => t.createAttributeElement("span", {style: `${s}:${e}`}, {priority: 7})
}

function fT({
                dropdownView: s,
                colors: e,
                columns: t,
                removeButtonLabel: i,
                colorPickerLabel: n,
                documentColorsLabel: o,
                documentColorsCount: r,
                colorPickerViewConfig: a
            }) {
    const l = s.locale, c = new jf(l, {
        colors: e,
        columns: t,
        removeButtonLabel: i,
        colorPickerLabel: n,
        documentColorsLabel: o,
        documentColorsCount: r,
        colorPickerViewConfig: a
    });
    return s.colorSelectorView = c, s.panelView.children.add(c), c
}

function mT(s) {
    return s.replace(/\s/g, "")
}

class gT extends co {
    constructor(e) {
        super(e, Pe)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Em(s) {
    return s.map(pT).filter(e => e !== void 0)
}

function pT(s) {
    if (typeof s == "object") return s;
    if (s === "default") return {title: "Default", model: void 0};
    if (typeof s == "string") return wT(s)
}

function wT(s) {
    const e = s.replace(/"|'/g, "").split(","), t = e[0], i = e.map(bT).join(", ");
    return {title: t, model: i, view: {name: "span", styles: {"font-family": i}, priority: 7}}
}

function bT(s) {
    return s = s.trim(), s.indexOf(" ") > 0 && (s = `'${s}'`), s
}

class _T extends w {
    static get pluginName() {
        return "FontFamilyEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), e.config.define(Pe, {
            options: ["default", "Arial, Helvetica, sans-serif", "Courier New, Courier, monospace", "Georgia, serif", "Lucida Sans Unicode, Lucida Grande, sans-serif", "Tahoma, Geneva, sans-serif", "Times New Roman, Times, serif", "Trebuchet MS, Helvetica, sans-serif", "Verdana, Geneva, sans-serif"],
            supportAllValues: !1
        })
    }

    init() {
        const e = this.editor;
        e.model.schema.extend("$text", {allowAttributes: Pe}), e.model.schema.setAttributeProperties(Pe, {
            isFormatting: !0,
            copyOnEnter: !0
        });
        const t = Em(e.config.get("fontFamily.options")).filter(n => n.model), i = ym(Pe, t);
        e.config.get("fontFamily.supportAllValues") ? (this._prepareAnyValueConverters(), this._prepareCompatibilityConverter()) : e.conversion.attributeToElement(i), e.commands.add(Pe, new gT(e))
    }

    _prepareAnyValueConverters() {
        const e = this.editor;
        e.conversion.for("downcast").attributeToElement({
            model: Pe,
            view: (t, {writer: i}) => i.createAttributeElement("span", {style: "font-family:" + t}, {priority: 7})
        }), e.conversion.for("upcast").elementToAttribute({
            model: {key: Pe, value: t => t.getStyle("font-family")},
            view: {name: "span", styles: {"font-family": /.*/}}
        })
    }

    _prepareCompatibilityConverter() {
        this.editor.conversion.for("upcast").elementToAttribute({
            view: {name: "font", attributes: {face: /.*/}},
            model: {key: Pe, value: t => t.getAttribute("face")}
        })
    }
}

class vT extends w {
    static get pluginName() {
        return "FontFamilyUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.t, i = this._getLocalizedOptions(), n = e.commands.get(Pe), o = t("Font Family"),
            r = yT(i, n);
        e.ui.componentFactory.add(Pe, a => {
            const l = Ae(a);
            return jn(l, r, {role: "menu", ariaLabel: o}), l.buttonView.set({
                label: o,
                icon: ec,
                tooltip: !0
            }), l.extendTemplate({attributes: {class: "ck-font-family-dropdown"}}), l.bind("isEnabled").to(n), this.listenTo(l, "execute", c => {
                e.execute(c.source.commandName, {value: c.source.commandParam}), e.editing.view.focus()
            }), l
        }), e.ui.componentFactory.add(`menuBar:${Pe}`, a => {
            const l = new Ne(a);
            l.buttonView.set({label: o, icon: ec}), l.bind("isEnabled").to(n);
            const c = new $t(a);
            for (const u of r) {
                const d = new St(a, l), h = new K(a);
                h.set({
                    role: "menuitemradio",
                    isToggleable: !0
                }), h.bind(...Object.keys(u.model)).to(u.model), h.delegate("execute").to(l), h.on("execute", () => {
                    e.execute(u.model.commandName, {value: u.model.commandParam}), e.editing.view.focus()
                }), d.children.add(h), c.items.add(d)
            }
            return l.panelView.children.add(c), l
        })
    }

    _getLocalizedOptions() {
        const e = this.editor, t = e.t;
        return Em(e.config.get(Pe).options).map(n => (n.title === "Default" && (n.title = t("Default")), n))
    }
}

function yT(s, e) {
    const t = new ce;
    for (const i of s) {
        const n = {
            type: "button",
            model: new qi({commandName: Pe, commandParam: i.model, label: i.title, role: "menuitemradio", withText: !0})
        };
        n.model.bind("isOn").to(e, "value", o => o === i.model ? !0 : !o || !i.model ? !1 : o.split(",")[0].replace(/'/g, "").toLowerCase() === i.model.toLowerCase()), i.view && typeof i.view != "string" && i.view.styles && n.model.set("labelStyle", `font-family: ${i.view.styles["font-family"]}`), t.add(n)
    }
    return t
}

class kT extends w {
    static get requires() {
        return [_T, vT]
    }

    static get pluginName() {
        return "FontFamily"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

class CT extends co {
    constructor(e) {
        super(e, Se)
    }
}

function Aa(s) {
    return s.map(e => ET(e)).filter(e => e !== void 0)
}

const pu = {
    get tiny() {
        return {title: "Tiny", model: "tiny", view: {name: "span", classes: "text-tiny", priority: 7}}
    }, get small() {
        return {title: "Small", model: "small", view: {name: "span", classes: "text-small", priority: 7}}
    }, get big() {
        return {title: "Big", model: "big", view: {name: "span", classes: "text-big", priority: 7}}
    }, get huge() {
        return {title: "Huge", model: "huge", view: {name: "span", classes: "text-huge", priority: 7}}
    }
};

function ET(s) {
    if (typeof s == "number" && (s = String(s)), typeof s == "object" && xT(s)) return xr(s);
    const e = AT(s);
    if (e) return xr(e);
    if (s === "default") return {model: void 0, title: "Default"};
    if (!IT(s)) return TT(s)
}

function TT(s) {
    return typeof s == "string" && (s = {title: s, model: `${parseFloat(s)}px`}), s.view = {
        name: "span",
        styles: {"font-size": s.model}
    }, xr(s)
}

function xr(s) {
    return s.view && typeof s.view != "string" && !s.view.priority && (s.view.priority = 7), s
}

function AT(s) {
    return typeof s == "string" ? pu[s] : pu[s.model]
}

function xT(s) {
    return s.title && s.model && s.view
}

function IT(s) {
    let e;
    if (typeof s == "object") if (s.model) e = parseFloat(s.model); else throw new p("font-size-invalid-definition", null, s); else e = parseFloat(s);
    return isNaN(e)
}

const wu = ["x-small", "x-small", "small", "medium", "large", "x-large", "xx-large", "xxx-large"];

class ST extends w {
    static get pluginName() {
        return "FontSizeEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), e.config.define(Se, {options: ["tiny", "small", "default", "big", "huge"], supportAllValues: !1})
    }

    init() {
        const e = this.editor;
        e.model.schema.extend("$text", {allowAttributes: Se}), e.model.schema.setAttributeProperties(Se, {
            isFormatting: !0,
            copyOnEnter: !0
        });
        const t = e.config.get("fontSize.supportAllValues"),
            i = Aa(this.editor.config.get("fontSize.options")).filter(o => o.model), n = ym(Se, i);
        t ? (this._prepareAnyValueConverters(n), this._prepareCompatibilityConverter()) : e.conversion.attributeToElement(n), e.commands.add(Se, new CT(e))
    }

    _prepareAnyValueConverters(e) {
        const t = this.editor, i = e.model.values.filter(n => !rv(String(n)) && !lv(String(n)));
        if (i.length) throw new p("font-size-invalid-use-of-named-presets", null, {presets: i});
        t.conversion.for("downcast").attributeToElement({
            model: Se, view: (n, {writer: o}) => {
                if (n) return o.createAttributeElement("span", {style: "font-size:" + n}, {priority: 7})
            }
        }), t.conversion.for("upcast").elementToAttribute({
            model: {key: Se, value: n => n.getStyle("font-size")},
            view: {name: "span", styles: {"font-size": /.*/}}
        })
    }

    _prepareCompatibilityConverter() {
        this.editor.conversion.for("upcast").elementToAttribute({
            view: {
                name: "font",
                attributes: {size: /^[+-]?\d{1,3}$/}
            }, model: {
                key: Se, value: t => {
                    const i = t.getAttribute("size"), n = i[0] === "-" || i[0] === "+";
                    let o = parseInt(i, 10);
                    n && (o = 3 + o);
                    const r = wu.length - 1, a = Math.min(Math.max(o, 0), r);
                    return wu[a]
                }
            }
        })
    }
}

class PT extends w {
    static get pluginName() {
        return "FontSizeUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.t, i = this._getLocalizedOptions(), n = e.commands.get(Se), o = t("Font Size"),
            r = RT(i, n);
        e.ui.componentFactory.add(Se, a => {
            const l = Ae(a);
            return jn(l, r, {role: "menu", ariaLabel: o}), l.buttonView.set({
                label: o,
                icon: tc,
                tooltip: !0
            }), l.extendTemplate({attributes: {class: ["ck-font-size-dropdown"]}}), l.bind("isEnabled").to(n), this.listenTo(l, "execute", c => {
                e.execute(c.source.commandName, {value: c.source.commandParam}), e.editing.view.focus()
            }), l
        }), e.ui.componentFactory.add(`menuBar:${Se}`, a => {
            const l = new Ne(a);
            l.buttonView.set({label: o, icon: tc}), l.bind("isEnabled").to(n);
            const c = new $t(a);
            for (const u of r) {
                const d = new St(a, l), h = new K(a);
                h.set({
                    role: "menuitemradio",
                    isToggleable: !0
                }), h.bind(...Object.keys(u.model)).to(u.model), h.delegate("execute").to(l), h.on("execute", () => {
                    e.execute(u.model.commandName, {value: u.model.commandParam}), e.editing.view.focus()
                }), d.children.add(h), c.items.add(d)
            }
            return l.panelView.children.add(c), l
        })
    }

    _getLocalizedOptions() {
        const e = this.editor, t = e.t,
            i = {Default: t("Default"), Tiny: t("Tiny"), Small: t("Small"), Big: t("Big"), Huge: t("Huge")};
        return Aa(e.config.get(Se).options).map(o => {
            const r = i[o.title];
            return r && r != o.title && (o = Object.assign({}, o, {title: r})), o
        })
    }
}

function RT(s, e) {
    const t = new ce;
    for (const i of s) {
        const n = {
            type: "button",
            model: new qi({
                commandName: Se,
                commandParam: i.model,
                label: i.title,
                class: "ck-fontsize-option",
                role: "menuitemradio",
                withText: !0
            })
        };
        i.view && typeof i.view != "string" && (i.view.styles && n.model.set("labelStyle", `font-size:${i.view.styles["font-size"]}`), i.view.classes && n.model.set("class", `${n.model.class} ${i.view.classes}`)), n.model.bind("isOn").to(e, "value", o => o === i.model), t.add(n)
    }
    return t
}

class VT extends w {
    static get requires() {
        return [ST, PT]
    }

    static get pluginName() {
        return "FontSize"
    }

    static get isOfficialPlugin() {
        return !0
    }

    normalizeSizeOptions(e) {
        return Aa(e)
    }
}

class OT extends co {
    constructor(e) {
        super(e, ct)
    }
}

class MT extends w {
    static get pluginName() {
        return "FontColorEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), e.config.define(ct, {
            colors: [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
                color: "hsl(0, 0%, 30%)",
                label: "Dim grey"
            }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
                color: "hsl(0, 0%, 90%)",
                label: "Light grey"
            }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: !0}, {
                color: "hsl(0, 75%, 60%)",
                label: "Red"
            }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
                color: "hsl(60, 75%, 60%)",
                label: "Yellow"
            }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
                color: "hsl(120, 75%, 60%)",
                label: "Green"
            }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
                color: "hsl(180, 75%, 60%)",
                label: "Turquoise"
            }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
                color: "hsl(240, 75%, 60%)",
                label: "Blue"
            }, {color: "hsl(270, 75%, 60%)", label: "Purple"}], columns: 5
        }), e.conversion.for("upcast").elementToAttribute({
            view: {name: "span", styles: {color: /[\s\S]+/}},
            model: {key: ct, value: km("color")}
        }), e.conversion.for("upcast").elementToAttribute({
            view: {name: "font", attributes: {color: /^#?\w+$/}},
            model: {key: ct, value: t => t.getAttribute("color")}
        }), e.conversion.for("downcast").attributeToElement({
            model: ct,
            view: Cm("color")
        }), e.commands.add(ct, new OT(e)), e.model.schema.extend("$text", {allowAttributes: ct}), e.model.schema.setAttributeProperties(ct, {
            isFormatting: !0,
            copyOnEnter: !0
        })
    }
}

class Tm extends w {
    commandName;
    componentName;
    icon;
    dropdownLabel;
    columns;

    constructor(e, {commandName: t, componentName: i, icon: n, dropdownLabel: o}) {
        super(e), this.commandName = t, this.componentName = i, this.icon = n, this.dropdownLabel = o, this.columns = e.config.get(`${this.componentName}.columns`)
    }

    init() {
        const e = this.editor, t = e.locale, i = t.t, n = e.commands.get(this.commandName),
            o = e.config.get(this.componentName), r = xy(o.colors), a = Ay(t, r), l = o.documentColors,
            c = o.colorPicker !== !1;
        e.ui.componentFactory.add(this.componentName, u => {
            const d = Ae(u);
            let h = !1;
            const f = fT({
                dropdownView: d,
                colors: a.map(m => ({label: m.label, color: m.model, options: {hasBorder: m.hasBorder}})),
                columns: this.columns,
                removeButtonLabel: i("Remove color"),
                colorPickerLabel: i("Color picker"),
                documentColorsLabel: l !== 0 ? i("Document colors") : "",
                documentColorsCount: l === void 0 ? this.columns : l,
                colorPickerViewConfig: c ? o.colorPicker || {} : !1
            });
            return f.bind("selectedColor").to(n, "value"), d.buttonView.set({
                label: this.dropdownLabel,
                icon: this.icon,
                tooltip: !0
            }), d.extendTemplate({attributes: {class: "ck-color-ui-dropdown"}}), d.bind("isEnabled").to(n), f.on("execute", (m, g) => {
                d.isOpen && e.execute(this.commandName, {
                    value: g.value,
                    batch: this._undoStepBatch
                }), g.source !== "colorPicker" && e.editing.view.focus(), g.source === "colorPickerSaveButton" && (d.isOpen = !1)
            }), f.on("colorPicker:show", () => {
                this._undoStepBatch = e.model.createBatch()
            }), f.on("colorPicker:cancel", () => {
                this._undoStepBatch.operations.length && (d.isOpen = !1, e.execute("undo", this._undoStepBatch)), e.editing.view.focus()
            }), d.on("change:isOpen", (m, g, _) => {
                h || (h = !0, d.colorSelectorView.appendUI()), _ && (l !== 0 && f.updateDocumentColors(e.model, this.componentName), f.updateSelectedColors(), f.showColorGridsFragment())
            }), ba(d, () => d.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find(m => m.isOn)), d
        }), e.ui.componentFactory.add(`menuBar:${this.componentName}`, u => {
            const d = new Ne(u);
            d.buttonView.set({label: this.dropdownLabel, icon: this.icon}), d.bind("isEnabled").to(n);
            let h = !1;
            const f = new jf(u, {
                colors: a.map(m => ({
                    label: m.label,
                    color: m.model,
                    options: {hasBorder: m.hasBorder}
                })),
                columns: this.columns,
                removeButtonLabel: i("Remove color"),
                colorPickerLabel: i("Color picker"),
                documentColorsLabel: l !== 0 ? i("Document colors") : "",
                documentColorsCount: l === void 0 ? this.columns : l,
                colorPickerViewConfig: !1
            });
            return f.bind("selectedColor").to(n, "value"), f.delegate("execute").to(d), f.on("execute", (m, g) => {
                e.execute(this.commandName, {value: g.value, batch: this._undoStepBatch}), e.editing.view.focus()
            }), d.on("change:isOpen", (m, g, _) => {
                h || (h = !0, f.appendUI()), _ && (l !== 0 && f.updateDocumentColors(e.model, this.componentName), f.updateSelectedColors(), f.showColorGridsFragment())
            }), d.panelView.children.add(f), d
        })
    }
}

class BT extends Tm {
    constructor(e) {
        const t = e.locale.t;
        super(e, {commandName: ct, componentName: ct, icon: e1, dropdownLabel: t("Font Color")})
    }

    static get pluginName() {
        return "FontColorUI"
    }
}

class FT extends w {
    static get requires() {
        return [MT, BT]
    }

    static get pluginName() {
        return "FontColor"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

class LT extends co {
    constructor(e) {
        super(e, kt)
    }
}

class DT extends w {
    static get pluginName() {
        return "FontBackgroundColorEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), e.config.define(kt, {
            colors: [{color: "hsl(0, 0%, 0%)", label: "Black"}, {
                color: "hsl(0, 0%, 30%)",
                label: "Dim grey"
            }, {color: "hsl(0, 0%, 60%)", label: "Grey"}, {
                color: "hsl(0, 0%, 90%)",
                label: "Light grey"
            }, {color: "hsl(0, 0%, 100%)", label: "White", hasBorder: !0}, {
                color: "hsl(0, 75%, 60%)",
                label: "Red"
            }, {color: "hsl(30, 75%, 60%)", label: "Orange"}, {
                color: "hsl(60, 75%, 60%)",
                label: "Yellow"
            }, {color: "hsl(90, 75%, 60%)", label: "Light green"}, {
                color: "hsl(120, 75%, 60%)",
                label: "Green"
            }, {color: "hsl(150, 75%, 60%)", label: "Aquamarine"}, {
                color: "hsl(180, 75%, 60%)",
                label: "Turquoise"
            }, {color: "hsl(210, 75%, 60%)", label: "Light blue"}, {
                color: "hsl(240, 75%, 60%)",
                label: "Blue"
            }, {color: "hsl(270, 75%, 60%)", label: "Purple"}], columns: 5
        }), e.data.addStyleProcessorRules(bv), e.conversion.for("upcast").elementToAttribute({
            view: {
                name: "span",
                styles: {"background-color": /[\s\S]+/}
            }, model: {key: kt, value: km("background-color")}
        }), e.conversion.for("downcast").attributeToElement({
            model: kt,
            view: Cm("background-color")
        }), e.commands.add(kt, new LT(e)), e.model.schema.extend("$text", {allowAttributes: kt}), e.model.schema.setAttributeProperties(kt, {
            isFormatting: !0,
            copyOnEnter: !0
        })
    }
}

class NT extends Tm {
    constructor(e) {
        const t = e.locale.t;
        super(e, {commandName: kt, componentName: kt, icon: Xv, dropdownLabel: t("Font Background Color")})
    }

    static get pluginName() {
        return "FontBackgroundColorUI"
    }
}

class zT extends w {
    static get requires() {
        return [DT, NT]
    }

    static get pluginName() {
        return "FontBackgroundColor"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class HT extends O {
    constructor(e) {
        super(e), this._isEnabledBasedOnSelection = !1
    }

    refresh() {
        const e = this.editor.model, t = e.document, i = re(t.selection.getSelectedBlocks());
        this.value = !!i && i.is("element", "paragraph"), this.isEnabled = !!i && bu(i, e.schema)
    }

    execute(e = {}) {
        const t = this.editor.model, i = t.document, n = e.selection || i.selection;
        t.canEditAt(n) && t.change(o => {
            const r = n.getSelectedBlocks();
            for (const a of r) !a.is("element", "paragraph") && bu(a, t.schema) && o.rename(a, "paragraph")
        })
    }
}

function bu(s, e) {
    return e.checkChild(s.parent, "paragraph") && !e.isObject(s)
}

class UT extends O {
    constructor(e) {
        super(e), this._isEnabledBasedOnSelection = !1
    }

    execute(e) {
        const t = this.editor.model, i = e.attributes;
        let n = e.position;
        return t.canEditAt(n) ? t.change(o => {
            if (n = this._findPositionToInsertParagraph(n, o), !n) return null;
            const r = o.createElement("paragraph");
            return i && t.schema.setAllowedAttributes(r, i, o), t.insertContent(r, n), o.setSelection(r, "in"), o.createPositionAt(r, 0)
        }) : null
    }

    _findPositionToInsertParagraph(e, t) {
        const i = this.editor.model;
        if (i.schema.checkChild(e, "paragraph")) return e;
        const n = i.schema.findAllowedParent(e, "paragraph");
        if (!n) return null;
        const o = e.parent, r = i.schema.checkChild(o, "$text");
        return o.isEmpty || r && e.isAtEnd ? i.createPositionAfter(o) : !o.isEmpty && r && e.isAtStart ? i.createPositionBefore(o) : t.split(e, n).position
    }
}

class uo extends w {
    static get pluginName() {
        return "Paragraph"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.model;
        e.commands.add("paragraph", new HT(e)), e.commands.add("insertParagraph", new UT(e)), t.schema.register("paragraph", {inheritAllFrom: "$block"}), e.conversion.elementToElement({
            model: "paragraph",
            view: "p"
        }), e.conversion.for("upcast").elementToElement({
            model: (i, {writer: n}) => !uo.paragraphLikeElements.has(i.name) || i.isEmpty ? null : n.createElement("paragraph"),
            view: /.+/,
            converterPriority: "low"
        })
    }

    static paragraphLikeElements = new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"])
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class $T extends O {
    modelElements;

    constructor(e, t) {
        super(e), this.modelElements = t
    }

    refresh() {
        const e = re(this.editor.model.document.selection.getSelectedBlocks());
        this.value = !!e && this.modelElements.includes(e.name) && e.name, this.isEnabled = !!e && this.modelElements.some(t => _u(e, t, this.editor.model.schema))
    }

    execute(e) {
        const t = this.editor.model, i = t.document, n = e.value;
        t.change(o => {
            const r = Array.from(i.selection.getSelectedBlocks()).filter(a => _u(a, n, t.schema));
            for (const a of r) a.is("element", n) || o.rename(a, n)
        })
    }
}

function _u(s, e, t) {
    return t.checkChild(s.parent, e) && !t.isObject(s)
}

const vu = "paragraph";

class WT extends w {
    static get pluginName() {
        return "HeadingEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), e.config.define("heading", {
            options: [{
                model: "paragraph",
                title: "Paragraph",
                class: "ck-heading_paragraph"
            }, {model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1"}, {
                model: "heading2",
                view: "h3",
                title: "Heading 2",
                class: "ck-heading_heading2"
            }, {model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3"}]
        })
    }

    static get requires() {
        return [uo]
    }

    init() {
        const e = this.editor, t = e.config.get("heading.options"), i = [];
        for (const n of t) n.model !== "paragraph" && (e.model.schema.register(n.model, {inheritAllFrom: "$block"}), e.conversion.elementToElement(n), i.push(n.model));
        this._addDefaultH1Conversion(e), e.commands.add("heading", new $T(e, i))
    }

    afterInit() {
        const e = this.editor, t = e.commands.get("enter"), i = e.config.get("heading.options");
        t && this.listenTo(t, "afterExecute", (n, o) => {
            const r = e.model.document.selection.getFirstPosition().parent;
            i.some(l => r.is("element", l.model)) && !r.is("element", vu) && r.childCount === 0 && o.writer.rename(r, vu)
        })
    }

    _addDefaultH1Conversion(e) {
        e.conversion.for("upcast").elementToElement({model: "heading1", view: "h1", converterPriority: Le.low + 1})
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function qT(s) {
    const e = s.t, t = {
        Paragraph: e("Paragraph"),
        "Heading 1": e("Heading 1"),
        "Heading 2": e("Heading 2"),
        "Heading 3": e("Heading 3"),
        "Heading 4": e("Heading 4"),
        "Heading 5": e("Heading 5"),
        "Heading 6": e("Heading 6")
    };
    return s.config.get("heading.options").map(i => {
        const n = t[i.title];
        return n && n != i.title && (i.title = n), i
    })
}

class jT extends w {
    static get pluginName() {
        return "HeadingUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.t, i = qT(e), n = t("Choose heading"), o = t("Heading");
        e.ui.componentFactory.add("heading", r => {
            const a = {}, l = new ce, c = e.commands.get("heading"), u = e.commands.get("paragraph"), d = [c];
            for (const f of i) {
                const m = {
                    type: "button",
                    model: new qi({label: f.title, class: f.class, role: "menuitemradio", withText: !0})
                };
                f.model === "paragraph" ? (m.model.bind("isOn").to(u, "value"), m.model.set("commandName", "paragraph"), d.push(u)) : (m.model.bind("isOn").to(c, "value", g => g === f.model), m.model.set({
                    commandName: "heading",
                    commandValue: f.model
                })), l.add(m), a[f.model] = f.title
            }
            const h = Ae(r);
            return jn(h, l, {ariaLabel: o, role: "menu"}), h.buttonView.set({
                ariaLabel: o,
                ariaLabelledBy: void 0,
                isOn: !1,
                withText: !0,
                tooltip: o
            }), h.extendTemplate({attributes: {class: ["ck-heading-dropdown"]}}), h.bind("isEnabled").toMany(d, "isEnabled", (...f) => f.some(m => m)), h.buttonView.bind("label").to(c, "value", u, "value", (f, m) => {
                const g = m ? "paragraph" : f;
                return typeof g == "boolean" || !a[g] ? n : a[g]
            }), h.buttonView.bind("ariaLabel").to(c, "value", u, "value", (f, m) => {
                const g = m ? "paragraph" : f;
                return typeof g == "boolean" || !a[g] ? o : `${a[g]}, ${o}`
            }), this.listenTo(h, "execute", f => {
                const {commandName: m, commandValue: g} = f.source;
                e.execute(m, g ? {value: g} : void 0), e.editing.view.focus()
            }), h
        }), e.ui.componentFactory.add("menuBar:heading", r => {
            const a = new Ne(r), l = e.commands.get("heading"), c = e.commands.get("paragraph"), u = [l], d = new $t(r);
            a.set({class: "ck-heading-dropdown"}), d.set({
                ariaLabel: t("Heading"),
                role: "menu"
            }), a.buttonView.set({label: t("Heading")}), a.panelView.children.add(d);
            for (const h of i) {
                const f = new St(r, a), m = new K(r);
                f.children.add(m), d.items.add(f), m.set({
                    isToggleable: !0,
                    label: h.title,
                    role: "menuitemradio",
                    class: h.class
                }), m.delegate("execute").to(a), m.on("execute", () => {
                    const g = h.model === "paragraph" ? "paragraph" : "heading";
                    e.execute(g, {value: h.model}), e.editing.view.focus()
                }), h.model === "paragraph" ? (m.bind("isOn").to(c, "value"), u.push(c)) : m.bind("isOn").to(l, "value", g => g === h.model)
            }
            return a.bind("isEnabled").toMany(u, "isEnabled", (...h) => h.some(f => f)), a
        })
    }
}

class GT extends w {
    static get requires() {
        return [WT, jT]
    }

    static get pluginName() {
        return "Heading"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class KT extends O {
    refresh() {
        const e = this.editor.model, t = e.document;
        this.value = t.selection.getAttribute("highlight"), this.isEnabled = e.schema.checkAttributeInSelection(t.selection, "highlight")
    }

    execute(e = {}) {
        const t = this.editor.model, n = t.document.selection, o = e.value;
        t.change(r => {
            if (n.isCollapsed) {
                const a = n.getFirstPosition();
                if (n.hasAttribute("highlight")) {
                    const l = h => h.item.hasAttribute("highlight") && h.item.getAttribute("highlight") === this.value,
                        c = a.getLastMatchingPosition(l, {direction: "backward"}), u = a.getLastMatchingPosition(l),
                        d = r.createRange(c, u);
                    !o || this.value === o ? (a.isEqual(u) || r.removeAttribute("highlight", d), r.removeSelectionAttribute("highlight")) : (a.isEqual(u) || r.setAttribute("highlight", o, d), r.setSelectionAttribute("highlight", o))
                } else o && r.setSelectionAttribute("highlight", o)
            } else {
                const a = t.schema.getValidRanges(n.getRanges(), "highlight");
                for (const l of a) o ? r.setAttribute("highlight", o, l) : r.removeAttribute("highlight", l)
            }
        })
    }
}

class ZT extends w {
    static get pluginName() {
        return "HighlightEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), e.config.define("highlight", {
            options: [{
                model: "yellowMarker",
                class: "marker-yellow",
                title: "Yellow marker",
                color: "var(--ck-highlight-marker-yellow)",
                type: "marker"
            }, {
                model: "greenMarker",
                class: "marker-green",
                title: "Green marker",
                color: "var(--ck-highlight-marker-green)",
                type: "marker"
            }, {
                model: "pinkMarker",
                class: "marker-pink",
                title: "Pink marker",
                color: "var(--ck-highlight-marker-pink)",
                type: "marker"
            }, {
                model: "blueMarker",
                class: "marker-blue",
                title: "Blue marker",
                color: "var(--ck-highlight-marker-blue)",
                type: "marker"
            }, {
                model: "redPen",
                class: "pen-red",
                title: "Red pen",
                color: "var(--ck-highlight-pen-red)",
                type: "pen"
            }, {
                model: "greenPen",
                class: "pen-green",
                title: "Green pen",
                color: "var(--ck-highlight-pen-green)",
                type: "pen"
            }]
        })
    }

    init() {
        const e = this.editor;
        e.model.schema.extend("$text", {allowAttributes: "highlight"});
        const t = e.config.get("highlight.options");
        e.conversion.attributeToElement(JT(t)), e.commands.add("highlight", new KT(e))
    }
}

function JT(s) {
    const e = {model: {key: "highlight", values: []}, view: {}};
    for (const t of s) e.model.values.push(t.model), e.view[t.model] = {name: "mark", classes: t.class};
    return e
}

class QT extends w {
    get localizedOptionTitles() {
        const e = this.editor.t;
        return {
            "Yellow marker": e("Yellow marker"),
            "Green marker": e("Green marker"),
            "Pink marker": e("Pink marker"),
            "Blue marker": e("Blue marker"),
            "Red pen": e("Red pen"),
            "Green pen": e("Green pen")
        }
    }

    static get pluginName() {
        return "HighlightUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor.config.get("highlight.options");
        for (const t of e) this._addHighlighterButton(t);
        this._addRemoveHighlightButton(), this._addDropdown(e), this._addMenuBarButton(e)
    }

    _addRemoveHighlightButton() {
        const e = this.editor.t, t = this.editor.commands.get("highlight");
        this._addButton("removeHighlight", e("Remove highlight"), vr, null, i => {
            i.bind("isEnabled").to(t, "isEnabled")
        })
    }

    _addHighlighterButton(e) {
        const t = this.editor.commands.get("highlight");
        this._addButton("highlight:" + e.model, e.title, ds(e.type), e.model, i);

        function i(n) {
            n.bind("isEnabled").to(t, "isEnabled"), n.bind("isOn").to(t, "value", o => o === e.model), n.iconView.fillColor = e.color, n.isToggleable = !0
        }
    }

    _addButton(e, t, i, n, o) {
        const r = this.editor;
        r.ui.componentFactory.add(e, a => {
            const l = new I(a), c = this.localizedOptionTitles[t] ? this.localizedOptionTitles[t] : t;
            return l.set({label: c, icon: i, tooltip: !0}), l.on("execute", () => {
                r.execute("highlight", {value: n}), r.editing.view.focus()
            }), o(l), l
        })
    }

    _addDropdown(e) {
        const t = this.editor, i = t.t, n = t.ui.componentFactory, o = e[0],
            r = e.reduce((a, l) => (a[l.model] = l, a), {});
        n.add("highlight", a => {
            const l = t.commands.get("highlight"), c = Ae(a, Wn), u = c.buttonView;
            u.set({
                label: i("Highlight"),
                tooltip: !0,
                lastExecuted: o.model,
                commandValue: o.model,
                isToggleable: !0
            }), u.bind("icon").to(l, "value", f => ds(h(f, "type"))), u.bind("color").to(l, "value", f => h(f, "color")), u.bind("commandValue").to(l, "value", f => h(f, "model")), u.bind("isOn").to(l, "value", f => !!f), u.delegate("execute").to(c);
            const d = () => {
                const f = e.map(m => {
                    const g = n.create("highlight:" + m.model);
                    return this.listenTo(g, "execute", () => {
                        c.buttonView.set({lastExecuted: m.model})
                    }), g
                });
                return f.push(new wa), f.push(n.create("removeHighlight")), f
            };
            c.bind("isEnabled").to(l, "isEnabled"), qn(c, d, {
                enableActiveItemFocusOnDropdownOpen: !0,
                ariaLabel: i("Text highlight toolbar")
            }), YT(c), u.on("execute", () => {
                t.execute("highlight", {value: u.commandValue})
            }), this.listenTo(c, "execute", () => {
                t.editing.view.focus()
            });

            function h(f, m) {
                const g = !f || f === u.lastExecuted ? u.lastExecuted : f;
                return r[g][m]
            }

            return c
        })
    }

    _addMenuBarButton(e) {
        const t = this.editor, i = t.t, n = t.commands.get("highlight");
        t.ui.componentFactory.add("menuBar:highlight", o => {
            const r = new Ne(o);
            r.buttonView.set({
                label: i("Highlight"),
                icon: ds("marker")
            }), r.bind("isEnabled").to(n), r.buttonView.iconView.fillColor = "transparent";
            const a = new $t(o);
            for (const u of e) {
                const d = new St(o, r), h = new K(o);
                h.set({
                    label: u.title,
                    icon: ds(u.type),
                    role: "menuitemradio",
                    isToggleable: !0
                }), h.iconView.fillColor = u.color, h.delegate("execute").to(r), h.bind("isOn").to(n, "value", f => f === u.model), h.on("execute", () => {
                    t.execute("highlight", {value: u.model}), t.editing.view.focus()
                }), d.children.add(h), a.items.add(d)
            }
            a.items.add(new so(o));
            const l = new St(o, r), c = new K(o);
            return c.set({label: i("Remove highlight"), icon: vr}), c.delegate("execute").to(r), c.on("execute", () => {
                t.execute("highlight", {value: null}), t.editing.view.focus()
            }), l.children.add(c), a.items.add(l), r.panelView.children.add(a), r
        })
    }
}

function YT(s) {
    s.buttonView.actionView.iconView.bind("fillColor").to(s.buttonView, "color")
}

function ds(s) {
    return s === "marker" ? a1 : _1
}

class XT extends w {
    static get requires() {
        return [ZT, QT]
    }

    static get pluginName() {
        return "Highlight"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class eA extends O {
    refresh() {
        const e = this.editor.model, t = e.schema, i = e.document.selection;
        this.isEnabled = tA(i, t, e)
    }

    execute() {
        const e = this.editor.model;
        e.change(t => {
            const i = t.createElement("horizontalLine");
            e.insertObject(i, null, null, {setSelection: "after"})
        })
    }
}

function tA(s, e, t) {
    const i = iA(s, t);
    return e.checkChild(i, "horizontalLine")
}

function iA(s, e) {
    const i = ka(s, e).start.parent;
    return i.isEmpty && !i.is("element", "$root") ? i.parent : i
}

class nA extends w {
    static get pluginName() {
        return "HorizontalLineEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.model.schema, i = e.t, n = e.conversion;
        t.register("horizontalLine", {inheritAllFrom: "$blockObject"}), n.for("dataDowncast").elementToElement({
            model: "horizontalLine",
            view: (o, {writer: r}) => r.createEmptyElement("hr")
        }), n.for("editingDowncast").elementToStructure({
            model: "horizontalLine", view: (o, {writer: r}) => {
                const a = i("Horizontal line"), l = r.createContainerElement("div", null, r.createEmptyElement("hr"));
                return r.addClass("ck-horizontal-line", l), r.setCustomProperty("hr", !0, l), sA(l, r, a)
            }
        }), n.for("upcast").elementToElement({
            view: "hr",
            model: "horizontalLine"
        }), e.commands.add("horizontalLine", new eA(e))
    }
}

function sA(s, e, t) {
    return e.setCustomProperty("horizontalLine", !0, s), Xi(s, e, {label: t})
}

class oA extends w {
    static get pluginName() {
        return "HorizontalLineUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        e.ui.componentFactory.add("horizontalLine", () => {
            const t = this._createButton(I);
            return t.set({tooltip: !0}), t
        }), e.ui.componentFactory.add("menuBar:horizontalLine", () => this._createButton(K))
    }

    _createButton(e) {
        const t = this.editor, i = t.locale, n = t.commands.get("horizontalLine"), o = new e(t.locale), r = i.t;
        return o.set({
            label: r("Horizontal line"),
            icon: t1
        }), o.bind("isEnabled").to(n, "isEnabled"), this.listenTo(o, "execute", () => {
            t.execute("horizontalLine"), t.editing.view.focus()
        }), o
    }
}

class rA extends w {
    static get requires() {
        return [nA, oA, di]
    }

    static get pluginName() {
        return "HorizontalLine"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function dt(s, e, t, i) {
    e && aA(s, e, i), t && ht(s, t, i)
}

function ht(s, e, t) {
    if (e.attributes) for (const [i, n] of Object.entries(e.attributes)) s.setAttribute(i, n, t);
    e.styles && s.setStyle(e.styles, t), e.classes && s.addClass(e.classes, t)
}

function aA(s, e, t) {
    if (e.attributes) for (const [i] of Object.entries(e.attributes)) s.removeAttribute(i, t);
    if (e.styles) for (const i of Object.keys(e.styles)) s.removeStyle(i, t);
    e.classes && s.removeClass(e.classes, t)
}

function lA(s, e) {
    const t = Ve(s);
    let i = "attributes";
    for (i in e) i == "classes" ? t[i] = Array.from(new Set([...s[i] || [], ...e[i]])) : t[i] = {...s[i], ...e[i]};
    return t
}

function Ci(s, e, t, i, n) {
    const o = e.getAttribute(t), r = {};
    for (const a of ["attributes", "styles", "classes"]) {
        if (a != i) {
            o && o[a] && (r[a] = o[a]);
            continue
        }
        if (i == "classes") {
            const c = new Set(o && o.classes || []);
            n(c), c.size && (r[a] = Array.from(c));
            continue
        }
        const l = new Map(Object.entries(o && o[a] || {}));
        n(l), l.size && (r[a] = Object.fromEntries(l))
    }
    Object.keys(r).length ? e.is("documentSelection") ? s.setSelectionAttribute(t, r) : s.setAttribute(t, r, e) : o && (e.is("documentSelection") ? s.removeSelectionAttribute(t) : s.removeAttribute(t, e))
}

function cA(s) {
    return np(s).replace(/ /g, "")
}

function Ge(s) {
    return `html${cA(s)}Attributes`
}

function xa({model: s}) {
    return (e, t) => t.writer.createElement(s, {htmlContent: e.getCustomProperty("$rawContent")})
}

function uA(s, {view: e, isInline: t}) {
    const i = s.t;
    return (n, {writer: o}) => {
        const r = i("HTML object"), a = ho(e, n, o), l = n.getAttribute(Ge(e));
        o.addClass("html-object-embed__content", a), l && ht(o, l, a);
        const c = o.createContainerElement(t ? "span" : "div", {
            class: "html-object-embed",
            "data-html-object-embed-label": r
        }, a);
        return Xi(c, o, {label: r})
    }
}

function ho(s, e, t) {
    return t.createRawElement(s, null, (i, n) => {
        n.setContentOf(i, e.getAttribute("htmlContent"))
    })
}

function dA({view: s, model: e, allowEmpty: t}, i) {
    return o => {
        o.on(`element:${s}`, (r, a, l) => {
            let c = i.processViewAttributes(a.viewItem, l);
            if (!(!c && !l.consumable.test(a.viewItem, {name: !0}))) {
                if (c = c || {}, l.consumable.consume(a.viewItem, {name: !0}), a.modelRange || (a = Object.assign(a, l.convertChildren(a.viewItem, a.modelCursor))), t && a.modelRange.isCollapsed && Object.keys(c).length) {
                    const u = l.writer.createElement("htmlEmptyElement");
                    if (!l.safeInsert(u, a.modelCursor)) return;
                    const d = l.getSplitParts(u);
                    a.modelRange = l.writer.createRange(a.modelRange.start, l.writer.createPositionAfter(d[d.length - 1])), l.updateConversionResult(u, a), n(u, c, l);
                    return
                }
                for (const u of a.modelRange.getItems()) n(u, c, l)
            }
        }, {priority: "low"})
    };

    function n(o, r, a) {
        if (a.schema.checkAttribute(o, e)) {
            const l = o.getAttribute(e), c = lA(r, l || {});
            a.writer.setAttribute(e, c, o)
        }
    }
}

function yu({model: s, view: e}, t) {
    return (i, {writer: n, consumable: o}) => {
        if (!i.hasAttribute(s)) return null;
        const r = n.createContainerElement(e), a = i.getAttribute(s);
        return o.consume(i, `attribute:${s}`), ht(n, a, r), r.getFillerOffset = () => null, t ? Xi(r, n) : r
    }
}

function hA({priority: s, view: e}) {
    return (t, i) => {
        if (!t) return;
        const {writer: n} = i, o = n.createAttributeElement(e, null, {priority: s});
        return ht(n, t, o), o
    }
}

function ji({view: s}, e) {
    return t => {
        t.on(`element:${s}`, (i, n, o) => {
            if (!n.modelRange || n.modelRange.isCollapsed) return;
            const r = e.processViewAttributes(n.viewItem, o);
            r && o.writer.setAttribute(Ge(n.viewItem.name), r, n.modelRange)
        }, {priority: "low"})
    }
}

function Ln({view: s, model: e}) {
    return t => {
        t.on(`attribute:${Ge(s)}:${e}`, (i, n, o) => {
            if (!o.consumable.consume(n.item, i.name)) return;
            const {attributeOldValue: r, attributeNewValue: a} = n, l = o.writer, c = o.mapper.toViewElement(n.item);
            dt(l, r, a, c)
        })
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */var ku = {
    block: [{model: "codeBlock", view: "pre"}, {model: "paragraph", view: "p"}, {
        model: "blockQuote",
        view: "blockquote"
    }, {model: "listItem", view: "li"}, {model: "pageBreak", view: "div"}, {
        model: "rawHtml",
        view: "div"
    }, {model: "table", view: "table"}, {model: "tableRow", view: "tr"}, {
        model: "tableCell",
        view: "td"
    }, {model: "tableCell", view: "th"}, {model: "tableColumnGroup", view: "colgroup"}, {
        model: "tableColumn",
        view: "col"
    }, {model: "caption", view: "caption"}, {model: "caption", view: "figcaption"}, {
        model: "imageBlock",
        view: "img"
    }, {model: "imageInline", view: "img"}, {model: "horizontalLine", view: "hr"}, {
        model: "htmlP",
        view: "p",
        modelSchema: {inheritAllFrom: "$block"}
    }, {model: "htmlBlockquote", view: "blockquote", modelSchema: {inheritAllFrom: "$container"}}, {
        model: "htmlTable",
        view: "table",
        modelSchema: {allowWhere: "$block", isBlock: !0}
    }, {model: "htmlTbody", view: "tbody", modelSchema: {allowIn: "htmlTable", isBlock: !1}}, {
        model: "htmlThead",
        view: "thead",
        modelSchema: {allowIn: "htmlTable", isBlock: !1}
    }, {model: "htmlTfoot", view: "tfoot", modelSchema: {allowIn: "htmlTable", isBlock: !1}}, {
        model: "htmlCaption",
        view: "caption",
        modelSchema: {allowIn: "htmlTable", allowChildren: "$text", isBlock: !1}
    }, {
        model: "htmlColgroup",
        view: "colgroup",
        modelSchema: {allowIn: "htmlTable", allowChildren: "col", isBlock: !1}
    }, {model: "htmlCol", view: "col", modelSchema: {allowIn: "htmlColgroup", isBlock: !1}}, {
        model: "htmlTr",
        view: "tr",
        modelSchema: {allowIn: ["htmlTable", "htmlThead", "htmlTbody"], isLimit: !0}
    }, {
        model: "htmlTd",
        view: "td",
        modelSchema: {allowIn: "htmlTr", allowContentOf: "$container", isLimit: !0, isBlock: !1}
    }, {
        model: "htmlTh",
        view: "th",
        modelSchema: {allowIn: "htmlTr", allowContentOf: "$container", isLimit: !0, isBlock: !1}
    }, {
        model: "htmlFigure",
        view: "figure",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {
        model: "htmlFigcaption",
        view: "figcaption",
        modelSchema: {allowIn: "htmlFigure", allowChildren: "$text", isBlock: !1}
    }, {
        model: "htmlAddress",
        view: "address",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {
        model: "htmlAside",
        view: "aside",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {
        model: "htmlMain",
        view: "main",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {
        model: "htmlDetails",
        view: "details",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {
        model: "htmlSummary",
        view: "summary",
        modelSchema: {
            allowChildren: ["htmlH1", "htmlH2", "htmlH3", "htmlH4", "htmlH5", "htmlH6", "$text"],
            allowIn: "htmlDetails",
            isBlock: !1
        }
    }, {
        model: "htmlDiv",
        view: "div",
        paragraphLikeModel: "htmlDivParagraph",
        modelSchema: {inheritAllFrom: "$container"}
    }, {
        model: "htmlFieldset",
        view: "fieldset",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {
        model: "htmlLegend",
        view: "legend",
        modelSchema: {allowIn: "htmlFieldset", allowChildren: "$text"}
    }, {
        model: "htmlHeader",
        view: "header",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {
        model: "htmlFooter",
        view: "footer",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {
        model: "htmlForm",
        view: "form",
        modelSchema: {inheritAllFrom: "$container", isBlock: !0}
    }, {
        model: "htmlHgroup",
        view: "hgroup",
        modelSchema: {
            allowIn: ["$root", "$container"],
            allowChildren: ["paragraph", "htmlP", "htmlH1", "htmlH2", "htmlH3", "htmlH4", "htmlH5", "htmlH6"],
            isBlock: !1
        }
    }, {model: "htmlH1", view: "h1", modelSchema: {inheritAllFrom: "$block"}}, {
        model: "htmlH2",
        view: "h2",
        modelSchema: {inheritAllFrom: "$block"}
    }, {model: "htmlH3", view: "h3", modelSchema: {inheritAllFrom: "$block"}}, {
        model: "htmlH4",
        view: "h4",
        modelSchema: {inheritAllFrom: "$block"}
    }, {model: "htmlH5", view: "h5", modelSchema: {inheritAllFrom: "$block"}}, {
        model: "htmlH6",
        view: "h6",
        modelSchema: {inheritAllFrom: "$block"}
    }, {
        model: "$htmlList",
        modelSchema: {allowWhere: "$container", allowChildren: ["$htmlList", "htmlLi"], isBlock: !1}
    }, {model: "htmlDir", view: "dir", modelSchema: {inheritAllFrom: "$htmlList"}}, {
        model: "htmlMenu",
        view: "menu",
        modelSchema: {inheritAllFrom: "$htmlList"}
    }, {model: "htmlUl", view: "ul", modelSchema: {inheritAllFrom: "$htmlList"}}, {
        model: "htmlOl",
        view: "ol",
        modelSchema: {inheritAllFrom: "$htmlList"}
    }, {
        model: "htmlLi",
        view: "li",
        modelSchema: {allowIn: "$htmlList", allowChildren: "$text", isBlock: !1}
    }, {model: "htmlPre", view: "pre", modelSchema: {inheritAllFrom: "$block"}}, {
        model: "htmlArticle",
        view: "article",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {
        model: "htmlSection",
        view: "section",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {model: "htmlNav", view: "nav", modelSchema: {inheritAllFrom: "$container", isBlock: !1}}, {
        model: "htmlDivDl",
        view: "div",
        modelSchema: {allowChildren: ["htmlDt", "htmlDd"], allowIn: "htmlDl"}
    }, {
        model: "htmlDl",
        view: "dl",
        modelSchema: {allowWhere: "$container", allowChildren: ["htmlDt", "htmlDd", "htmlDivDl"], isBlock: !1}
    }, {model: "htmlDt", view: "dt", modelSchema: {allowChildren: "$block", isBlock: !1}}, {
        model: "htmlDd",
        view: "dd",
        modelSchema: {allowChildren: "$block", isBlock: !1}
    }, {
        model: "htmlCenter",
        view: "center",
        modelSchema: {inheritAllFrom: "$container", isBlock: !1}
    }, {model: "htmlHr", view: "hr", isEmpty: !0, modelSchema: {inheritAllFrom: "$blockObject"}}],
    inline: [{
        model: "htmlLiAttributes",
        view: "li",
        appliesToBlock: !0,
        coupledAttribute: "listItemId"
    }, {
        model: "htmlOlAttributes",
        view: "ol",
        appliesToBlock: !0,
        coupledAttribute: "listItemId"
    }, {
        model: "htmlUlAttributes",
        view: "ul",
        appliesToBlock: !0,
        coupledAttribute: "listItemId"
    }, {model: "htmlFigureAttributes", view: "figure", appliesToBlock: "table"}, {
        model: "htmlTheadAttributes",
        view: "thead",
        appliesToBlock: "table"
    }, {model: "htmlTbodyAttributes", view: "tbody", appliesToBlock: "table"}, {
        model: "htmlFigureAttributes",
        view: "figure",
        appliesToBlock: "imageBlock"
    }, {
        model: "htmlAcronym",
        view: "acronym",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlTt", view: "tt", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlFont",
        view: "font",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlTime", view: "time", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlVar",
        view: "var",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlBig", view: "big", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlSmall",
        view: "small",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlSamp", view: "samp", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlQ",
        view: "q",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {
        model: "htmlOutput",
        view: "output",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlKbd", view: "kbd", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlBdi",
        view: "bdi",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlBdo", view: "bdo", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlAbbr",
        view: "abbr",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlA", view: "a", priority: 5, coupledAttribute: "linkHref"}, {
        model: "htmlStrong",
        view: "strong",
        coupledAttribute: "bold",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {
        model: "htmlB",
        view: "b",
        coupledAttribute: "bold",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {
        model: "htmlI",
        view: "i",
        coupledAttribute: "italic",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {
        model: "htmlEm",
        view: "em",
        coupledAttribute: "italic",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {
        model: "htmlS",
        view: "s",
        coupledAttribute: "strikethrough",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {
        model: "htmlDel",
        view: "del",
        coupledAttribute: "strikethrough",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlIns", view: "ins", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlU",
        view: "u",
        coupledAttribute: "underline",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {
        model: "htmlSub",
        view: "sub",
        coupledAttribute: "subscript",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {
        model: "htmlSup",
        view: "sup",
        coupledAttribute: "superscript",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {
        model: "htmlCode",
        view: "code",
        coupledAttribute: "code",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlMark", view: "mark", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlSpan",
        view: "span",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlCite", view: "cite", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlLabel",
        view: "label",
        attributeProperties: {copyOnEnter: !0, isFormatting: !0}
    }, {model: "htmlDfn", view: "dfn", attributeProperties: {copyOnEnter: !0, isFormatting: !0}}, {
        model: "htmlObject",
        view: "object",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlIframe",
        view: "iframe",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlInput",
        view: "input",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlButton",
        view: "button",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlTextarea",
        view: "textarea",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlSelect",
        view: "select",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlVideo",
        view: "video",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlEmbed",
        view: "embed",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlOembed",
        view: "oembed",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlAudio",
        view: "audio",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlImg",
        view: "img",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlCanvas",
        view: "canvas",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlMeter",
        view: "meter",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlProgress",
        view: "progress",
        isObject: !0,
        modelSchema: {inheritAllFrom: "$inlineObject"}
    }, {
        model: "htmlScript",
        view: "script",
        modelSchema: {allowWhere: ["$text", "$block"], isInline: !0}
    }, {
        model: "htmlStyle",
        view: "style",
        modelSchema: {allowWhere: ["$text", "$block"], isInline: !0}
    }, {
        model: "htmlCustomElement",
        view: "$customElement",
        modelSchema: {allowWhere: ["$text", "$block"], allowAttributesOf: "$inlineObject", isInline: !0}
    }]
};

class Gi extends w {
    _definitions = [];

    static get pluginName() {
        return "DataSchema"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        for (const e of ku.block) this.registerBlockElement(e);
        for (const e of ku.inline) this.registerInlineElement(e)
    }

    registerBlockElement(e) {
        this._definitions.push({...e, isBlock: !0})
    }

    registerInlineElement(e) {
        this._definitions.push({...e, isInline: !0})
    }

    extendBlockElement(e) {
        this._extendDefinition({...e, isBlock: !0})
    }

    extendInlineElement(e) {
        this._extendDefinition({...e, isInline: !0})
    }

    getDefinitionsForView(e, t = !1) {
        const i = new Set;
        for (const n of this._getMatchingViewDefinitions(e)) {
            if (t) for (const o of this._getReferences(n.model)) i.add(o);
            i.add(n)
        }
        return i
    }

    getDefinitionsForModel(e) {
        return this._definitions.filter(t => t.model == e)
    }

    _getMatchingViewDefinitions(e) {
        return this._definitions.filter(t => t.view && fA(e, t.view))
    }

    * _getReferences(e) {
        const t = ["inheritAllFrom", "inheritTypesFrom", "allowWhere", "allowContentOf", "allowAttributesOf"],
            i = this._definitions.filter(n => n.model == e);
        for (const {modelSchema: n} of i) if (n) for (const o of t) for (const r of U(n[o] || [])) {
            const a = this._definitions.filter(l => l.model == r);
            for (const l of a) r !== e && (yield* this._getReferences(l.model), yield l)
        }
    }

    _extendDefinition(e) {
        const t = Array.from(this._definitions.entries()).filter(([, i]) => i.model == e.model);
        if (t.length == 0) {
            this._definitions.push(e);
            return
        }
        for (const [i, n] of t) this._definitions[i] = Ud({}, n, e, (o, r) => Array.isArray(o) ? o.concat(r) : void 0)
    }
}

function fA(s, e) {
    return typeof s == "string" ? s === e : s instanceof RegExp ? s.test(e) : !1
}

class ee extends w {
    _dataSchema;
    _allowedAttributes;
    _disallowedAttributes;
    _allowedElements;
    _disallowedElements;
    _dataInitialized;
    _coupledAttributes;

    constructor(e) {
        super(e), this._dataSchema = e.plugins.get("DataSchema"), this._allowedAttributes = new He, this._disallowedAttributes = new He, this._allowedElements = new Set, this._disallowedElements = new Set, this._dataInitialized = !1, this._coupledAttributes = null, this._registerElementsAfterInit(), this._registerElementHandlers(), this._registerCoupledAttributesPostFixer(), this._registerAssociatedHtmlAttributesPostFixer()
    }

    static get pluginName() {
        return "DataFilter"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Gi, di]
    }

    loadAllowedConfig(e) {
        for (const t of e) {
            const i = t.name || /[\s\S]+/, n = Eu(t);
            this.allowElement(i), n.forEach(o => this.allowAttributes(o))
        }
    }

    loadDisallowedConfig(e) {
        for (const t of e) {
            const i = t.name || /[\s\S]+/, n = Eu(t);
            n.length == 0 ? this.disallowElement(i) : n.forEach(o => this.disallowAttributes(o))
        }
    }

    loadAllowedEmptyElementsConfig(e) {
        for (const t of e) this.allowEmptyElement(t)
    }

    allowElement(e) {
        for (const t of this._dataSchema.getDefinitionsForView(e, !0)) this._addAllowedElement(t), this._coupledAttributes = null
    }

    disallowElement(e) {
        for (const t of this._dataSchema.getDefinitionsForView(e, !1)) this._disallowedElements.add(t.view)
    }

    allowEmptyElement(e) {
        for (const t of this._dataSchema.getDefinitionsForView(e, !0)) t.isInline && this._dataSchema.extendInlineElement({
            ...t,
            allowEmpty: !0
        })
    }

    allowAttributes(e) {
        this._allowedAttributes.add(e)
    }

    disallowAttributes(e) {
        this._disallowedAttributes.add(e)
    }

    processViewAttributes(e, t) {
        const {consumable: i} = t;
        return Cu(e, this._disallowedAttributes, i), mA(e, Cu(e, this._allowedAttributes, i))
    }

    _addAllowedElement(e) {
        if (!this._allowedElements.has(e)) {
            if (this._allowedElements.add(e), "appliesToBlock" in e && typeof e.appliesToBlock == "string") for (const t of this._dataSchema.getDefinitionsForModel(e.appliesToBlock)) t.isBlock && this._addAllowedElement(t);
            this._dataInitialized && this.editor.data.once("set", () => {
                this._fireRegisterEvent(e)
            }, {priority: Le.highest + 1})
        }
    }

    _registerElementsAfterInit() {
        this.editor.data.on("init", () => {
            this._dataInitialized = !0;
            for (const e of this._allowedElements) this._fireRegisterEvent(e)
        }, {priority: Le.highest + 1})
    }

    _registerElementHandlers() {
        this.on("register", (e, t) => {
            const i = this.editor.model.schema;
            if (t.isObject && !i.isRegistered(t.model)) this._registerObjectElement(t); else if (t.isBlock) this._registerBlockElement(t); else if (t.isInline) this._registerInlineElement(t); else throw new p("data-filter-invalid-definition", null, t);
            e.stop()
        }, {priority: "lowest"})
    }

    _registerCoupledAttributesPostFixer() {
        const e = this.editor.model, t = e.document.selection;
        e.document.registerPostFixer(i => {
            const n = e.document.differ.getChanges();
            let o = !1;
            const r = this._getCoupledAttributesMap();
            for (const a of n) {
                if (a.type != "attribute" || a.attributeNewValue !== null) continue;
                const l = r.get(a.attributeKey);
                if (l) for (const {item: c} of a.range.getWalker()) for (const u of l) c.hasAttribute(u) && (i.removeAttribute(u, c), o = !0)
            }
            return o
        }), this.listenTo(t, "change:attribute", (i, {attributeKeys: n}) => {
            const o = new Set, r = this._getCoupledAttributesMap();
            for (const a of n) {
                if (t.hasAttribute(a)) continue;
                const l = r.get(a);
                if (l) for (const c of l) t.hasAttribute(c) && o.add(c)
            }
            o.size != 0 && e.change(a => {
                for (const l of o) a.removeSelectionAttribute(l)
            })
        })
    }

    _registerAssociatedHtmlAttributesPostFixer() {
        const e = this.editor.model;
        e.document.registerPostFixer(t => {
            const i = e.document.differ.getChanges();
            let n = !1;
            for (const o of i) if (!(o.type !== "insert" || o.name === "$text")) for (const r of o.attributes.keys()) !r.startsWith("html") || !r.endsWith("Attributes") || e.schema.checkAttribute(o.name, r) || (t.removeAttribute(r, o.position.nodeAfter), n = !0);
            return n
        })
    }

    _getCoupledAttributesMap() {
        if (this._coupledAttributes) return this._coupledAttributes;
        this._coupledAttributes = new Map;
        for (const e of this._allowedElements) if (e.coupledAttribute && e.model) {
            const t = this._coupledAttributes.get(e.coupledAttribute);
            t ? t.push(e.model) : this._coupledAttributes.set(e.coupledAttribute, [e.model])
        }
        return this._coupledAttributes
    }

    _fireRegisterEvent(e) {
        e.view && this._disallowedElements.has(e.view) || this.fire(e.view ? `register:${e.view}` : "register", e)
    }

    _registerObjectElement(e) {
        const t = this.editor, i = t.model.schema, n = t.conversion, {view: o, model: r} = e;
        i.register(r, e.modelSchema);/* istanbul ignore next: paranoid check -- @preserve */
        o && (i.extend(e.model, {allowAttributes: [Ge(o), "htmlContent"]}), t.data.registerRawContentMatcher({name: o}), n.for("upcast").elementToElement({
            view: o,
            model: xa(e),
            converterPriority: Le.low + 2
        }), n.for("upcast").add(ji(e, this)), n.for("editingDowncast").elementToStructure({
            model: {
                name: r,
                attributes: [Ge(o)]
            }, view: uA(t, e)
        }), n.for("dataDowncast").elementToElement({
            model: r,
            view: (a, {writer: l}) => ho(o, a, l)
        }), n.for("dataDowncast").add(Ln(e)))
    }

    _registerBlockElement(e) {
        const t = this.editor, i = t.model.schema, n = t.conversion, {view: o, model: r} = e;
        if (!i.isRegistered(e.model)) {
            if (!e.modelSchema || (i.register(e.model, e.modelSchema), !o)) return;
            n.for("upcast").elementToElement({
                model: r,
                view: o,
                converterPriority: Le.low + 2
            }), n.for("downcast").elementToElement({
                model: r,
                view: (a, {writer: l}) => e.isEmpty ? l.createEmptyElement(o) : l.createContainerElement(o)
            })
        }
        o && (i.extend(e.model, {allowAttributes: Ge(o)}), n.for("upcast").add(ji(e, this)), n.for("downcast").add(Ln(e)))
    }

    _registerInlineElement(e) {
        const t = this.editor, i = t.model.schema, n = t.conversion, o = e.model;
        if (!e.appliesToBlock && (i.extend("$text", {allowAttributes: o}), e.attributeProperties && i.setAttributeProperties(o, e.attributeProperties), n.for("upcast").add(dA(e, this)), n.for("downcast").attributeToElement({
            model: o,
            view: hA(e)
        }), !!e.allowEmpty)) {
            if (i.setAttributeProperties(o, {copyFromObject: !1}), !i.isRegistered("htmlEmptyElement")) {
                i.register("htmlEmptyElement", {inheritAllFrom: "$inlineObject"});
                const r = a => Array.from(a.getAttributeKeys()).some(l => l.startsWith("html"));
                t.model.document.registerPostFixer(a => {
                    const l = t.model.document.differ.getChanges(), c = new Set;
                    for (const u of l) if (u.type !== "remove") {
                        if (u.type === "attribute" && u.attributeNewValue === null) for (const {item: d} of u.range) d.is("element", "htmlEmptyElement") && !r(d) && c.add(d);
                        if (u.type === "insert" && u.position.nodeAfter) {
                            const d = u.position.nodeAfter;
                            for (const {item: h} of a.createRangeOn(d)) h.is("element", "htmlEmptyElement") && !r(h) && c.add(h)
                        }
                    }
                    for (const u of c) a.remove(u);
                    return c.size > 0
                })
            }
            t.data.htmlProcessor.domConverter.registerInlineObjectMatcher(r => r.name == e.view && r.isEmpty && Array.from(r.getAttributeKeys()).length ? {name: !0} : null), n.for("editingDowncast").elementToElement({
                model: "htmlEmptyElement",
                view: yu(e, !0)
            }), n.for("dataDowncast").elementToElement({model: "htmlEmptyElement", view: yu(e)})
        }
    }
}

function Cu(s, e, t) {
    const i = e.matchAll(s) || [], n = s.document.stylesProcessor;
    return i.reduce((o, {match: r}) => {
        for (const [a, l] of r.attributes || []) if (a == "style") {
            const c = l,
                u = n.getRelatedStyles(c).filter(d => d.split("-").length > c.split("-").length).sort((d, h) => h.split("-").length - d.split("-").length);
            for (const d of u) t.consume(s, {styles: [d]}) && o.styles.push(d);
            t.consume(s, {styles: [c]}) && o.styles.push(c)
        } else if (a == "class") {
            const c = l;
            t.consume(s, {classes: [c]}) && o.classes.push(c)
        } else t.consume(s, {attributes: [a]}) && o.attributes.push(a);
        return o
    }, {attributes: [], classes: [], styles: []})
}

function mA(s, {attributes: e, classes: t, styles: i}) {
    return !e.length && !t.length && !i.length ? null : {...e.length && {attributes: gA(s, e)}, ...i.length && {styles: pA(s, i)}, ...t.length && {classes: t}}
}

function gA(s, e) {
    const t = {};
    for (const i of e) {
        const n = s.getAttribute(i);
        n !== void 0 && ch(i) && (t[i] = n)
    }
    return t
}

function pA(s, e) {
    const t = new Fi(s.document.stylesProcessor);
    for (const i of e) {
        const n = s.getStyle(i);
        n !== void 0 && t.set(i, n)
    }
    return Object.fromEntries(t.getStylesEntries())
}

function Zo(s, e) {
    const {name: t} = s, i = s[e];
    return Xe(i) ? Object.entries(i).map(([n, o]) => ({
        name: t,
        [e]: {[n]: o}
    })) : Array.isArray(i) ? i.map(n => ({name: t, [e]: [n]})) : [s]
}

function Eu(s) {
    const {name: e, attributes: t, classes: i, styles: n} = s, o = [];
    return t && o.push(...Zo({name: e, attributes: t}, "attributes")), i && o.push(...Zo({
        name: e,
        classes: i
    }, "classes")), n && o.push(...Zo({name: e, styles: n}, "styles")), o
}

class wA extends w {
    static get requires() {
        return [ee]
    }

    static get pluginName() {
        return "CodeBlockElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        if (!this.editor.plugins.has("CodeBlockEditing")) return;
        const e = this.editor.plugins.get(ee);
        e.on("register:pre", (t, i) => {
            if (i.model !== "codeBlock") return;
            const n = this.editor, o = n.model.schema, r = n.conversion;
            o.extend("codeBlock", {allowAttributes: ["htmlPreAttributes", "htmlContentAttributes"]}), r.for("upcast").add(bA(e)), r.for("downcast").add(_A()), t.stop()
        })
    }
}

function bA(s) {
    return e => {
        e.on("element:code", (t, i, n) => {
            const o = i.viewItem, r = o.parent;
            if (!r || !r.is("element", "pre")) return;
            a(r, "htmlPreAttributes"), a(o, "htmlContentAttributes");

            function a(l, c) {
                const u = s.processViewAttributes(l, n);
                u && n.writer.setAttribute(c, u, i.modelRange)
            }
        }, {priority: "low"})
    }
}

function _A() {
    return s => {
        s.on("attribute:htmlPreAttributes:codeBlock", (e, t, i) => {
            if (!i.consumable.consume(t.item, e.name)) return;
            const {attributeOldValue: n, attributeNewValue: o} = t, a = i.mapper.toViewElement(t.item).parent;
            dt(i.writer, n, o, a)
        }), s.on("attribute:htmlContentAttributes:codeBlock", (e, t, i) => {
            if (!i.consumable.consume(t.item, e.name)) return;
            const {attributeOldValue: n, attributeNewValue: o} = t, r = i.mapper.toViewElement(t.item);
            dt(i.writer, n, o, r)
        })
    }
}

class vA extends w {
    static get requires() {
        return [ee]
    }

    static get pluginName() {
        return "DualContentModelElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        this.editor.plugins.get(ee).on("register", (t, i) => {
            const n = i, o = this.editor, r = o.model.schema, a = o.conversion;
            if (!n.paragraphLikeModel || r.isRegistered(n.model) || r.isRegistered(n.paragraphLikeModel)) return;
            const l = {model: n.paragraphLikeModel, view: n.view};
            r.register(n.model, n.modelSchema), r.register(l.model, {inheritAllFrom: "$block"}), a.for("upcast").elementToElement({
                view: n.view,
                model: (c, {writer: u}) => this._hasBlockContent(c) ? u.createElement(n.model) : u.createElement(l.model),
                converterPriority: Le.low + .5
            }), a.for("downcast").elementToElement({
                view: n.view,
                model: n.model
            }), this._addAttributeConversion(n), a.for("downcast").elementToElement({
                view: l.view,
                model: l.model
            }), this._addAttributeConversion(l), t.stop()
        })
    }

    _hasBlockContent(e) {
        const t = this.editor.editing.view, i = t.domConverter.blockElements;
        for (const n of t.createRangeIn(e).getItems()) if (n.is("element") && i.includes(n.name)) return !0;
        return !1
    }

    _addAttributeConversion(e) {
        const t = this.editor, i = t.conversion, n = t.plugins.get(ee);
        t.model.schema.extend(e.model, {allowAttributes: Ge(e.view)}), i.for("upcast").add(ji(e, n)), i.for("downcast").add(Ln(e))
    }
}

class yA extends w {
    static get requires() {
        return [Gi, Gn]
    }

    static get pluginName() {
        return "HeadingElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        if (!e.plugins.has("HeadingEditing")) return;
        const t = e.config.get("heading.options");
        this.registerHeadingElements(e, t)
    }

    registerHeadingElements(e, t) {
        const i = e.plugins.get(Gi), n = [];
        for (const o of t) "model" in o && "view" in o && (i.registerBlockElement({
            view: o.view,
            model: o.model
        }), n.push(o.model));
        i.extendBlockElement({
            model: "htmlHgroup",
            modelSchema: {allowChildren: n}
        }), i.extendBlockElement({model: "htmlSummary", modelSchema: {allowChildren: n}})
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Dn(s, e, t) {
    const i = s.createRangeOn(e);
    for (const {item: n} of i.getWalker()) if (n.is("element", t)) return n
}

class kA extends w {
    static get requires() {
        return [ee]
    }

    static get pluginName() {
        return "ImageElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        if (!e.plugins.has("ImageInlineEditing") && !e.plugins.has("ImageBlockEditing")) return;
        const t = e.model.schema, i = e.conversion, n = e.plugins.get(ee);
        n.on("register:figure", () => {
            i.for("upcast").add(TA(n))
        }), n.on("register:img", (o, r) => {
            r.model !== "imageBlock" && r.model !== "imageInline" || (t.isRegistered("imageBlock") && t.extend("imageBlock", {allowAttributes: ["htmlImgAttributes", "htmlFigureAttributes", "htmlLinkAttributes"]}), t.isRegistered("imageInline") && t.extend("imageInline", {allowAttributes: ["htmlA", "htmlImgAttributes"]}), i.for("upcast").add(CA(n)), i.for("downcast").add(AA()), e.plugins.has("LinkImage") && i.for("upcast").add(EA(n, e)), o.stop())
        })
    }
}

function CA(s) {
    return e => {
        e.on("element:img", (t, i, n) => {
            if (!i.modelRange) return;
            const o = i.viewItem, r = s.processViewAttributes(o, n);
            r && n.writer.setAttribute("htmlImgAttributes", r, i.modelRange)
        }, {priority: "low"})
    }
}

function EA(s, e) {
    const t = e.plugins.get("ImageUtils");
    return i => {
        i.on("element:a", (n, o, r) => {
            const a = o.viewItem;
            if (!t.findViewImgElement(a)) return;
            const c = o.modelCursor.parent;
            if (!c.is("element", "imageBlock")) return;
            const u = s.processViewAttributes(a, r);
            u && r.writer.setAttribute("htmlLinkAttributes", u, c)
        }, {priority: "low"})
    }
}

function TA(s) {
    return e => {
        e.on("element:figure", (t, i, n) => {
            const o = i.viewItem;
            if (!i.modelRange || !o.hasClass("image")) return;
            const r = s.processViewAttributes(o, n);
            r && n.writer.setAttribute("htmlFigureAttributes", r, i.modelRange)
        }, {priority: "low"})
    }
}

function AA() {
    return s => {
        e("htmlImgAttributes"), t("img", "htmlImgAttributes"), t("figure", "htmlFigureAttributes"), t("a", "htmlLinkAttributes");

        function e(i) {
            s.on(`attribute:${i}:imageInline`, (n, o, r) => {
                if (!r.consumable.consume(o.item, n.name)) return;
                const {attributeOldValue: a, attributeNewValue: l} = o, c = r.mapper.toViewElement(o.item);
                dt(r.writer, a, l, c)
            }, {priority: "low"})
        }

        function t(i, n) {
            s.on(`attribute:${n}:imageBlock`, (o, r, a) => {
                if (!a.consumable.test(r.item, o.name)) return;
                const {attributeOldValue: l, attributeNewValue: c} = r, u = a.mapper.toViewElement(r.item),
                    d = Dn(a.writer, u, i);
                d && (dt(a.writer, l, c, d), a.consumable.consume(r.item, o.name))
            }, {priority: "low"}), i === "a" && s.on("attribute:linkHref:imageBlock", (o, r, a) => {
                if (!a.consumable.consume(r.item, "attribute:htmlLinkAttributes:imageBlock")) return;
                const l = a.mapper.toViewElement(r.item), c = Dn(a.writer, l, "a");
                ht(a.writer, r.item.getAttribute("htmlLinkAttributes"), c)
            }, {priority: "low"})
        }
    }
}

class xA extends w {
    static get requires() {
        return [ee]
    }

    static get pluginName() {
        return "MediaEmbedElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        if (!e.plugins.has("MediaEmbed") || e.config.get("mediaEmbed.previewsInData")) return;
        const t = e.model.schema, i = e.conversion, n = this.editor.plugins.get(ee), o = this.editor.plugins.get(Gi),
            r = e.config.get("mediaEmbed.elementName");
        o.registerBlockElement({model: "media", view: r}), n.on("register:figure", () => {
            i.for("upcast").add(SA(n))
        }), n.on(`register:${r}`, (a, l) => {
            l.model === "media" && (t.extend("media", {allowAttributes: [Ge(r), "htmlFigureAttributes"]}), i.for("upcast").add(IA(n, r)), i.for("dataDowncast").add(PA(r)), a.stop())
        })
    }
}

function IA(s, e) {
    const t = (i, n, o) => {
        const r = n.viewItem;
        a(r, Ge(e));

        function a(l, c) {
            const u = s.processViewAttributes(l, o);
            u && o.writer.setAttribute(c, u, n.modelRange)
        }
    };
    return i => {
        i.on(`element:${e}`, t, {priority: "low"})
    }
}

function SA(s) {
    return e => {
        e.on("element:figure", (t, i, n) => {
            const o = i.viewItem;
            if (!i.modelRange || !o.hasClass("media")) return;
            const r = s.processViewAttributes(o, n);
            r && n.writer.setAttribute("htmlFigureAttributes", r, i.modelRange)
        }, {priority: "low"})
    }
}

function PA(s) {
    return e => {
        t(s, Ge(s)), t("figure", "htmlFigureAttributes");

        function t(i, n) {
            e.on(`attribute:${n}:media`, (o, r, a) => {
                if (!a.consumable.consume(r.item, o.name)) return;
                const {attributeOldValue: l, attributeNewValue: c} = r, u = a.mapper.toViewElement(r.item),
                    d = Dn(a.writer, u, i);
                dt(a.writer, l, c, d)
            })
        }
    }
}

class RA extends w {
    static get requires() {
        return [ee]
    }

    static get pluginName() {
        return "ScriptElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor.plugins.get(ee);
        e.on("register:script", (t, i) => {
            const n = this.editor, o = n.model.schema, r = n.conversion;
            o.register("htmlScript", i.modelSchema), o.extend("htmlScript", {
                allowAttributes: ["htmlScriptAttributes", "htmlContent"],
                isContent: !0
            }), n.data.registerRawContentMatcher({name: "script"}), r.for("upcast").elementToElement({
                view: "script",
                model: xa(i)
            }), r.for("upcast").add(ji(i, e)), r.for("downcast").elementToElement({
                model: "htmlScript",
                view: (a, {writer: l}) => ho("script", a, l)
            }), r.for("downcast").add(Ln(i)), t.stop()
        })
    }
}

const VA = ["width", "max-width", "min-width", "height", "min-height", "max-height"];

class OA extends w {
    static get requires() {
        return [ee]
    }

    static get pluginName() {
        return "TableElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        if (!e.plugins.has("TableEditing")) return;
        const t = e.model.schema, i = e.conversion, n = e.plugins.get(ee), o = e.plugins.get("TableUtils");
        n.on("register:figure", () => {
            i.for("upcast").add(FA(n))
        }), n.on("register:table", (r, a) => {
            a.model === "table" && (t.extend("table", {allowAttributes: ["htmlTableAttributes", "htmlFigureAttributes", "htmlTheadAttributes", "htmlTbodyAttributes"]}), i.for("upcast").add(BA(n)), i.for("downcast").add(LA()), e.model.document.registerPostFixer(MA(e.model, o)), r.stop())
        })
    }
}

function MA(s, e) {
    return t => {
        const i = s.document.differ.getChanges();
        let n = !1;
        for (const o of i) {
            if (o.type != "attribute" || o.attributeKey != "headingRows") continue;
            const r = o.range.start.nodeAfter, a = r.getAttribute("htmlTheadAttributes"),
                l = r.getAttribute("htmlTbodyAttributes");
            a && !o.attributeNewValue ? (t.removeAttribute("htmlTheadAttributes", r), n = !0) : l && o.attributeNewValue == e.getRows(r) && (t.removeAttribute("htmlTbodyAttributes", r), n = !0)
        }
        return n
    }
}

function BA(s) {
    return e => {
        e.on("element:table", (t, i, n) => {
            if (!i.modelRange) return;
            const o = i.viewItem;
            r(o, "htmlTableAttributes");
            for (const a of o.getChildren()) a.is("element", "thead") && r(a, "htmlTheadAttributes"), a.is("element", "tbody") && r(a, "htmlTbodyAttributes");

            function r(a, l) {
                const c = s.processViewAttributes(a, n);
                c && n.writer.setAttribute(l, c, i.modelRange)
            }
        }, {priority: "low"})
    }
}

function FA(s) {
    return e => {
        e.on("element:figure", (t, i, n) => {
            const o = i.viewItem;
            if (!i.modelRange || !o.hasClass("table")) return;
            const r = s.processViewAttributes(o, n);
            r && n.writer.setAttribute("htmlFigureAttributes", r, i.modelRange)
        }, {priority: "low"})
    }
}

function LA() {
    return s => {
        e("table", "htmlTableAttributes"), e("figure", "htmlFigureAttributes"), e("thead", "htmlTheadAttributes"), e("tbody", "htmlTbodyAttributes");

        function e(t, i) {
            s.on(`attribute:${i}:table`, (n, o, r) => {
                if (!r.consumable.test(o.item, n.name)) return;
                const a = r.mapper.toViewElement(o.item), l = Dn(r.writer, a, t);
                if (l) if (r.consumable.consume(o.item, n.name), i === "htmlTableAttributes" && a !== l) {
                    const c = Tu(o.attributeOldValue), u = Tu(o.attributeNewValue);
                    dt(r.writer, c.tableAttributes, u.tableAttributes, l), dt(r.writer, c.figureAttributes, u.figureAttributes, a)
                } else dt(r.writer, o.attributeOldValue, o.attributeNewValue, l)
            })
        }
    }
}

function Tu(s) {
    const e = {}, t = {...s};
    if (!s || !("styles" in s)) return {figureAttributes: e, tableAttributes: t};
    t.styles = {};
    for (const [i, n] of Object.entries(s.styles)) VA.includes(i) ? e.styles = {
        ...e.styles,
        [i]: n
    } : t.styles = {...t.styles, [i]: n};
    return {figureAttributes: e, tableAttributes: t}
}

class DA extends w {
    static get requires() {
        return [ee]
    }

    static get pluginName() {
        return "StyleElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor.plugins.get(ee);
        e.on("register:style", (t, i) => {
            const n = this.editor, o = n.model.schema, r = n.conversion;
            o.register("htmlStyle", i.modelSchema), o.extend("htmlStyle", {
                allowAttributes: ["htmlStyleAttributes", "htmlContent"],
                isContent: !0
            }), n.data.registerRawContentMatcher({name: "style"}), r.for("upcast").elementToElement({
                view: "style",
                model: xa(i)
            }), r.for("upcast").add(ji(i, e)), r.for("downcast").elementToElement({
                model: "htmlStyle",
                view: (a, {writer: l}) => ho("style", a, l)
            }), r.for("downcast").add(Ln(i)), t.stop()
        })
    }
}

class NA extends w {
    static get requires() {
        return [ee]
    }

    static get pluginName() {
        return "ListElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        if (!e.plugins.has("ListEditing")) return;
        const t = e.model.schema, i = e.conversion, n = e.plugins.get(ee), o = e.plugins.get("ListEditing"),
            r = e.plugins.get("ListUtils"), a = ["ul", "ol", "li"];
        o.registerDowncastStrategy({
            scope: "item",
            attributeName: "htmlLiAttributes",
            setAttributeOnDowncast: ht
        }), o.registerDowncastStrategy({
            scope: "list",
            attributeName: "htmlUlAttributes",
            setAttributeOnDowncast: ht
        }), o.registerDowncastStrategy({
            scope: "list",
            attributeName: "htmlOlAttributes",
            setAttributeOnDowncast: ht
        }), n.on("register", (l, c) => {
            if (!a.includes(c.view) || (l.stop(), t.checkAttribute("$block", "htmlLiAttributes"))) return;
            const u = a.map(d => Ge(d));
            t.extend("$listItem", {allowAttributes: u}), i.for("upcast").add(d => {
                d.on("element:ul", Jo("htmlUlAttributes", n), {priority: "low"}), d.on("element:ol", Jo("htmlOlAttributes", n), {priority: "low"}), d.on("element:li", Jo("htmlLiAttributes", n), {priority: "low"})
            })
        }), o.on("postFixer", (l, {listNodes: c, writer: u}) => {
            for (const {node: d, previousNodeInList: h} of c) if (h) {
                if (h.getAttribute("listType") == d.getAttribute("listType")) {
                    const f = Au(h.getAttribute("listType")), m = h.getAttribute(f);
                    !Ps(d.getAttribute(f), m) && u.model.schema.checkAttribute(d, f) && (u.setAttribute(f, m, d), l.return = !0)
                }
                if (h.getAttribute("listItemId") == d.getAttribute("listItemId")) {
                    const f = h.getAttribute("htmlLiAttributes");
                    !Ps(d.getAttribute("htmlLiAttributes"), f) && u.model.schema.checkAttribute(d, "htmlLiAttributes") && (u.setAttribute("htmlLiAttributes", f, d), l.return = !0)
                }
            }
        }), o.on("postFixer", (l, {listNodes: c, writer: u}) => {
            for (const {node: d} of c) {
                const h = d.getAttribute("listType");
                !r.isNumberedListType(h) && d.getAttribute("htmlOlAttributes") && (u.removeAttribute("htmlOlAttributes", d), l.return = !0), r.isNumberedListType(h) && d.getAttribute("htmlUlAttributes") && (u.removeAttribute("htmlUlAttributes", d), l.return = !0)
            }
        })
    }

    afterInit() {
        const e = this.editor;
        if (!e.commands.get("indentList")) return;
        const t = e.commands.get("indentList");
        this.listenTo(t, "afterExecute", (i, n) => {
            e.model.change(o => {
                for (const r of n) {
                    const a = Au(r.getAttribute("listType"));
                    e.model.schema.checkAttribute(r, a) && o.setAttribute(a, {}, r)
                }
            })
        })
    }
}

function Jo(s, e) {
    return (t, i, n) => {
        const o = i.viewItem;
        i.modelRange || Object.assign(i, n.convertChildren(i.viewItem, i.modelCursor));
        const r = e.processViewAttributes(o, n);
        for (const a of i.modelRange.getItems({shallow: !0})) a.hasAttribute("listItemId") && (a.hasAttribute("htmlUlAttributes") || a.hasAttribute("htmlOlAttributes") || n.writer.model.schema.checkAttribute(a, s) && n.writer.setAttribute(s, r || {}, a))
    }
}

function Au(s) {
    return s === "numbered" || s == "customNumbered" ? "htmlOlAttributes" : "htmlUlAttributes"
}

class zA extends w {
    static get requires() {
        return [ee]
    }

    static get pluginName() {
        return "HorizontalLineElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        if (!e.plugins.has("HorizontalLineEditing")) return;
        const t = e.model.schema, i = e.conversion, n = e.plugins.get(ee);
        n.on("register:hr", (o, r) => {
            r.model === "horizontalLine" && (t.extend("horizontalLine", {allowAttributes: ["htmlHrAttributes"]}), i.for("upcast").add(ji(r, n)), i.for("downcast").add(HA()), o.stop())
        })
    }
}

function HA() {
    return s => {
        s.on("attribute:htmlHrAttributes:horizontalLine", (e, t, i) => {
            if (!i.consumable.test(t.item, e.name)) return;
            const {attributeOldValue: n, attributeNewValue: o} = t, r = i.mapper.toViewElement(t.item),
                a = Dn(i.writer, r, "hr");
            a && (dt(i.writer, n, o, a), i.consumable.consume(t.item, e.name))
        }, {priority: "low"})
    }
}

class UA extends w {
    static get requires() {
        return [ee, Gi]
    }

    static get pluginName() {
        return "CustomElementSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor.plugins.get(ee), t = this.editor.plugins.get(Gi);
        e.on("register:$customElement", (i, n) => {
            i.stop();
            const o = this.editor, r = o.model.schema, a = o.conversion, l = o.editing.view.domConverter.unsafeElements,
                c = o.data.htmlProcessor.domConverter.preElements;
            r.register(n.model, n.modelSchema), r.extend(n.model, {
                allowAttributes: ["htmlElementName", "htmlCustomElementAttributes", "htmlContent"],
                isContent: !0
            }), o.data.htmlProcessor.domConverter.registerRawContentMatcher({name: "template"}), a.for("upcast").elementToElement({
                view: /.*/,
                model: (u, d) => {
                    if (u.name == "$comment" || !$A(u.name) || t.getDefinitionsForView(u.name).size) return null;
                    l.includes(u.name) || l.push(u.name), c.includes(u.name) || c.push(u.name);
                    const h = d.writer.createElement(n.model, {htmlElementName: u.name}),
                        f = e.processViewAttributes(u, d);
                    f && d.writer.setAttribute("htmlCustomElementAttributes", f, h);
                    let m;
                    if (u.is("element", "template") && u.getCustomProperty("$rawContent")) m = u.getCustomProperty("$rawContent"); else {
                        const _ = new pt(u.document).createDocumentFragment(u),
                            v = o.data.htmlProcessor.domConverter.viewToDom(_), E = v.firstChild;
                        for (; E.firstChild;) v.appendChild(E.firstChild);
                        E.remove(), m = o.data.htmlProcessor.htmlWriter.getHtml(v)
                    }
                    d.writer.setAttribute("htmlContent", m, h);
                    for (const {item: g} of o.editing.view.createRangeIn(u)) d.consumable.consume(g, {name: !0});
                    return h
                },
                converterPriority: "low"
            }), a.for("editingDowncast").elementToElement({
                model: {
                    name: n.model,
                    attributes: ["htmlElementName", "htmlCustomElementAttributes", "htmlContent"]
                }, view: (u, {writer: d}) => {
                    const h = u.getAttribute("htmlElementName"), f = d.createRawElement(h);
                    return u.hasAttribute("htmlCustomElementAttributes") && ht(d, u.getAttribute("htmlCustomElementAttributes"), f), f
                }
            }), a.for("dataDowncast").elementToElement({
                model: {
                    name: n.model,
                    attributes: ["htmlElementName", "htmlCustomElementAttributes", "htmlContent"]
                }, view: (u, {writer: d}) => {
                    const h = u.getAttribute("htmlElementName"), f = u.getAttribute("htmlContent"),
                        m = d.createRawElement(h, null, (g, _) => {
                            _.setContentOf(g, f)
                        });
                    return u.hasAttribute("htmlCustomElementAttributes") && ht(d, u.getAttribute("htmlCustomElementAttributes"), m), m
                }
            })
        })
    }
}

function $A(s) {
    try {
        document.createElement(s)
    } catch {
        return !1
    }
    return !0
}

class WA extends w {
    static get pluginName() {
        return "GeneralHtmlSupport"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [ee, wA, vA, yA, kA, xA, RA, OA, DA, NA, zA, UA]
    }

    init() {
        const e = this.editor, t = e.plugins.get(ee);
        t.loadAllowedEmptyElementsConfig(e.config.get("htmlSupport.allowEmpty") || []), t.loadAllowedConfig(e.config.get("htmlSupport.allow") || []), t.loadDisallowedConfig(e.config.get("htmlSupport.disallow") || [])
    }

    getGhsAttributeNameForElement(e) {
        const t = this.editor.plugins.get("DataSchema"), i = Array.from(t.getDefinitionsForView(e, !1)),
            n = i.find(o => o.isInline && !i[0].isObject);
        return n ? n.model : Ge(e)
    }

    addModelHtmlClass(e, t, i) {
        const n = this.editor.model, o = this.getGhsAttributeNameForElement(e);
        n.change(r => {
            for (const a of Ei(n, i, o)) Ci(r, a, o, "classes", l => {
                for (const c of U(t)) l.add(c)
            })
        })
    }

    removeModelHtmlClass(e, t, i) {
        const n = this.editor.model, o = this.getGhsAttributeNameForElement(e);
        n.change(r => {
            for (const a of Ei(n, i, o)) Ci(r, a, o, "classes", l => {
                for (const c of U(t)) l.delete(c)
            })
        })
    }

    setModelHtmlAttributes(e, t, i) {
        const n = this.editor.model, o = this.getGhsAttributeNameForElement(e);
        n.change(r => {
            for (const a of Ei(n, i, o)) Ci(r, a, o, "attributes", l => {
                for (const [c, u] of Object.entries(t)) l.set(c, u)
            })
        })
    }

    removeModelHtmlAttributes(e, t, i) {
        const n = this.editor.model, o = this.getGhsAttributeNameForElement(e);
        n.change(r => {
            for (const a of Ei(n, i, o)) Ci(r, a, o, "attributes", l => {
                for (const c of U(t)) l.delete(c)
            })
        })
    }

    setModelHtmlStyles(e, t, i) {
        const n = this.editor.model, o = this.getGhsAttributeNameForElement(e);
        n.change(r => {
            for (const a of Ei(n, i, o)) Ci(r, a, o, "styles", l => {
                for (const [c, u] of Object.entries(t)) l.set(c, u)
            })
        })
    }

    removeModelHtmlStyles(e, t, i) {
        const n = this.editor.model, o = this.getGhsAttributeNameForElement(e);
        n.change(r => {
            for (const a of Ei(n, i, o)) Ci(r, a, o, "styles", l => {
                for (const c of U(t)) l.delete(c)
            })
        })
    }
}

function* Ei(s, e, t) {
    if (e) if (!(Symbol.iterator in e) && e.is("documentSelection") && e.isCollapsed) s.schema.checkAttributeInSelection(e, t) && (yield e); else for (const i of qA(s, e, t)) yield* i.getItems({shallow: !0})
}

function qA(s, e, t) {
    return !(Symbol.iterator in e) && (e.is("node") || e.is("$text") || e.is("$textProxy")) ? s.schema.checkAttribute(e, t) ? [s.createRangeOn(e)] : [] : s.schema.getValidRanges(s.createSelection(e).getRanges(), t)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function jA(s) {
    return s.createContainerElement("span", {class: "image-inline"}, s.createEmptyElement("img"))
}

function xu(s) {
    return s.createContainerElement("figure", {class: "image"}, [s.createEmptyElement("img"), s.createSlot("children")])
}

function Am(s, e) {
    const t = s.plugins.get("ImageUtils"),
        i = s.plugins.has("ImageInlineEditing") && s.plugins.has("ImageBlockEditing");
    return o => t.isInlineImageView(o) ? i && (o.getStyle("display") == "block" || o.findAncestor(t.isBlockImageView) ? "imageBlock" : "imageInline") !== e ? null : n(o) : null;

    function n(o) {
        const r = {name: !0};
        return o.hasAttribute("src") && (r.attributes = ["src"]), r
    }
}

function Ia(s, e) {
    const t = re(e.getSelectedBlocks());
    return !t || s.isObject(t) || t.isEmpty && t.name != "listItem" ? "imageBlock" : "imageInline"
}

function Ws(s) {
    return s && s.endsWith("px") ? parseInt(s) : null
}

function qs(s) {
    const e = Ws(s.getStyle("width")), t = Ws(s.getStyle("height"));
    return !!(e && t)
}

const GA = /^(image|image-inline)$/;

class we extends w {
    _domEmitter = new (xe());

    static get pluginName() {
        return "ImageUtils"
    }

    static get isOfficialPlugin() {
        return !0
    }

    isImage(e) {
        return this.isInlineImage(e) || this.isBlockImage(e)
    }

    isInlineImageView(e) {
        return !!e && e.is("element", "img")
    }

    isBlockImageView(e) {
        return !!e && e.is("element", "figure") && e.hasClass("image")
    }

    insertImage(e = {}, t = null, i = null, n = {}) {
        const o = this.editor, r = o.model, a = r.document.selection, l = xm(o, t || a, i);
        e = {...Object.fromEntries(a.getAttributes()), ...e};
        for (const c in e) r.schema.checkAttribute(l, c) || delete e[c];
        return r.change(c => {
            const {setImageSizes: u = !0} = n, d = c.createElement(l, e);
            return r.insertObject(d, t, null, {
                setSelection: "on",
                findOptimalPosition: !t && l != "imageInline" ? "auto" : void 0
            }), d.parent ? (u && this.setImageNaturalSizeAttributes(d), d) : null
        })
    }

    setImageNaturalSizeAttributes(e) {
        const t = e.getAttribute("src");
        t && (e.getAttribute("width") || e.getAttribute("height") || this.editor.model.change(i => {
            const n = new C.window.Image;
            this._domEmitter.listenTo(n, "load", () => {
                !e.getAttribute("width") && !e.getAttribute("height") && this.editor.model.enqueueChange(i.batch, o => {
                    o.setAttribute("width", n.naturalWidth, e), o.setAttribute("height", n.naturalHeight, e)
                }), this._domEmitter.stopListening(n, "load")
            }), n.src = t
        }))
    }

    getClosestSelectedImageWidget(e) {
        const t = e.getFirstPosition();
        if (!t) return null;
        const i = e.getSelectedElement();
        if (i && this.isImageWidget(i)) return i;
        let n = t.parent;
        for (; n;) {
            if (n.is("element") && this.isImageWidget(n)) return n;
            n = n.parent
        }
        return null
    }

    getClosestSelectedImageElement(e) {
        const t = e.getSelectedElement();
        return this.isImage(t) ? t : e.getFirstPosition().findAncestor("imageBlock")
    }

    getImageWidgetFromImageView(e) {
        return e.findAncestor({classes: GA})
    }

    isImageAllowed() {
        const t = this.editor.model.document.selection;
        return KA(this.editor, t) && ZA(t)
    }

    toImageWidget(e, t, i) {
        return t.setCustomProperty("image", !0, e), Xi(e, t, {
            label: () => {
                const r = this.findViewImgElement(e).getAttribute("alt");
                return r ? `${r} ${i}` : i
            }
        })
    }

    isImageWidget(e) {
        return !!e.getCustomProperty("image") && ie(e)
    }

    isBlockImage(e) {
        return !!e && e.is("element", "imageBlock")
    }

    isInlineImage(e) {
        return !!e && e.is("element", "imageInline")
    }

    findViewImgElement(e) {
        if (this.isInlineImageView(e)) return e;
        const t = this.editor.editing.view;
        for (const {item: i} of t.createRangeIn(e)) if (this.isInlineImageView(i)) return i
    }

    destroy() {
        return this._domEmitter.stopListening(), super.destroy()
    }
}

function KA(s, e) {
    if (xm(s, e, null) == "imageBlock") {
        const i = JA(e, s.model);
        if (s.model.schema.checkChild(i, "imageBlock")) return !0
    } else if (s.model.schema.checkChild(e.focus, "imageInline")) return !0;
    return !1
}

function ZA(s) {
    return [...s.focus.getAncestors()].every(e => !e.is("element", "imageBlock"))
}

function JA(s, e) {
    const i = ka(s, e).start.parent;
    return i.isEmpty && !i.is("element", "$root") ? i.parent : i
}

function xm(s, e, t) {
    const i = s.model.schema, n = s.config.get("image.insert.type");
    return s.plugins.has("ImageBlockEditing") ? s.plugins.has("ImageInlineEditing") ? t || (n === "inline" ? "imageInline" : n !== "auto" ? "imageBlock" : e.is("selection") ? Ia(i, e) : i.checkChild(e, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline"
}

const QA = new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source));

class YA extends w {
    static get requires() {
        return [Ea, we, Ta, mt]
    }

    static get pluginName() {
        return "AutoImage"
    }

    static get isOfficialPlugin() {
        return !0
    }

    _timeoutId;
    _positionToInsert;

    constructor(e) {
        super(e), this._timeoutId = null, this._positionToInsert = null
    }

    init() {
        const e = this.editor, t = e.model.document, i = e.plugins.get("ClipboardPipeline");
        this.listenTo(i, "inputTransformation", () => {
            const n = t.selection.getFirstRange(), o = Y.fromPosition(n.start);
            o.stickiness = "toPrevious";
            const r = Y.fromPosition(n.end);
            r.stickiness = "toNext", t.once("change:data", () => {
                this._embedImageBetweenPositions(o, r), o.detach(), r.detach()
            }, {priority: "high"})
        }), e.commands.get("undo").on("execute", () => {
            this._timeoutId && (C.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null)
        }, {priority: "high"})
    }

    _embedImageBetweenPositions(e, t) {
        const i = this.editor, n = new Ce(e, t), o = n.getWalker({ignoreElementEnd: !0}),
            r = Object.fromEntries(i.model.document.selection.getAttributes()),
            a = this.editor.plugins.get("ImageUtils");
        let l = "";
        for (const c of o) c.item.is("$textProxy") && (l += c.item.data);
        if (l = l.trim(), !l.match(QA)) {
            n.detach();
            return
        }
        this._positionToInsert = Y.fromPosition(e), this._timeoutId = setTimeout(() => {
            if (!i.commands.get("insertImage").isEnabled) {
                n.detach();
                return
            }
            i.model.change(d => {
                this._timeoutId = null, d.remove(n), n.detach();
                let h;
                this._positionToInsert.root.rootName !== "$graveyard" && (h = this._positionToInsert.toPosition()), a.insertImage({
                    ...r,
                    src: l
                }, h), this._positionToInsert.detach(), this._positionToInsert = null
            }), i.plugins.get("Delete").requestUndoOnBackspace()
        }, 100)
    }
}

class XA extends O {
    refresh() {
        const i = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
        this.isEnabled = !!i, this.isEnabled && i.hasAttribute("alt") ? this.value = i.getAttribute("alt") : this.value = !1
    }

    execute(e) {
        const t = this.editor, i = t.plugins.get("ImageUtils"), n = t.model,
            o = i.getClosestSelectedImageElement(n.document.selection);
        n.change(r => {
            r.setAttribute("alt", e.newValue, o)
        })
    }
}

class ex extends w {
    static get requires() {
        return [we]
    }

    static get pluginName() {
        return "ImageTextAlternativeEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        this.editor.commands.add("imageTextAlternative", new XA(this.editor))
    }
}

class tx extends T {
    focusTracker;
    keystrokes;
    labeledInput;
    backButtonView;
    saveButtonView;
    children;
    _focusables;
    _focusCycler;

    constructor(e) {
        super(e), this.focusTracker = new se, this.keystrokes = new ue, this.backButtonView = this._createBackButton(), this.saveButtonView = this._createSaveButton(), this.labeledInput = this._createLabeledInputView(), this.children = this.createCollection([this._createHeaderView()]), this.children.add(new Hs(e, {
            children: [this.labeledInput, this.saveButtonView],
            class: ["ck-form__row_with-submit", "ck-form__row_large-top-padding"]
        })), this._focusables = new Ie, this.keystrokes.set("Esc", (t, i) => {
            this.fire("cancel"), i()
        }), this._focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"}
        }), this.setTemplate({
            tag: "form",
            attributes: {class: ["ck", "ck-form", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1"},
            children: this.children
        })
    }

    render() {
        super.render(), li({view: this}), [this.backButtonView, this.labeledInput, this.saveButtonView].forEach(t => {
            this._focusables.add(t), this.focusTracker.add(t.element)
        }), this.keystrokes.listenTo(this.element)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    _createBackButton() {
        const e = this.locale.t, t = new I(this.locale);
        return t.set({
            class: "ck-button-back",
            label: e("Back"),
            icon: Ht,
            tooltip: !0
        }), t.delegate("execute").to(this, "cancel"), t
    }

    _createSaveButton() {
        const e = this.locale.t, t = new I(this.locale);
        return t.set({label: e("Save"), withText: !0, type: "submit", class: "ck-button-action ck-button-bold"}), t
    }

    _createHeaderView() {
        const e = this.locale.t, t = new ci(this.locale, {label: e("Text Alternative")});
        return t.children.add(this.backButtonView, 0), t
    }

    _createLabeledInputView() {
        const e = this.locale.t, t = new Ut(this.locale, ti);
        return t.label = e("Text alternative"), t.class = "ck-labeled-field-view_full-width", t
    }
}

function ix(s) {
    const e = s.plugins.get("ContextualBalloon");
    if (s.plugins.get("ImageUtils").getClosestSelectedImageWidget(s.editing.view.document.selection)) {
        const i = Sa(s);
        e.updatePosition(i)
    }
}

function Sa(s) {
    const e = s.editing.view, t = Be.defaultPositions, i = s.plugins.get("ImageUtils");
    return {
        target: e.domConverter.mapViewToDom(i.getClosestSelectedImageWidget(e.document.selection)),
        positions: [t.northArrowSouth, t.northArrowSouthWest, t.northArrowSouthEast, t.southArrowNorth, t.southArrowNorthWest, t.southArrowNorthEast, t.viewportStickyNorth]
    }
}

class nx extends w {
    _balloon;
    _form;

    static get requires() {
        return [ii]
    }

    static get pluginName() {
        return "ImageTextAlternativeUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        this._createButton()
    }

    destroy() {
        super.destroy(), this._form && this._form.destroy()
    }

    _createButton() {
        const e = this.editor, t = e.t;
        e.ui.componentFactory.add("imageTextAlternative", i => {
            const n = e.commands.get("imageTextAlternative"), o = new I(i);
            return o.set({
                label: t("Change image text alternative"),
                icon: O1,
                tooltip: !0
            }), o.bind("isEnabled").to(n, "isEnabled"), o.bind("isOn").to(n, "value", r => !!r), this.listenTo(o, "execute", () => {
                this._showForm()
            }), o
        })
    }

    _createForm() {
        const e = this.editor, i = e.editing.view.document, n = e.plugins.get("ImageUtils");
        this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new ($i(tx))(e.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
            e.execute("imageTextAlternative", {newValue: this._form.labeledInput.fieldView.element.value}), this._hideForm(!0)
        }), this.listenTo(this._form, "cancel", () => {
            this._hideForm(!0)
        }), this.listenTo(e.ui, "update", () => {
            n.getClosestSelectedImageWidget(i.selection) ? this._isVisible && ix(e) : this._hideForm(!0)
        }), Ji({
            emitter: this._form,
            activator: () => this._isVisible,
            contextElements: () => [this._balloon.view.element],
            callback: () => this._hideForm()
        })
    }

    _showForm() {
        if (this._isVisible) return;
        this._form || this._createForm();
        const e = this.editor, t = e.commands.get("imageTextAlternative"), i = this._form.labeledInput;
        this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({
            view: this._form,
            position: Sa(e)
        }), i.fieldView.value = i.fieldView.element.value = t.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions()
    }

    _hideForm(e = !1) {
        this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus())
    }

    get _isVisible() {
        return !!this._balloon && this._balloon.visibleView === this._form
    }

    get _isInBalloon() {
        return !!this._balloon && this._balloon.hasView(this._form)
    }
}

class Pa extends w {
    static get requires() {
        return [ex, nx]
    }

    static get pluginName() {
        return "ImageTextAlternative"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

function sx(s) {
    const e = (t, i, n) => {
        if (!n.consumable.test(i.viewItem, {name: !0, classes: "image"})) return;
        const o = s.findViewImgElement(i.viewItem);
        if (!o || !n.consumable.test(o, {name: !0})) return;
        n.consumable.consume(i.viewItem, {name: !0, classes: "image"});
        const r = n.convertItem(o, i.modelCursor), a = re(r.modelRange.getItems());
        if (!a) {
            n.consumable.revert(i.viewItem, {name: !0, classes: "image"});
            return
        }
        n.convertChildren(i.viewItem, a), n.updateConversionResult(a, i)
    };
    return t => {
        t.on("element:figure", e)
    }
}

function Im(s, e) {
    const t = (i, n, o) => {
        if (!o.consumable.consume(n.item, i.name)) return;
        const r = o.writer, a = o.mapper.toViewElement(n.item), l = s.findViewImgElement(a);
        n.attributeNewValue === null ? (r.removeAttribute("srcset", l), r.removeAttribute("sizes", l)) : n.attributeNewValue && (r.setAttribute("srcset", n.attributeNewValue, l), r.setAttribute("sizes", "100vw", l))
    };
    return i => {
        i.on(`attribute:srcset:${e}`, t)
    }
}

function js(s, e, t) {
    const i = (n, o, r) => {
        if (!r.consumable.consume(o.item, n.name)) return;
        const a = r.writer, l = r.mapper.toViewElement(o.item), c = s.findViewImgElement(l);
        a.setAttribute(o.attributeKey, o.attributeNewValue || "", c)
    };
    return n => {
        n.on(`attribute:${t}:${e}`, i)
    }
}

class Ra extends gt {
    observe(e) {
        this.listenTo(e, "load", (t, i) => {
            const n = i.target;
            this.checkShouldIgnoreEventFromTarget(n) || n.tagName == "IMG" && this._fireEvents(i)
        }, {useCapture: !0})
    }

    stopObserving(e) {
        this.stopListening(e)
    }

    _fireEvents(e) {
        this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", e))
    }
}

class ox extends O {
    constructor(e) {
        super(e);
        const t = e.config.get("image.insert.type");
        e.plugins.has("ImageBlockEditing") || t === "block" && L("image-block-plugin-required"), e.plugins.has("ImageInlineEditing") || t === "inline" && L("image-inline-plugin-required")
    }

    refresh() {
        const e = this.editor.plugins.get("ImageUtils");
        this.isEnabled = e.isImageAllowed()
    }

    execute(e) {
        const t = U(e.source), i = this.editor.model.document.selection, n = this.editor.plugins.get("ImageUtils"),
            o = Object.fromEntries(i.getAttributes());
        t.forEach((r, a) => {
            const l = i.getSelectedElement();
            if (typeof r == "string" && (r = {src: r}), a && l && n.isImage(l)) {
                const c = this.editor.model.createPositionAfter(l);
                n.insertImage({...r, ...o}, c, e.imageType)
            } else e.breakBlock ? n.insertImage({...r, ...o}, i.getFirstPosition(), e.imageType) : n.insertImage({...r, ...o}, null, e.imageType)
        })
    }
}

class rx extends O {
    constructor(e) {
        super(e), this.decorate("cleanupImage")
    }

    refresh() {
        const t = this.editor.plugins.get("ImageUtils"), i = this.editor.model.document.selection.getSelectedElement();
        this.isEnabled = t.isImage(i), this.value = this.isEnabled ? i.getAttribute("src") : null
    }

    execute(e) {
        const t = this.editor.model.document.selection.getSelectedElement(), i = this.editor.plugins.get("ImageUtils");
        this.editor.model.change(n => {
            n.setAttribute("src", e.source, t), this.cleanupImage(n, t), i.setImageNaturalSizeAttributes(t)
        })
    }

    cleanupImage(e, t) {
        e.removeAttribute("srcset", t), e.removeAttribute("sizes", t), e.removeAttribute("sources", t), e.removeAttribute("width", t), e.removeAttribute("height", t), e.removeAttribute("alt", t)
    }
}

class Sm extends w {
    static get requires() {
        return [we]
    }

    static get pluginName() {
        return "ImageEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.conversion;
        e.editing.view.addObserver(Ra), t.for("upcast").attributeToAttribute({
            view: {name: "img", key: "alt"},
            model: "alt"
        }).attributeToAttribute({view: {name: "img", key: "srcset"}, model: "srcset"});
        const i = new ox(e), n = new rx(e);
        e.commands.add("insertImage", i), e.commands.add("replaceImageSource", n), e.commands.add("imageInsert", i)
    }
}

class Pm extends w {
    static get requires() {
        return [we]
    }

    static get pluginName() {
        return "ImageSizeAttributes"
    }

    static get isOfficialPlugin() {
        return !0
    }

    afterInit() {
        this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline")
    }

    _registerSchema() {
        this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", {allowAttributes: ["width", "height"]}), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", {allowAttributes: ["width", "height"]})
    }

    _registerConverters(e) {
        const t = this.editor, i = t.plugins.get("ImageUtils"), n = e === "imageBlock" ? "figure" : "img";
        t.conversion.for("upcast").attributeToAttribute({
            view: {name: n, styles: {width: /.+/}},
            model: {key: "width", value: r => qs(r) ? Ws(r.getStyle("width")) : null}
        }).attributeToAttribute({view: {name: n, key: "width"}, model: "width"}).attributeToAttribute({
            view: {
                name: n,
                styles: {height: /.+/}
            }, model: {key: "height", value: r => qs(r) ? Ws(r.getStyle("height")) : null}
        }).attributeToAttribute({
            view: {name: n, key: "height"},
            model: "height"
        }), t.conversion.for("editingDowncast").add(r => {
            o(r, "width", "width", !0, !0), o(r, "height", "height", !0, !0)
        }), t.conversion.for("dataDowncast").add(r => {
            o(r, "width", "width", !1), o(r, "height", "height", !1)
        }), t.conversion.for("upcast").add(r => {
            r.on("element:img", (a, l, c) => {
                const u = l.viewItem.getAttribute("width"), d = l.viewItem.getAttribute("height");
                u && d && c.consumable.consume(l.viewItem, {styles: ["aspect-ratio"]})
            })
        });

        function o(r, a, l, c, u = !1) {
            r.on(`attribute:${a}:${e}`, (d, h, f) => {
                if (!f.consumable.consume(h.item, d.name)) return;
                const m = f.writer, g = f.mapper.toViewElement(h.item), _ = i.findViewImgElement(g);
                h.attributeNewValue !== null ? m.setAttribute(l, h.attributeNewValue, _) : m.removeAttribute(l, _);
                const v = h.item.getAttribute("width"), E = h.item.getAttribute("height"), V = v && E;
                if (V && u && m.setAttribute("loading", "lazy", _), h.item.hasAttribute("sources")) return;
                const N = h.item.hasAttribute("resizedWidth");
                e === "imageInline" && !N && !c || V && m.setStyle("aspect-ratio", `${v}/${E}`, _)
            })
        }
    }
}

class Rm extends O {
    _modelElementName;

    constructor(e, t) {
        super(e), this._modelElementName = t
    }

    refresh() {
        const t = this.editor.plugins.get("ImageUtils"),
            i = t.getClosestSelectedImageElement(this.editor.model.document.selection);
        this._modelElementName === "imageBlock" ? this.isEnabled = t.isInlineImage(i) : this.isEnabled = t.isBlockImage(i)
    }

    execute(e = {}) {
        const t = this.editor, i = this.editor.model, n = t.plugins.get("ImageUtils"),
            o = n.getClosestSelectedImageElement(i.document.selection), r = Object.fromEntries(o.getAttributes());
        return !r.src && !r.uploadId ? null : i.change(a => {
            const {setImageSizes: l = !0} = e, c = Array.from(i.markers).filter(h => h.getRange().containsItem(o)),
                u = n.insertImage(r, i.createSelection(o, "on"), this._modelElementName, {setImageSizes: l});
            if (!u) return null;
            const d = a.createRangeOn(u);
            for (const h of c) {
                const f = h.getRange(), m = f.root.rootName != "$graveyard" ? f.getJoined(d, !0) : d;
                a.updateMarker(h, {range: m})
            }
            return {oldElement: o, newElement: u}
        })
    }
}

class Vm extends w {
    static get requires() {
        return [we]
    }

    static get pluginName() {
        return "ImagePlaceholder"
    }

    static get isOfficialPlugin() {
        return !0
    }

    afterInit() {
        this._setupSchema(), this._setupConversion(), this._setupLoadListener()
    }

    _setupSchema() {
        const e = this.editor.model.schema;
        e.isRegistered("imageBlock") && e.extend("imageBlock", {allowAttributes: ["placeholder"]}), e.isRegistered("imageInline") && e.extend("imageInline", {allowAttributes: ["placeholder"]})
    }

    _setupConversion() {
        const e = this.editor, t = e.conversion, i = e.plugins.get("ImageUtils");
        t.for("editingDowncast").add(n => {
            n.on("attribute:placeholder", (o, r, a) => {
                if (!a.consumable.test(r.item, o.name) || !r.item.is("element", "imageBlock") && !r.item.is("element", "imageInline")) return;
                a.consumable.consume(r.item, o.name);
                const l = a.writer, c = a.mapper.toViewElement(r.item), u = i.findViewImgElement(c);
                r.attributeNewValue ? (l.addClass("image_placeholder", u), l.setStyle("background-image", `url(${r.attributeNewValue})`, u), l.setCustomProperty("editingPipeline:doNotReuseOnce", !0, u)) : (l.removeClass("image_placeholder", u), l.removeStyle("background-image", u))
            })
        })
    }

    _setupLoadListener() {
        const e = this.editor, t = e.model, i = e.editing, n = i.view, o = e.plugins.get("ImageUtils");
        n.addObserver(Ra), this.listenTo(n.document, "imageLoaded", (r, a) => {
            const l = n.domConverter.mapDomToView(a.target);
            if (!l) return;
            const c = o.getImageWidgetFromImageView(l);
            if (!c) return;
            const u = i.mapper.toModelElement(c);
            !u || !u.hasAttribute("placeholder") || t.enqueueChange({isUndoable: !1}, d => {
                d.removeAttribute("placeholder", u)
            })
        })
    }
}

class Om extends w {
    static get requires() {
        return [Sm, Pm, we, Vm, $e]
    }

    static get pluginName() {
        return "ImageBlockEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        e.model.schema.register("imageBlock", {
            inheritAllFrom: "$blockObject",
            allowAttributes: ["alt", "src", "srcset"]
        }), this._setupConversion(), e.plugins.has("ImageInlineEditing") && (e.commands.add("imageTypeBlock", new Rm(this.editor, "imageBlock")), this._setupClipboardIntegration())
    }

    _setupConversion() {
        const e = this.editor, t = e.t, i = e.conversion, n = e.plugins.get("ImageUtils");
        i.for("dataDowncast").elementToStructure({
            model: "imageBlock",
            view: (o, {writer: r}) => xu(r)
        }), i.for("editingDowncast").elementToStructure({
            model: "imageBlock",
            view: (o, {writer: r}) => n.toImageWidget(xu(r), r, t("image widget"))
        }), i.for("downcast").add(js(n, "imageBlock", "src")).add(js(n, "imageBlock", "alt")).add(Im(n, "imageBlock")), i.for("upcast").elementToElement({
            view: Am(e, "imageBlock"),
            model: (o, {writer: r}) => r.createElement("imageBlock", o.hasAttribute("src") ? {src: o.getAttribute("src")} : void 0)
        }).add(sx(n))
    }

    _setupClipboardIntegration() {
        const e = this.editor, t = e.model, i = e.editing.view, n = e.plugins.get("ImageUtils"),
            o = e.plugins.get("ClipboardPipeline");
        this.listenTo(o, "inputTransformation", (r, a) => {
            const l = Array.from(a.content.getChildren());
            let c;
            if (!l.every(n.isInlineImageView)) return;
            a.targetRanges ? c = e.editing.mapper.toModelRange(a.targetRanges[0]) : c = t.document.selection.getFirstRange();
            const u = t.createSelection(c);
            if (Ia(t.schema, u) === "imageBlock") {
                const d = new pt(i.document), h = l.map(f => d.createElement("figure", {class: "image"}, f));
                a.content = d.createDocumentFragment(h)
            }
        }), this.listenTo(o, "contentInsertion", (r, a) => {
            a.method === "paste" && t.change(l => {
                const c = l.createRangeIn(a.content);
                for (const u of c.getItems()) u.is("element", "imageBlock") && n.setImageNaturalSizeAttributes(u)
            })
        })
    }
}

class ax extends T {
    focusTracker;
    keystrokes;
    _focusables;
    _focusCycler;
    children;

    constructor(e, t = []) {
        super(e), this.focusTracker = new se, this.keystrokes = new ue, this._focusables = new Ie, this.children = this.createCollection(), this._focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"}
        });
        for (const i of t) this.children.add(i), this._focusables.add(i), i instanceof Ff && this._focusables.addMany(i.children);
        this.setTemplate({
            tag: "form",
            attributes: {class: ["ck", "ck-image-insert-form"], tabindex: -1},
            children: this.children
        })
    }

    render() {
        super.render(), li({view: this});
        for (const t of this._focusables) this.focusTracker.add(t.element);
        this.keystrokes.listenTo(this.element);
        const e = t => t.stopPropagation();
        this.keystrokes.set("arrowright", e), this.keystrokes.set("arrowleft", e), this.keystrokes.set("arrowup", e), this.keystrokes.set("arrowdown", e)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    focus() {
        this._focusCycler.focusFirst()
    }
}

class Kn extends w {
    static get pluginName() {
        return "ImageInsertUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [we]
    }

    dropdownView;
    _integrations = new Map;

    constructor(e) {
        super(e), e.config.define("image.insert.integrations", ["upload", "assetManager", "url"])
    }

    init() {
        const e = this.editor, t = e.model.document.selection, i = e.plugins.get("ImageUtils");
        this.set("isImageSelected", !1), this.listenTo(e.model.document, "change", () => {
            this.isImageSelected = i.isImage(t.getSelectedElement())
        });
        const n = r => this._createToolbarComponent(r), o = r => this._createMenuBarComponent(r);
        e.ui.componentFactory.add("insertImage", n), e.ui.componentFactory.add("imageInsert", n), e.ui.componentFactory.add("menuBar:insertImage", o)
    }

    registerIntegration({
                            name: e,
                            observable: t,
                            buttonViewCreator: i,
                            formViewCreator: n,
                            menuBarButtonViewCreator: o,
                            requiresForm: r = !1,
                            override: a = !1
                        }) {
        this._integrations.has(e) && !a && L("image-insert-integration-exists", {name: e}), this._integrations.set(e, {
            observable: t,
            buttonViewCreator: i,
            menuBarButtonViewCreator: o,
            formViewCreator: n,
            requiresForm: r
        })
    }

    _createToolbarComponent(e) {
        const t = this.editor, i = e.t, n = this._prepareIntegrations();
        if (!n.length) return null;
        let o;
        const r = n[0];
        if (n.length == 1) {
            if (!r.requiresForm) return r.buttonViewCreator(!0);
            o = r.buttonViewCreator(!0)
        } else {
            const c = r.buttonViewCreator(!1);
            o = new Wn(e, c), o.tooltip = !0, o.bind("label").to(this, "isImageSelected", u => i(u ? "Replace image" : "Insert image"))
        }
        const a = this.dropdownView = Ae(e, o), l = n.map(({observable: c}) => typeof c == "function" ? c() : c);
        return a.bind("isEnabled").toMany(l, "isEnabled", (...c) => c.some(u => u)), a.once("change:isOpen", () => {
            const c = n.flatMap(({formViewCreator: d}) => d(n.length == 1)), u = new ax(t.locale, c);
            a.panelView.children.add(u)
        }), a
    }

    _createMenuBarComponent(e) {
        const t = e.t, i = this._prepareIntegrations();
        if (!i.length) return null;
        const n = i.flatMap(({menuBarButtonViewCreator: a}) => a(i.length == 1)), o = new Ne(e), r = new $t(e);
        o.panelView.children.add(r), o.buttonView.set({icon: i1, label: t("Image")});
        for (const a of n) {
            const l = new St(e, o);
            l.children.add(a), r.items.add(l), a.delegate("execute").to(o)
        }
        return o
    }

    _prepareIntegrations() {
        const t = this.editor.config.get("image.insert.integrations"), i = [];
        if (!t.length) return L("image-insert-integrations-not-specified"), i;
        for (const n of t) {
            if (!this._integrations.has(n)) {
                ["upload", "assetManager", "url"].includes(n) || L("image-insert-unknown-integration", {item: n});
                continue
            }
            i.push(this._integrations.get(n))
        }
        return i.length || L("image-insert-integrations-not-registered"), i
    }
}

class lx extends w {
    static get requires() {
        return [Om, di, Pa, Kn]
    }

    static get pluginName() {
        return "ImageBlock"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

class cx extends w {
    static get requires() {
        return [Sm, Pm, we, Vm, $e]
    }

    static get pluginName() {
        return "ImageInlineEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        e.model.schema.register("imageInline", {
            inheritAllFrom: "$inlineObject",
            allowAttributes: ["alt", "src", "srcset"],
            disallowIn: ["caption"]
        }), this._setupConversion(), e.plugins.has("ImageBlockEditing") && (e.commands.add("imageTypeInline", new Rm(this.editor, "imageInline")), this._setupClipboardIntegration())
    }

    _setupConversion() {
        const e = this.editor, t = e.t, i = e.conversion, n = e.plugins.get("ImageUtils");
        i.for("dataDowncast").elementToElement({
            model: "imageInline",
            view: (o, {writer: r}) => r.createEmptyElement("img")
        }), i.for("editingDowncast").elementToStructure({
            model: "imageInline",
            view: (o, {writer: r}) => n.toImageWidget(jA(r), r, t("image widget"))
        }), i.for("downcast").add(js(n, "imageInline", "src")).add(js(n, "imageInline", "alt")).add(Im(n, "imageInline")), i.for("upcast").elementToElement({
            view: Am(e, "imageInline"),
            model: (o, {writer: r}) => r.createElement("imageInline", o.hasAttribute("src") ? {src: o.getAttribute("src")} : void 0)
        })
    }

    _setupClipboardIntegration() {
        const e = this.editor, t = e.model, i = e.editing.view, n = e.plugins.get("ImageUtils"),
            o = e.plugins.get("ClipboardPipeline");
        this.listenTo(o, "inputTransformation", (r, a) => {
            const l = Array.from(a.content.getChildren());
            let c;
            if (!l.every(n.isBlockImageView)) return;
            a.targetRanges ? c = e.editing.mapper.toModelRange(a.targetRanges[0]) : c = t.document.selection.getFirstRange();
            const u = t.createSelection(c);
            if (Ia(t.schema, u) === "imageInline") {
                const d = new pt(i.document),
                    h = l.map(f => f.childCount === 1 ? (Array.from(f.getAttributes()).forEach(m => d.setAttribute(...m, n.findViewImgElement(f))), f.getChild(0)) : f);
                a.content = d.createDocumentFragment(h)
            }
        }), this.listenTo(o, "contentInsertion", (r, a) => {
            a.method === "paste" && t.change(l => {
                const c = l.createRangeIn(a.content);
                for (const u of c.getItems()) u.is("element", "imageInline") && n.setImageNaturalSizeAttributes(u)
            })
        })
    }
}

class ux extends w {
    static get requires() {
        return [cx, di, Pa, Kn]
    }

    static get pluginName() {
        return "ImageInline"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

class Mm extends w {
    static get pluginName() {
        return "ImageCaptionUtils"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [we]
    }

    getCaptionFromImageModelElement(e) {
        for (const t of e.getChildren()) if (t && t.is("element", "caption")) return t;
        return null
    }

    getCaptionFromModelSelection(e) {
        const t = this.editor.plugins.get("ImageUtils"), i = e.getFirstPosition().findAncestor("caption");
        return i && t.isBlockImage(i.parent) ? i : null
    }

    matchImageCaptionViewElement(e) {
        const t = this.editor.plugins.get("ImageUtils");
        return e.name == "figcaption" && t.isBlockImageView(e.parent) ? {name: !0} : null
    }
}

class dx extends O {
    refresh() {
        const e = this.editor, t = e.plugins.get("ImageCaptionUtils"), i = e.plugins.get("ImageUtils");
        if (!e.plugins.has(Om)) {
            this.isEnabled = !1, this.value = !1;
            return
        }
        const n = e.model.document.selection, o = n.getSelectedElement();
        if (!o) {
            const r = t.getCaptionFromModelSelection(n);
            this.isEnabled = !!r, this.value = !!r;
            return
        }
        this.isEnabled = i.isImage(o), this.isEnabled ? this.value = !!t.getCaptionFromImageModelElement(o) : this.value = !1
    }

    execute(e = {}) {
        const {focusCaptionOnShow: t} = e;
        this.editor.model.change(i => {
            this.value ? this._hideImageCaption(i) : this._showImageCaption(i, t)
        })
    }

    _showImageCaption(e, t) {
        const n = this.editor.model.document.selection, o = this.editor.plugins.get("ImageCaptionEditing"),
            r = this.editor.plugins.get("ImageUtils");
        let a = n.getSelectedElement();
        const l = o._getSavedCaption(a);
        r.isInlineImage(a) && (this.editor.execute("imageTypeBlock"), a = n.getSelectedElement());
        const c = l || e.createElement("caption");
        e.append(c, a), t && e.setSelection(c, "in")
    }

    _hideImageCaption(e) {
        const t = this.editor, i = t.model.document.selection, n = t.plugins.get("ImageCaptionEditing"),
            o = t.plugins.get("ImageCaptionUtils");
        let r = i.getSelectedElement(), a;
        r ? a = o.getCaptionFromImageModelElement(r) : (a = o.getCaptionFromModelSelection(i), r = a.parent), n._saveCaption(r, a), e.setSelection(r, "on"), e.remove(a)
    }
}

class hx extends w {
    static get requires() {
        return [we, Mm]
    }

    static get pluginName() {
        return "ImageCaptionEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    _savedCaptionsMap;

    constructor(e) {
        super(e), this._savedCaptionsMap = new WeakMap
    }

    init() {
        const e = this.editor, t = e.model.schema;
        t.isRegistered("caption") ? t.extend("caption", {allowIn: "imageBlock"}) : t.register("caption", {
            allowIn: "imageBlock",
            allowContentOf: "$block",
            isLimit: !0
        }), e.commands.add("toggleImageCaption", new dx(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion()
    }

    _setupConversion() {
        const e = this.editor, t = e.editing.view, i = e.plugins.get("ImageUtils"),
            n = e.plugins.get("ImageCaptionUtils"), o = e.t;
        e.conversion.for("upcast").elementToElement({
            view: r => n.matchImageCaptionViewElement(r),
            model: "caption"
        }), e.conversion.for("dataDowncast").elementToElement({
            model: "caption",
            view: (r, {writer: a}) => i.isBlockImage(r.parent) ? a.createContainerElement("figcaption") : null
        }), e.conversion.for("editingDowncast").elementToElement({
            model: "caption", view: (r, {writer: a}) => {
                if (!i.isBlockImage(r.parent)) return null;
                const l = a.createEditableElement("figcaption");
                a.setCustomProperty("imageCaption", !0, l), l.placeholder = o("Enter image caption"), wh({
                    view: t,
                    element: l,
                    keepOnFocus: !0
                });
                const c = r.parent.getAttribute("alt"),
                    u = c ? o("Caption for image: %0", [c]) : o("Caption for the image");
                return um(l, a, {label: u})
            }
        })
    }

    _setupImageTypeCommandsIntegration() {
        const e = this.editor, t = e.plugins.get("ImageUtils"), i = e.plugins.get("ImageCaptionUtils"),
            n = e.commands.get("imageTypeInline"), o = e.commands.get("imageTypeBlock"), r = a => {
                if (!a.return) return;
                const {oldElement: l, newElement: c} = a.return;/* istanbul ignore if: paranoid check -- @preserve */
                if (!l) return;
                if (t.isBlockImage(l)) {
                    const d = i.getCaptionFromImageModelElement(l);
                    if (d) {
                        this._saveCaption(c, d);
                        return
                    }
                }
                const u = this._getSavedCaption(l);
                u && this._saveCaption(c, u)
            };
        n && this.listenTo(n, "execute", r, {priority: "low"}), o && this.listenTo(o, "execute", r, {priority: "low"})
    }

    _getSavedCaption(e) {
        const t = this._savedCaptionsMap.get(e);
        return t ? j.fromJSON(t) : null
    }

    _saveCaption(e, t) {
        this._savedCaptionsMap.set(e, t.toJSON())
    }

    _registerCaptionReconversion() {
        const e = this.editor, t = e.model, i = e.plugins.get("ImageUtils"), n = e.plugins.get("ImageCaptionUtils");
        t.document.on("change:data", () => {
            const o = t.document.differ.getChanges();
            for (const r of o) {
                if (r.attributeKey !== "alt") continue;
                const a = r.range.start.nodeAfter;
                if (i.isBlockImage(a)) {
                    const l = n.getCaptionFromImageModelElement(a);
                    if (!l) return;
                    e.editing.reconvertItem(l)
                }
            }
        })
    }
}

class fx extends w {
    static get requires() {
        return [Mm]
    }

    static get pluginName() {
        return "ImageCaptionUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.editing.view, i = e.plugins.get("ImageCaptionUtils"), n = e.t;
        e.ui.componentFactory.add("toggleImageCaption", o => {
            const r = e.commands.get("toggleImageCaption"), a = new I(o);
            return a.set({
                icon: Kv,
                tooltip: !0,
                isToggleable: !0
            }), a.bind("isOn", "isEnabled").to(r, "value", "isEnabled"), a.bind("label").to(r, "value", l => n(l ? "Toggle caption off" : "Toggle caption on")), this.listenTo(a, "execute", () => {
                e.execute("toggleImageCaption", {focusCaptionOnShow: !0});
                const l = i.getCaptionFromModelSelection(e.model.document.selection);
                if (l) {
                    const c = e.editing.mapper.toViewElement(l);
                    t.scrollToTheSelection(), t.change(u => {
                        u.addClass("image__caption_highlighted", c)
                    })
                }
                e.editing.view.focus()
            }), a
        })
    }
}

class mx extends w {
    static get requires() {
        return [hx, fx]
    }

    static get pluginName() {
        return "ImageCaption"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

function Bm(s) {
    const e = s.map(t => t.replace("+", "\\+"));
    return new RegExp(`^image\\/(${e.join("|")})$`)
}

function gx(s) {
    return new Promise((e, t) => {
        const i = s.getAttribute("src");
        fetch(i).then(n => n.blob()).then(n => {
            const o = Fm(n, i), a = `image.${o.replace("image/", "")}`, l = new File([n], a, {type: o});
            e(l)
        }).catch(n => n && n.name === "TypeError" ? wx(i).then(e).catch(t) : t(n))
    })
}

function px(s, e) {
    return !s.isInlineImageView(e) || !e.getAttribute("src") ? !1 : !!e.getAttribute("src").match(/^data:image\/\w+;base64,/g) || !!e.getAttribute("src").match(/^blob:/g)
}

function Fm(s, e) {
    return s.type ? s.type : e.match(/data:(image\/\w+);base64/) ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg"
}

function wx(s) {
    return bx(s).then(e => {
        const t = Fm(e, s), n = `image.${t.replace("image/", "")}`;
        return new File([e], n, {type: t})
    })
}

function bx(s) {
    return new Promise((e, t) => {
        const i = C.document.createElement("img");
        i.addEventListener("load", () => {
            const n = C.document.createElement("canvas");
            n.width = i.width, n.height = i.height, n.getContext("2d").drawImage(i, 0, 0), n.toBlob(r => r ? e(r) : t())
        }), i.addEventListener("error", () => t()), i.src = s
    })
}

class _x extends w {
    static get pluginName() {
        return "ImageUploadUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        e.ui.componentFactory.add("uploadImage", () => this._createToolbarButton()), e.ui.componentFactory.add("imageUpload", () => this._createToolbarButton()), e.ui.componentFactory.add("menuBar:uploadImage", () => this._createMenuBarButton("standalone")), e.plugins.has("ImageInsertUI") && e.plugins.get("ImageInsertUI").registerIntegration({
            name: "upload",
            observable: () => e.commands.get("uploadImage"),
            buttonViewCreator: () => this._createToolbarButton(),
            formViewCreator: () => this._createDropdownButton(),
            menuBarButtonViewCreator: t => this._createMenuBarButton(t ? "insertOnly" : "insertNested")
        })
    }

    _createButton(e) {
        const t = this.editor, i = t.locale, n = t.commands.get("uploadImage"), o = t.config.get("image.upload.types"),
            r = Bm(o), a = new e(t.locale), l = i.t;
        return a.set({
            acceptedType: o.map(c => `image/${c}`).join(","),
            allowMultipleFiles: !0,
            label: l("Upload from computer"),
            icon: n1
        }), a.bind("isEnabled").to(n), a.on("done", (c, u) => {
            const d = Array.from(u).filter(h => r.test(h.type));
            d.length && (t.execute("uploadImage", {file: d}), t.editing.view.focus())
        }), a
    }

    _createToolbarButton() {
        const e = this.editor.locale.t, t = this.editor.plugins.get("ImageInsertUI"),
            i = this.editor.commands.get("uploadImage"), n = this._createButton(Ic);
        return n.tooltip = !0, n.bind("label").to(t, "isImageSelected", i, "isAccessAllowed", (o, r) => e(r ? o ? "Replace image from computer" : "Upload image from computer" : "You have no image upload permissions.")), n
    }

    _createDropdownButton() {
        const e = this.editor.locale.t, t = this.editor.plugins.get("ImageInsertUI"), i = this._createButton(Ic);
        return i.withText = !0, i.bind("label").to(t, "isImageSelected", n => e(n ? "Replace from computer" : "Upload from computer")), i.on("execute", () => {
            t.dropdownView.isOpen = !1
        }), i
    }

    _createMenuBarButton(e) {
        const t = this.editor.locale.t, i = this._createButton(Yf);
        switch (i.withText = !0, e) {
            case"standalone":
                i.label = t("Image from computer");
                break;
            case"insertOnly":
                i.label = t("Image");
                break;
            case"insertNested":
                i.label = t("From computer");
                break
        }
        return i
    }
}

class vx extends w {
    static get pluginName() {
        return "ImageUploadProgress"
    }

    static get isOfficialPlugin() {
        return !0
    }

    placeholder;

    constructor(e) {
        super(e), this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
    }

    init() {
        const e = this.editor;
        e.plugins.has("ImageBlockEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), e.plugins.has("ImageInlineEditing") && e.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange)
    }

    uploadStatusChange = (e, t, i) => {
        const n = this.editor, o = t.item, r = o.getAttribute("uploadId");
        if (!i.consumable.consume(t.item, e.name)) return;
        const a = n.plugins.get("ImageUtils"), l = n.plugins.get(Ft), c = r ? t.attributeNewValue : null,
            u = this.placeholder, d = n.editing.mapper.toViewElement(o), h = i.writer;
        if (c == "reading") {
            Iu(d, h), Su(a, u, d, h);
            return
        }
        if (c == "uploading") {
            const f = l.loaders.get(r);
            Iu(d, h), f ? (Pu(d, h), kx(d, h, f, n.editing.view), xx(a, d, h, f)) : Su(a, u, d, h);
            return
        }
        c == "complete" && l.loaders.get(r) && Ex(d, h, n.editing.view), Cx(d, h), Pu(d, h), yx(d, h)
    }
}

function Iu(s, e) {
    s.hasClass("ck-appear") || e.addClass("ck-appear", s)
}

function yx(s, e) {
    e.removeClass("ck-appear", s)
}

function Su(s, e, t, i) {
    t.hasClass("ck-image-upload-placeholder") || i.addClass("ck-image-upload-placeholder", t);
    const n = s.findViewImgElement(t);
    n.getAttribute("src") !== e && i.setAttribute("src", e, n), Lm(t, "placeholder") || i.insert(i.createPositionAfter(n), Ax(i))
}

function Pu(s, e) {
    s.hasClass("ck-image-upload-placeholder") && e.removeClass("ck-image-upload-placeholder", s), Dm(s, e, "placeholder")
}

function kx(s, e, t, i) {
    const n = Tx(e);
    e.insert(e.createPositionAt(s, "end"), n), t.on("change:uploadedPercent", (o, r, a) => {
        i.change(l => {
            l.setStyle("width", a + "%", n)
        })
    })
}

function Cx(s, e) {
    Dm(s, e, "progressBar")
}

function Ex(s, e, t) {
    const i = e.createUIElement("div", {class: "ck-image-upload-complete-icon"});
    e.insert(e.createPositionAt(s, "end"), i), setTimeout(() => {
        t.change(n => n.remove(n.createRangeOn(i)))
    }, 3e3)
}

function Tx(s) {
    const e = s.createUIElement("div", {class: "ck-progress-bar"});
    return s.setCustomProperty("progressBar", !0, e), e
}

function Ax(s) {
    const e = s.createUIElement("div", {class: "ck-upload-placeholder-loader"});
    return s.setCustomProperty("placeholder", !0, e), e
}

function Lm(s, e) {
    for (const t of s.getChildren()) if (t.getCustomProperty(e)) return t
}

function Dm(s, e, t) {
    const i = Lm(s, t);
    i && e.remove(e.createRangeOn(i))
}

function xx(s, e, t, i) {
    if (i.data) {
        const n = s.findViewImgElement(e);
        t.setAttribute("src", i.data, n)
    }
}

class Ix extends O {
    constructor(e) {
        super(e), this.set("isAccessAllowed", !0)
    }

    refresh() {
        const e = this.editor, t = e.plugins.get("ImageUtils"), i = e.model.document.selection.getSelectedElement();
        this.isEnabled = t.isImageAllowed() || t.isImage(i)
    }

    execute(e) {
        const t = U(e.file), i = this.editor.model.document.selection, n = this.editor.plugins.get("ImageUtils"),
            o = Object.fromEntries(i.getAttributes());
        t.forEach((r, a) => {
            const l = i.getSelectedElement();
            if (a && l && n.isImage(l)) {
                const c = this.editor.model.createPositionAfter(l);
                this._uploadImage(r, o, c)
            } else this._uploadImage(r, o)
        })
    }

    _uploadImage(e, t, i) {
        const n = this.editor, r = n.plugins.get(Ft).createLoader(e), a = n.plugins.get("ImageUtils");
        r && a.insertImage({...t, uploadId: r.id}, i)
    }
}

class Sx extends w {
    static get requires() {
        return [Ft, Hc, $e, we]
    }

    static get pluginName() {
        return "ImageUploadEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    _uploadImageElements;
    _uploadedImages = new Map;

    constructor(e) {
        super(e), e.config.define("image", {upload: {types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"]}}), this._uploadImageElements = new Map
    }

    init() {
        const e = this.editor, t = e.model.document, i = e.conversion, n = e.plugins.get(Ft),
            o = e.plugins.get("ImageUtils"), r = e.plugins.get("ClipboardPipeline"),
            a = Bm(e.config.get("image.upload.types")), l = new Ix(e);
        e.commands.add("uploadImage", l), e.commands.add("imageUpload", l), i.for("upcast").attributeToAttribute({
            view: {
                name: "img",
                key: "uploadId"
            }, model: "uploadId"
        }).add(c => c.on("element:img", (u, d, h) => {
            if (!h.consumable.test(d.viewItem, {attributes: ["data-ck-upload-id"]})) return;
            const f = d.viewItem.getAttribute("data-ck-upload-id");
            if (!f) return;
            const [m] = Array.from(d.modelRange.getItems({shallow: !0})), g = n.loaders.get(f);
            m && (h.writer.setAttribute("uploadId", f, m), h.consumable.consume(d.viewItem, {attributes: ["data-ck-upload-id"]}), g && g.data && h.writer.setAttribute("uploadStatus", g.status, m))
        }, {priority: "low"})), this.listenTo(e.editing.view.document, "clipboardInput", (c, u) => {
            if (Px(u.dataTransfer)) return;
            const d = Array.from(u.dataTransfer.files).filter(f => f ? a.test(f.type) : !1);
            if (!d.length) return;
            if (c.stop(), e.model.change(f => {
                u.targetRanges && f.setSelection(u.targetRanges.map(m => e.editing.mapper.toModelRange(m))), e.execute("uploadImage", {file: d})
            }), !e.commands.get("uploadImage").isAccessAllowed) {
                const f = e.plugins.get("Notification"), m = e.locale.t;
                f.showWarning(m("You have no image upload permissions."), {namespace: "image"})
            }
        }), this.listenTo(r, "inputTransformation", (c, u) => {
            const d = Array.from(e.editing.view.createRangeIn(u.content)).map(f => f.item).filter(f => px(o, f) && !f.getAttribute("uploadProcessed")).map(f => ({
                promise: gx(f),
                imageElement: f
            }));
            if (!d.length) return;
            const h = new pt(e.editing.view.document);
            for (const f of d) {
                h.setAttribute("uploadProcessed", !0, f.imageElement);
                const m = n.createLoader(f.promise);
                m && (h.setAttribute("src", "", f.imageElement), h.setAttribute("uploadId", m.id, f.imageElement))
            }
        }), e.editing.view.document.on("dragover", (c, u) => {
            u.preventDefault()
        }), t.on("change", () => {
            const c = t.differ.getChanges({includeChangesInGraveyard: !0}).reverse(), u = new Set;
            for (const d of c) if (d.type == "insert" && d.name != "$text") {
                const h = d.position.nodeAfter, f = d.position.root.rootName == "$graveyard";
                for (const m of Rx(e, h)) {
                    const g = m.getAttribute("uploadId");
                    if (!g) continue;
                    const _ = n.loaders.get(g);
                    if (!_) {
                        !f && this._uploadedImages.has(g) && e.model.enqueueChange({isUndoable: !1}, v => {
                            v.setAttribute("uploadStatus", "complete", m), this.fire("uploadComplete", {
                                data: this._uploadedImages.get(g),
                                imageElement: m
                            })
                        });
                        continue
                    }
                    f ? u.has(g) || Array.from(this._uploadImageElements.get(g)).every(E => E.root.rootName == "$graveyard") && _.abort() : (u.add(g), this._uploadImageElements.has(g) ? this._uploadImageElements.get(g).add(m) : this._uploadImageElements.set(g, new Set([m])), _.status == "idle" && this._readAndUpload(_))
                }
            }
        }), this.on("uploadComplete", (c, {imageElement: u, data: d}) => {
            const h = d.urls ? d.urls : d;
            this.editor.model.change(f => {
                f.setAttribute("src", h.default, u), this._parseAndSetSrcsetAttributeOnImage(h, u, f), o.setImageNaturalSizeAttributes(u)
            })
        }, {priority: "low"})
    }

    afterInit() {
        const e = this.editor.model.schema;
        this.editor.plugins.has("ImageBlockEditing") && (e.extend("imageBlock", {allowAttributes: ["uploadId", "uploadStatus"]}), this._registerConverters("imageBlock")), this.editor.plugins.has("ImageInlineEditing") && (e.extend("imageInline", {allowAttributes: ["uploadId", "uploadStatus"]}), this._registerConverters("imageInline"))
    }

    _readAndUpload(e) {
        const t = this.editor, i = t.model, n = t.locale.t, o = t.plugins.get(Ft), r = t.plugins.get(Hc),
            a = t.plugins.get("ImageUtils"), l = this._uploadImageElements;
        return i.enqueueChange({isUndoable: !1}, u => {
            const d = l.get(e.id);
            for (const h of d) u.setAttribute("uploadStatus", "reading", h)
        }), e.read().then(() => {
            const u = e.upload();
            t.ui && t.ui.ariaLiveAnnouncer.announce(n("Uploading image"));
            for (const d of l.get(e.id)) {/* istanbul ignore next -- @preserve */
                if (x.isSafari) {
                    const h = t.editing.mapper.toViewElement(d), f = a.findViewImgElement(h);
                    t.editing.view.once("render", () => {
                        if (!f.parent) return;
                        const m = t.editing.view.domConverter.mapViewToDom(f.parent);
                        if (!m) return;
                        const g = m.style.display;
                        m.style.display = "none", m._ckHack = m.offsetHeight, m.style.display = g
                    })
                }
                i.enqueueChange({isUndoable: !1}, h => {
                    h.setAttribute("uploadStatus", "uploading", d)
                })
            }
            return u
        }).then(u => {
            i.enqueueChange({isUndoable: !1}, d => {
                for (const h of l.get(e.id)) d.setAttribute("uploadStatus", "complete", h), this.fire("uploadComplete", {
                    data: u,
                    imageElement: h
                });
                t.ui && t.ui.ariaLiveAnnouncer.announce(n("Image upload complete")), this._uploadedImages.set(e.id, u)
            }), c()
        }).catch(u => {
            if (t.ui && t.ui.ariaLiveAnnouncer.announce(n("Error during image upload")), e.status !== "error" && e.status !== "aborted") throw u;
            e.status == "error" && u && r.showWarning(u, {
                title: n("Upload failed"),
                namespace: "upload"
            }), i.enqueueChange({isUndoable: !1}, d => {
                for (const h of l.get(e.id)) h.root.rootName !== "$graveyard" && d.remove(h)
            }), c()
        });

        function c() {
            i.enqueueChange({isUndoable: !1}, u => {
                for (const d of l.get(e.id)) u.removeAttribute("uploadId", d), u.removeAttribute("uploadStatus", d);
                l.delete(e.id)
            }), o.destroyLoader(e)
        }
    }

    _parseAndSetSrcsetAttributeOnImage(e, t, i) {
        let n = 0;
        const o = Object.keys(e).filter(r => {
            const a = parseInt(r, 10);
            if (!isNaN(a)) return n = Math.max(n, a), !0
        }).map(r => `${e[r]} ${r}w`).join(", ");
        if (o != "") {
            const r = {srcset: o};
            !t.hasAttribute("width") && !t.hasAttribute("height") && (r.width = n), i.setAttributes(r, t)
        }
    }

    _registerConverters(e) {
        const {conversion: t, plugins: i} = this.editor, n = i.get(Ft), o = i.get(we);
        t.for("dataDowncast").add(r => {
            r.on(`attribute:uploadId:${e}`, (a, l, c) => {
                if (!c.consumable.test(l.item, a.name)) return;
                const u = n.loaders.get(l.attributeNewValue);
                if (!u || !u.data) return null;
                const d = c.mapper.toViewElement(l.item), h = o.findViewImgElement(d);
                h && (c.consumable.consume(l.item, a.name), c.writer.setAttribute("data-ck-upload-id", u.id, h))
            })
        })
    }
}

function Px(s) {
    return Array.from(s.types).includes("text/html") && s.getData("text/html") !== ""
}

function Rx(s, e) {
    const t = s.plugins.get("ImageUtils");
    return Array.from(s.model.createRangeOn(e)).filter(i => t.isImage(i.item)).map(i => i.item)
}

class Nm extends w {
    static get pluginName() {
        return "ImageUpload"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Sx, _x, vx]
    }
}

class Vx extends T {
    urlInputView;
    keystrokes;

    constructor(e) {
        super(e), this.set("imageURLInputValue", ""), this.set("isImageSelected", !1), this.set("isEnabled", !0), this.keystrokes = new ue, this.urlInputView = this._createUrlInputView(), this.setTemplate({
            tag: "form",
            attributes: {class: ["ck", "ck-image-insert-url"], tabindex: "-1"},
            children: [this.urlInputView, {tag: "div", attributes: {class: ["ck", "ck-image-insert-url__action-row"]}}]
        })
    }

    render() {
        super.render(), li({view: this}), this.keystrokes.listenTo(this.element)
    }

    destroy() {
        super.destroy(), this.keystrokes.destroy()
    }

    _createUrlInputView() {
        const e = this.locale, t = e.t, i = new Ut(e, ti);
        return i.bind("label").to(this, "isImageSelected", n => t(n ? "Update image URL" : "Insert image via URL")), i.bind("isEnabled").to(this), i.fieldView.inputMode = "url", i.fieldView.placeholder = "https://example.com/image.png", i.fieldView.bind("value").to(this, "imageURLInputValue", n => n || ""), i.fieldView.on("input", () => {
            this.imageURLInputValue = i.fieldView.element.value.trim()
        }), i
    }

    focus() {
        this.urlInputView.focus()
    }
}

class Ox extends w {
    _imageInsertUI;
    _formView;

    static get pluginName() {
        return "ImageInsertViaUrlUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Kn, Me]
    }

    init() {
        this.editor.ui.componentFactory.add("insertImageViaUrl", () => this._createToolbarButton()), this.editor.ui.componentFactory.add("menuBar:insertImageViaUrl", () => this._createMenuBarButton("standalone"))
    }

    afterInit() {
        this._imageInsertUI = this.editor.plugins.get("ImageInsertUI"), this._imageInsertUI.registerIntegration({
            name: "url",
            observable: () => this.editor.commands.get("insertImage"),
            buttonViewCreator: () => this._createToolbarButton(),
            formViewCreator: () => this._createDropdownButton(),
            menuBarButtonViewCreator: e => this._createMenuBarButton(e ? "insertOnly" : "insertNested")
        })
    }

    _createInsertUrlButton(e) {
        const t = new e(this.editor.locale);
        return t.icon = s1, t.on("execute", () => {
            this._showModal()
        }), t
    }

    _createToolbarButton() {
        const e = this.editor.locale.t, t = this._createInsertUrlButton(I);
        return t.tooltip = !0, t.bind("label").to(this._imageInsertUI, "isImageSelected", i => e(i ? "Update image URL" : "Insert image via URL")), t
    }

    _createDropdownButton() {
        const e = this.editor.locale.t, t = this._createInsertUrlButton(I);
        return t.withText = !0, t.bind("label").to(this._imageInsertUI, "isImageSelected", i => e(i ? "Update image URL" : "Insert via URL")), t
    }

    _createMenuBarButton(e) {
        const t = this.editor.locale.t, i = this._createInsertUrlButton(K);
        switch (i.withText = !0, e) {
            case"standalone":
                i.label = t("Image via URL");
                break;
            case"insertOnly":
                i.label = t("Image");
                break;
            case"insertNested":
                i.label = t("Via URL");
                break
        }
        return i
    }

    _createInsertUrlView() {
        const e = this.editor, t = e.locale, i = e.commands.get("replaceImageSource"),
            n = e.commands.get("insertImage"), o = new Vx(t);
        return o.bind("isImageSelected").to(this._imageInsertUI), o.bind("isEnabled").toMany([n, i], "isEnabled", (...r) => r.some(a => a)), o
    }

    _showModal() {
        const e = this.editor, i = e.locale.t, n = e.plugins.get("Dialog");
        this._formView || (this._formView = this._createInsertUrlView(), this._formView.on("submit", () => this._handleSave()));
        const o = e.commands.get("replaceImageSource");
        this._formView.imageURLInputValue = o.value || "", n.show({
            id: "insertImageViaUrl",
            title: i("Image via URL"),
            isModal: !0,
            content: this._formView,
            actionButtons: [{
                label: i("Cancel"),
                withText: !0,
                onExecute: () => n.hide()
            }, {
                label: this._imageInsertUI.isImageSelected ? i("Save") : i("Insert"),
                class: "ck-button-action",
                withText: !0,
                onExecute: () => this._handleSave()
            }]
        })
    }

    _handleSave() {
        this.editor.commands.get("replaceImageSource").isEnabled ? this.editor.execute("replaceImageSource", {source: this._formView.imageURLInputValue}) : this.editor.execute("insertImage", {source: this._formView.imageURLInputValue}), this.editor.plugins.get("Dialog").hide()
    }
}

class zm extends w {
    static get pluginName() {
        return "ImageInsertViaUrl"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Ox, Kn]
    }
}

class Mx extends w {
    static get pluginName() {
        return "ImageInsert"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Nm, zm, Kn]
    }
}

class Bx extends O {
    refresh() {
        const e = this.editor,
            i = e.plugins.get("ImageUtils").getClosestSelectedImageElement(e.model.document.selection);
        this.isEnabled = !!i, !i || !i.hasAttribute("resizedWidth") ? this.value = null : this.value = {
            width: i.getAttribute("resizedWidth"),
            height: null
        }
    }

    execute(e) {
        const t = this.editor, i = t.model, n = t.plugins.get("ImageUtils"),
            o = n.getClosestSelectedImageElement(i.document.selection);
        this.value = {width: e.width, height: null}, o && i.change(r => {
            r.setAttribute("resizedWidth", e.width, o), r.removeAttribute("resizedHeight", o), n.setImageNaturalSizeAttributes(o)
        })
    }
}

class Hm extends w {
    static get requires() {
        return [we]
    }

    static get pluginName() {
        return "ImageResizeEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    constructor(e) {
        super(e), e.config.define("image", {
            resizeUnit: "%",
            resizeOptions: [{name: "resizeImage:original", value: null, icon: "original"}, {
                name: "resizeImage:custom",
                value: "custom",
                icon: "custom"
            }, {name: "resizeImage:25", value: "25", icon: "small"}, {
                name: "resizeImage:50",
                value: "50",
                icon: "medium"
            }, {name: "resizeImage:75", value: "75", icon: "large"}]
        })
    }

    init() {
        const e = this.editor, t = new Bx(e);
        this._registerConverters("imageBlock"), this._registerConverters("imageInline"), e.commands.add("resizeImage", t), e.commands.add("imageResize", t)
    }

    afterInit() {
        this._registerSchema()
    }

    _registerSchema() {
        this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", {allowAttributes: ["resizedWidth", "resizedHeight"]}), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", {allowAttributes: ["resizedWidth", "resizedHeight"]})
    }

    _registerConverters(e) {
        const t = this.editor, i = t.plugins.get("ImageUtils");
        t.conversion.for("downcast").add(n => n.on(`attribute:resizedWidth:${e}`, (o, r, a) => {
            if (!a.consumable.consume(r.item, o.name)) return;
            const l = a.writer, c = a.mapper.toViewElement(r.item);
            r.attributeNewValue !== null ? (l.setStyle("width", r.attributeNewValue, c), l.addClass("image_resized", c)) : (l.removeStyle("width", c), l.removeClass("image_resized", c))
        })), t.conversion.for("dataDowncast").attributeToAttribute({
            model: {name: e, key: "resizedHeight"},
            view: n => ({key: "style", value: {height: n}})
        }), t.conversion.for("editingDowncast").add(n => n.on(`attribute:resizedHeight:${e}`, (o, r, a) => {
            if (!a.consumable.consume(r.item, o.name)) return;
            const l = a.writer, c = a.mapper.toViewElement(r.item),
                u = e === "imageInline" ? i.findViewImgElement(c) : c;
            r.attributeNewValue !== null ? l.setStyle("height", r.attributeNewValue, u) : l.removeStyle("height", u)
        })), t.conversion.for("upcast").attributeToAttribute({
            view: {
                name: e === "imageBlock" ? "figure" : "img",
                styles: {width: /.+/}
            }, model: {key: "resizedWidth", value: n => qs(n) ? null : n.getStyle("width")}
        }), t.conversion.for("upcast").attributeToAttribute({
            view: {
                name: e === "imageBlock" ? "figure" : "img",
                styles: {height: /.+/}
            }, model: {key: "resizedHeight", value: n => qs(n) ? null : n.getStyle("height")}
        }), t.conversion.for("upcast").add(n => {
            n.on(`element:${e === "imageBlock" ? "figure" : "img"}`, (o, r, a) => {
                a.consumable.consume(r.viewItem, {classes: ["image_resized"]})
            })
        })
    }
}

const Qo = {small: p1, medium: g1, large: m1, custom: h1, original: f1};

class Fx extends w {
    static get requires() {
        return [Hm]
    }

    static get pluginName() {
        return "ImageResizeButtons"
    }

    static get isOfficialPlugin() {
        return !0
    }

    _resizeUnit;

    constructor(e) {
        super(e), this._resizeUnit = e.config.get("image.resizeUnit")
    }

    init() {
        const e = this.editor, t = e.config.get("image.resizeOptions"), i = e.commands.get("resizeImage");
        this.bind("isEnabled").to(i);
        for (const n of t) this._registerImageResizeButton(n);
        this._registerImageResizeDropdown(t)
    }

    _registerImageResizeButton(e) {
        const t = this.editor, {name: i, value: n, icon: o} = e;
        t.ui.componentFactory.add(i, r => {
            const a = new I(r), l = t.commands.get("resizeImage"), c = this._getOptionLabelValue(e, !0);
            if (!Qo[o]) throw new p("imageresizebuttons-missing-icon", t, e);
            if (a.set({
                label: c,
                icon: Qo[o],
                tooltip: c,
                isToggleable: !0
            }), a.bind("isEnabled").to(this), t.plugins.has("ImageCustomResizeUI") && hn(e)) {
                const u = t.plugins.get("ImageCustomResizeUI");
                this.listenTo(a, "execute", () => {
                    u._showForm(this._resizeUnit)
                })
            } else {
                const u = n ? n + this._resizeUnit : null;
                a.bind("isOn").to(l, "value", l, "isEnabled", Ir(u)), this.listenTo(a, "execute", () => {
                    t.execute("resizeImage", {width: u})
                })
            }
            return a
        })
    }

    _registerImageResizeDropdown(e) {
        const t = this.editor, i = t.t, n = e.find(r => !r.value), o = r => {
            const a = t.commands.get("resizeImage"), l = Ae(r, Hf), c = l.buttonView, u = i("Resize image");
            return c.set({
                tooltip: u,
                commandValue: n.value,
                icon: Qo.medium,
                isToggleable: !0,
                label: this._getOptionLabelValue(n),
                withText: !0,
                class: "ck-resize-image-button",
                ariaLabel: u,
                ariaLabelledBy: void 0
            }), c.bind("label").to(a, "value", d => d && d.width ? d.width : this._getOptionLabelValue(n)), l.bind("isEnabled").to(this), jn(l, () => this._getResizeDropdownListItemDefinitions(e, a), {
                ariaLabel: i("Image resize list"),
                role: "menu"
            }), this.listenTo(l, "execute", d => {
                "onClick" in d.source ? d.source.onClick() : (t.execute(d.source.commandName, {width: d.source.commandValue}), t.editing.view.focus())
            }), l
        };
        t.ui.componentFactory.add("resizeImage", o), t.ui.componentFactory.add("imageResize", o)
    }

    _getOptionLabelValue(e, t = !1) {
        const i = this.editor.t;
        return e.label ? e.label : t ? hn(e) ? i("Custom image size") : e.value ? i("Resize image to %0", e.value + this._resizeUnit) : i("Resize image to the original size") : hn(e) ? i("Custom") : e.value ? e.value + this._resizeUnit : i("Original")
    }

    _getResizeDropdownListItemDefinitions(e, t) {
        const {editor: i} = this, n = new ce, o = e.map(r => hn(r) ? {...r, valueWithUnits: "custom"} : r.value ? {
            ...r,
            valueWithUnits: `${r.value}${this._resizeUnit}`
        } : {...r, valueWithUnits: null});
        for (const r of o) {
            let a = null;
            if (i.plugins.has("ImageCustomResizeUI") && hn(r)) {
                const l = i.plugins.get("ImageCustomResizeUI");
                a = {
                    type: "button",
                    model: new qi({
                        label: this._getOptionLabelValue(r),
                        role: "menuitemradio",
                        withText: !0,
                        icon: null,
                        onClick: () => {
                            l._showForm(this._resizeUnit)
                        }
                    })
                };
                const c = Object.values(o).map(u => u.valueWithUnits);
                a.model.bind("isOn").to(t, "value", t, "isEnabled", Lx(c))
            } else a = {
                type: "button",
                model: new qi({
                    commandName: "resizeImage",
                    commandValue: r.valueWithUnits,
                    label: this._getOptionLabelValue(r),
                    role: "menuitemradio",
                    withText: !0,
                    icon: null
                })
            }, a.model.bind("isOn").to(t, "value", t, "isEnabled", Ir(r.valueWithUnits));
            a.model.bind("isEnabled").to(t, "isEnabled"), n.add(a)
        }
        return n
    }
}

function hn(s) {
    return s.value === "custom"
}

function Ir(s) {
    return (e, t) => {
        const i = e;
        return i === void 0 || !t ? !1 : s === null && i === s ? !0 : i !== null && i.width === s
    }
}

function Lx(s) {
    return (e, t) => !s.some(i => Ir(i)(e, t))
}

const Dx = "figure.image.ck-widget > img,figure.image.ck-widget > picture > img,figure.image.ck-widget > a > img,figure.image.ck-widget > a > picture > img,span.image-inline.ck-widget > img,span.image-inline.ck-widget > picture > img",
    Yo = "image_resized";

class Nx extends w {
    static get requires() {
        return [Go, we]
    }

    static get pluginName() {
        return "ImageResizeHandles"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor.commands.get("resizeImage");
        this.bind("isEnabled").to(e), this._setupResizerCreator()
    }

    _setupResizerCreator() {
        const e = this.editor, t = e.editing.view, i = e.plugins.get("ImageUtils");
        t.addObserver(Ra), this.listenTo(t.document, "imageLoaded", (n, o) => {
            if (!o.target.matches(Dx)) return;
            const r = e.editing.view.domConverter, a = r.domToView(o.target), l = i.getImageWidgetFromImageView(a);
            let c = this.editor.plugins.get(Go).getResizerByViewElement(l);
            if (c) {
                c.redraw();
                return
            }
            const u = e.editing.mapper, d = u.toModelElement(l);
            c = e.plugins.get(Go).attachTo({
                unit: e.config.get("image.resizeUnit"),
                modelElement: d,
                viewElement: l,
                editor: e,
                getHandleHost(h) {
                    return h.querySelector("img")
                },
                getResizeHost() {
                    return r.mapViewToDom(u.toViewElement(d))
                },
                isCentered() {
                    return d.getAttribute("imageStyle") == "alignCenter"
                },
                onCommit(h) {
                    t.change(f => {
                        f.removeClass(Yo, l)
                    }), e.execute("resizeImage", {width: h})
                }
            }), c.on("updateSize", () => {
                l.hasClass(Yo) || t.change(f => {
                    f.addClass(Yo, l)
                });
                const h = d.name === "imageInline" ? a : l;
                h.getStyle("height") && t.change(f => {
                    f.removeStyle("height", h)
                })
            }), c.bind("isEnabled").to(this)
        })
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Um(s) {
    if (!s) return null;
    const [, e, t] = s.trim().match(/([.,\d]+)(%|px)$/) || [], i = Number.parseFloat(e);
    return Number.isNaN(i) ? null : {value: i, unit: t}
}

function $m(s, e, t) {
    return t === "px" ? {value: e.value, unit: "px"} : {value: e.value / s * 100, unit: "%"}
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Wm(s) {
    const {editing: e} = s, i = s.plugins.get("ImageUtils").getClosestSelectedImageElement(s.model.document.selection);
    if (!i) return null;
    const n = e.mapper.toViewElement(i), o = e.view.domConverter.mapViewToDom(n);
    return {model: i, view: n, dom: o}
}

function zx(s, e) {
    const t = Wm(s);
    if (!t) return null;
    const i = Um(t.model.getAttribute("resizedWidth") || null);
    if (!i) return null;
    if (i.unit === e) return i;
    const n = Ca(t.dom), o = {value: new R(t.dom).width};
    return $m(n, o, e)
}

class Hx extends T {
    focusTracker;
    keystrokes;
    unit;
    backButtonView;
    saveButtonView;
    labeledInput;
    children;
    _focusables;
    _focusCycler;
    _validators;

    constructor(e, t, i) {
        super(e), this.focusTracker = new se, this.keystrokes = new ue, this.unit = t, this.backButtonView = this._createBackButton(), this.saveButtonView = this._createSaveButton(), this.labeledInput = this._createLabeledInputView(), this.children = this.createCollection([this._createHeaderView()]), this.children.add(new Hs(e, {
            children: [this.labeledInput, this.saveButtonView],
            class: ["ck-form__row_with-submit", "ck-form__row_large-top-padding"]
        })), this._focusables = new Ie, this._validators = i, this.keystrokes.set("Esc", (n, o) => {
            this.fire("cancel"), o()
        }), this._focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"}
        }), this.setTemplate({
            tag: "form",
            attributes: {class: ["ck", "ck-form", "ck-image-custom-resize-form", "ck-responsive-form"], tabindex: "-1"},
            children: this.children
        })
    }

    render() {
        super.render(), li({view: this}), [this.backButtonView, this.labeledInput, this.saveButtonView].forEach(t => {
            this._focusables.add(t), this.focusTracker.add(t.element)
        }), this.keystrokes.listenTo(this.element)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    _createBackButton() {
        const e = this.locale.t, t = new I(this.locale);
        return t.set({
            class: "ck-button-back",
            label: e("Back"),
            icon: Ht,
            tooltip: !0
        }), t.delegate("execute").to(this, "cancel"), t
    }

    _createSaveButton() {
        const e = this.locale.t, t = new I(this.locale);
        return t.set({label: e("Save"), withText: !0, type: "submit", class: "ck-button-action ck-button-bold"}), t
    }

    _createHeaderView() {
        const e = this.locale.t, t = new ci(this.locale, {label: e("Image Resize")});
        return t.children.add(this.backButtonView, 0), t
    }

    _createLabeledInputView() {
        const e = this.locale.t, t = new Ut(this.locale, Qy);
        return t.label = e("Resize image (in %0)", this.unit), t.class = "ck-labeled-field-view_full-width", t.fieldView.set({step: .1}), t
    }

    isValid() {
        this.resetFormStatus();
        for (const e of this._validators) {
            const t = e(this);
            if (t) return this.labeledInput.errorText = t, !1
        }
        return !0
    }

    resetFormStatus() {
        this.labeledInput.errorText = null
    }

    get rawSize() {
        const {element: e} = this.labeledInput.fieldView;
        return e ? e.value : null
    }

    get parsedSize() {
        const {rawSize: e} = this;
        if (e === null) return null;
        const t = Number.parseFloat(e);
        return Number.isNaN(t) ? null : t
    }

    get sizeWithUnits() {
        const {parsedSize: e, unit: t} = this;
        return e === null ? null : `${e}${t}`
    }
}

function Ux(s, e) {
    const t = Wm(s);
    if (!t) return null;
    const i = Ca(t.dom), n = Um(window.getComputedStyle(t.dom).minWidth) || {value: 1},
        o = Math.max(.1, $m(i, n, e).value);
    return {unit: e, lower: o, upper: e === "px" ? i : 100}
}

class $x extends w {
    _balloon;
    _form;

    static get requires() {
        return [ii]
    }

    static get pluginName() {
        return "ImageCustomResizeUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    destroy() {
        super.destroy(), this._form && this._form.destroy()
    }

    _createForm(e) {
        const t = this.editor;
        this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new ($i(Hx))(t.locale, e, Wx(t)), this._form.render(), this.listenTo(this._form, "submit", () => {
            this._form.isValid() && (t.execute("resizeImage", {width: this._form.sizeWithUnits}), this._hideForm(!0))
        }), this.listenTo(this._form.labeledInput, "change:errorText", () => {
            t.ui.update()
        }), this.listenTo(this._form, "cancel", () => {
            this._hideForm(!0)
        }), Ji({
            emitter: this._form,
            activator: () => this._isVisible,
            contextElements: () => [this._balloon.view.element],
            callback: () => this._hideForm()
        })
    }

    _showForm(e) {
        if (this._isVisible) return;
        this._form || this._createForm(e);
        const t = this.editor, i = this._form.labeledInput;
        this._form.disableCssTransitions(), this._form.resetFormStatus(), this._isInBalloon || this._balloon.add({
            view: this._form,
            position: Sa(t)
        });
        const n = zx(t, e), o = n ? n.value.toFixed(1) : "", r = Ux(t, e);
        i.fieldView.value = i.fieldView.element.value = o, r && Object.assign(i.fieldView, {
            min: r.lower.toFixed(1),
            max: Math.ceil(r.upper).toFixed(1)
        }), this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions()
    }

    _hideForm(e = !1) {
        this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), e && this.editor.editing.view.focus())
    }

    get _isVisible() {
        return !!this._balloon && this._balloon.visibleView === this._form
    }

    get _isInBalloon() {
        return !!this._balloon && this._balloon.hasView(this._form)
    }
}

function Wx(s) {
    const e = s.t;
    return [t => {
        if (t.rawSize.trim() === "") return e("The value must not be empty.");
        if (t.parsedSize === null) return e("The value should be a plain number.")
    }]
}

class qx extends w {
    static get requires() {
        return [Hm, Nx, $x, Fx]
    }

    static get pluginName() {
        return "ImageResize"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

class jx extends O {
    _defaultStyles;
    _styles;

    constructor(e, t) {
        super(e), this._defaultStyles = {imageBlock: !1, imageInline: !1}, this._styles = new Map(t.map(i => {
            if (i.isDefault) for (const n of i.modelElements) this._defaultStyles[n] = i.name;
            return [i.name, i]
        }))
    }

    refresh() {
        const i = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
        this.isEnabled = !!i, this.isEnabled ? i.hasAttribute("imageStyle") ? this.value = i.getAttribute("imageStyle") : this.value = this._defaultStyles[i.name] : this.value = !1
    }

    execute(e = {}) {
        const t = this.editor, i = t.model, n = t.plugins.get("ImageUtils");
        i.change(o => {
            const r = e.value, {setImageSizes: a = !0} = e;
            let l = n.getClosestSelectedImageElement(i.document.selection);
            r && this.shouldConvertImageType(r, l) && (this.editor.execute(n.isBlockImage(l) ? "imageTypeInline" : "imageTypeBlock", {setImageSizes: a}), l = n.getClosestSelectedImageElement(i.document.selection)), !r || this._styles.get(r).isDefault ? o.removeAttribute("imageStyle", l) : o.setAttribute("imageStyle", r, l), a && n.setImageNaturalSizeAttributes(l)
        })
    }

    shouldConvertImageType(e, t) {
        return !this._styles.get(e).modelElements.includes(t.name)
    }
}

const Es = {
    get inline() {
        return {name: "inline", title: "In line", icon: wf, modelElements: ["imageInline"], isDefault: !0}
    }, get alignLeft() {
        return {
            name: "alignLeft",
            title: "Left aligned image",
            icon: pf,
            modelElements: ["imageBlock", "imageInline"],
            className: "image-style-align-left"
        }
    }, get alignBlockLeft() {
        return {
            name: "alignBlockLeft",
            title: "Left aligned image",
            icon: bf,
            modelElements: ["imageBlock"],
            className: "image-style-block-align-left"
        }
    }, get alignCenter() {
        return {
            name: "alignCenter",
            title: "Centered image",
            icon: yr,
            modelElements: ["imageBlock"],
            className: "image-style-align-center"
        }
    }, get alignRight() {
        return {
            name: "alignRight",
            title: "Right aligned image",
            icon: kr,
            modelElements: ["imageBlock", "imageInline"],
            className: "image-style-align-right"
        }
    }, get alignBlockRight() {
        return {
            name: "alignBlockRight",
            title: "Right aligned image",
            icon: _f,
            modelElements: ["imageBlock"],
            className: "image-style-block-align-right"
        }
    }, get block() {
        return {name: "block", title: "Centered image", icon: yr, modelElements: ["imageBlock"], isDefault: !0}
    }, get side() {
        return {
            name: "side",
            title: "Side image",
            icon: kr,
            modelElements: ["imageBlock"],
            className: "image-style-side"
        }
    }
}, qm = {full: d1, left: bf, right: _f, center: yr, inlineLeft: pf, inlineRight: kr, inline: wf}, jm = [{
    name: "imageStyle:wrapText",
    title: "Wrap text",
    defaultItem: "imageStyle:alignLeft",
    items: ["imageStyle:alignLeft", "imageStyle:alignRight"]
}, {
    name: "imageStyle:breakText",
    title: "Break text",
    defaultItem: "imageStyle:block",
    items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"]
}];

function Gx(s) {
    return (s.configuredStyles.options || []).map(i => Jx(i)).filter(i => Qx(i, s))
}

function Kx(s, e) {
    return s && e ? {options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"]} : s ? {options: ["block", "side"]} : e ? {options: ["inline", "alignLeft", "alignRight"]} : {}
}

function Zx(s) {
    return s.has("ImageBlockEditing") && s.has("ImageInlineEditing") ? [...jm] : []
}

function Jx(s) {
    return typeof s == "string" ? Es[s] ? s = {...Es[s]} : s = {name: s} : s = Yx(Es[s.name], s), typeof s.icon == "string" && (s.icon = qm[s.icon] || s.icon), s
}

function Qx(s, {isBlockPluginLoaded: e, isInlinePluginLoaded: t}) {
    const {modelElements: i, name: n} = s;
    if (!i || !i.length || !n) return Gm({style: s}), !1;
    {
        const o = [e ? "imageBlock" : null, t ? "imageInline" : null];
        if (!i.some(r => o.includes(r))) return L("image-style-missing-dependency", {
            style: s,
            missingPlugins: i.map(r => r === "imageBlock" ? "ImageBlockEditing" : "ImageInlineEditing")
        }), !1
    }
    return !0
}

function Yx(s, e) {
    const t = {...e};
    for (const i in s) Object.prototype.hasOwnProperty.call(e, i) || (t[i] = s[i]);
    return t
}

function Gm(s) {
    L("image-style-configuration-definition-invalid", s)
}

var Sr = {
    normalizeStyles: Gx,
    getDefaultStylesConfiguration: Kx,
    getDefaultDropdownDefinitions: Zx,
    warnInvalidStyle: Gm,
    DEFAULT_OPTIONS: Es,
    DEFAULT_ICONS: qm,
    DEFAULT_DROPDOWN_DEFINITIONS: jm
};

function Xx(s) {
    return (e, t, i) => {
        if (!i.consumable.consume(t.item, e.name)) return;
        const n = Ru(t.attributeNewValue, s), o = Ru(t.attributeOldValue, s), r = i.mapper.toViewElement(t.item),
            a = i.writer;
        o && a.removeClass(o.className, r), n && a.addClass(n.className, r)
    }
}

function eI(s) {
    const e = {
        imageInline: s.filter(t => !t.isDefault && t.modelElements.includes("imageInline")),
        imageBlock: s.filter(t => !t.isDefault && t.modelElements.includes("imageBlock"))
    };
    return (t, i, n) => {
        if (!i.modelRange) return;
        const o = i.viewItem, r = re(i.modelRange.getItems());
        if (r && n.schema.checkAttribute(r, "imageStyle")) for (const a of e[r.name]) n.consumable.consume(o, {classes: a.className}) && n.writer.setAttribute("imageStyle", a.name, r)
    }
}

function Ru(s, e) {
    for (const t of e) if (t.name === s) return t
}

class Km extends w {
    static get pluginName() {
        return "ImageStyleEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [we]
    }

    normalizedStyles;

    init() {
        const {normalizeStyles: e, getDefaultStylesConfiguration: t} = Sr, i = this.editor,
            n = i.plugins.has("ImageBlockEditing"), o = i.plugins.has("ImageInlineEditing");
        i.config.define("image.styles", t(n, o)), this.normalizedStyles = e({
            configuredStyles: i.config.get("image.styles"),
            isBlockPluginLoaded: n,
            isInlinePluginLoaded: o
        }), this._setupConversion(n, o), this._setupPostFixer(), i.commands.add("imageStyle", new jx(i, this.normalizedStyles))
    }

    _setupConversion(e, t) {
        const i = this.editor, n = i.model.schema, o = Xx(this.normalizedStyles), r = eI(this.normalizedStyles);
        i.editing.downcastDispatcher.on("attribute:imageStyle", o), i.data.downcastDispatcher.on("attribute:imageStyle", o), e && (n.extend("imageBlock", {allowAttributes: "imageStyle"}), i.data.upcastDispatcher.on("element:figure", r, {priority: "low"})), t && (n.extend("imageInline", {allowAttributes: "imageStyle"}), i.data.upcastDispatcher.on("element:img", r, {priority: "low"}))
    }

    _setupPostFixer() {
        const e = this.editor, t = e.model.document, i = e.plugins.get(we),
            n = new Map(this.normalizedStyles.map(o => [o.name, o]));
        t.registerPostFixer(o => {
            let r = !1;
            for (const a of t.differ.getChanges()) if (a.type == "insert" || a.type == "attribute" && a.attributeKey == "imageStyle") {
                let l = a.type == "insert" ? a.position.nodeAfter : a.range.start.nodeAfter;
                if (l && l.is("element", "paragraph") && l.childCount > 0 && (l = l.getChild(0)), !i.isImage(l)) continue;
                const c = l.getAttribute("imageStyle");
                if (!c) continue;
                const u = n.get(c);
                (!u || !u.modelElements.includes(l.name)) && (o.removeAttribute("imageStyle", l), r = !0)
            }
            return r
        })
    }
}

class tI extends w {
    static get requires() {
        return [Km]
    }

    static get pluginName() {
        return "ImageStyleUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    get localizedDefaultStylesTitles() {
        const e = this.editor.t;
        return {
            "Wrap text": e("Wrap text"),
            "Break text": e("Break text"),
            "In line": e("In line"),
            "Full size image": e("Full size image"),
            "Side image": e("Side image"),
            "Left aligned image": e("Left aligned image"),
            "Centered image": e("Centered image"),
            "Right aligned image": e("Right aligned image")
        }
    }

    init() {
        const e = this.editor.plugins, t = this.editor.config.get("image.toolbar") || [],
            i = e.get("ImageStyleEditing"), n = Vu(i.normalizedStyles, this.localizedDefaultStylesTitles);
        for (const r of n) this._createButton(r);
        const o = Vu([...t.filter(tt), ...Sr.getDefaultDropdownDefinitions(e)], this.localizedDefaultStylesTitles);
        for (const r of o) this._createDropdown(r, n)
    }

    _createDropdown(e, t) {
        const i = this.editor.ui.componentFactory;
        i.add(e.name, n => {
            let o;
            const {defaultItem: r, items: a, title: l} = e,
                c = a.filter(f => t.find(({name: m}) => Ou(m) === f)).map(f => {
                    const m = i.create(f);
                    return f === r && (o = m), m
                });
            a.length !== c.length && Sr.warnInvalidStyle({dropdown: e});
            const u = Ae(n, Wn), d = u.buttonView, h = d.arrowView;
            return qn(u, c, {enableActiveItemFocusOnDropdownOpen: !0}), d.set({
                label: Mu(l, o.label),
                class: null,
                tooltip: !0
            }), h.unbind("label"), h.set({label: l}), d.bind("icon").toMany(c, "isOn", (...f) => {
                const m = f.findIndex(Ti);
                return m < 0 ? o.icon : c[m].icon
            }), d.bind("label").toMany(c, "isOn", (...f) => {
                const m = f.findIndex(Ti);
                return Mu(l, m < 0 ? o.label : c[m].label)
            }), d.bind("isOn").toMany(c, "isOn", (...f) => f.some(Ti)), d.bind("class").toMany(c, "isOn", (...f) => f.some(Ti) ? "ck-splitbutton_flatten" : void 0), d.on("execute", () => {
                c.some(({isOn: f}) => f) ? u.isOpen = !u.isOpen : o.fire("execute")
            }), u.bind("isEnabled").toMany(c, "isEnabled", (...f) => f.some(Ti)), this.listenTo(u, "execute", () => {
                this.editor.editing.view.focus()
            }), u
        })
    }

    _createButton(e) {
        const t = e.name;
        this.editor.ui.componentFactory.add(Ou(t), i => {
            const n = this.editor.commands.get("imageStyle"), o = new I(i);
            return o.set({
                label: e.title,
                icon: e.icon,
                tooltip: !0,
                isToggleable: !0
            }), o.bind("isEnabled").to(n, "isEnabled"), o.bind("isOn").to(n, "value", r => r === t), o.on("execute", this._executeCommand.bind(this, t)), o
        })
    }

    _executeCommand(e) {
        this.editor.execute("imageStyle", {value: e}), this.editor.editing.view.focus()
    }
}

function Vu(s, e) {
    for (const t of s) e[t.title] && (t.title = e[t.title]);
    return s
}

function Ou(s) {
    return `imageStyle:${s}`
}

function Mu(s, e) {
    return (s ? s + ": " : "") + e
}

class iI extends w {
    static get requires() {
        return [Km, tI]
    }

    static get pluginName() {
        return "ImageStyle"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

class nI extends w {
    static get requires() {
        return [$s, we]
    }

    static get pluginName() {
        return "ImageToolbar"
    }

    static get isOfficialPlugin() {
        return !0
    }

    afterInit() {
        const e = this.editor, t = e.t, i = e.plugins.get($s), n = e.plugins.get("ImageUtils");
        i.register("image", {
            ariaLabel: t("Image toolbar"),
            items: sI(e.config.get("image.toolbar") || []),
            getRelatedElement: o => n.getClosestSelectedImageWidget(o)
        })
    }
}

function sI(s) {
    return s.map(e => tt(e) ? e.name : e)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class oI extends w {
    static get pluginName() {
        return "IndentEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        e.commands.add("indent", new Kl(e)), e.commands.add("outdent", new Kl(e))
    }
}

class rI extends w {
    static get pluginName() {
        return "IndentUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.locale, i = e.t, n = t.uiLanguageDirection == "ltr" ? ic : nc,
            o = t.uiLanguageDirection == "ltr" ? nc : ic;
        this._defineButton("indent", i("Increase indent"), n), this._defineButton("outdent", i("Decrease indent"), o)
    }

    _defineButton(e, t, i) {
        const n = this.editor;
        n.ui.componentFactory.add(e, () => {
            const o = this._createButton(I, e, t, i);
            return o.set({tooltip: !0}), o
        }), n.ui.componentFactory.add("menuBar:" + e, () => this._createButton(K, e, t, i))
    }

    _createButton(e, t, i, n) {
        const o = this.editor, r = o.commands.get(t), a = new e(o.locale);
        return a.set({label: i, icon: n}), a.bind("isEnabled").to(r, "isEnabled"), this.listenTo(a, "execute", () => {
            o.execute(t), o.editing.view.focus()
        }), a
    }
}

class aI extends w {
    static get pluginName() {
        return "Indent"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [oI, rI]
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class lI {
    _definitions = new Set;

    get length() {
        return this._definitions.size
    }

    add(e) {
        Array.isArray(e) ? e.forEach(t => this._definitions.add(t)) : this._definitions.add(e)
    }

    getDispatcher() {
        return e => {
            e.on("attribute:linkHref", (t, i, n) => {
                if (!n.consumable.test(i.item, "attribute:linkHref") || !(i.item.is("selection") || n.schema.isInline(i.item))) return;
                const o = n.writer, r = o.document.selection;
                for (const a of this._definitions) {
                    const l = o.createAttributeElement("a", a.attributes, {priority: 5});
                    a.classes && o.addClass(a.classes, l);
                    for (const c in a.styles) o.setStyle(c, a.styles[c], l);
                    o.setCustomProperty("link", !0, l), a.callback(i.attributeNewValue) ? i.item.is("selection") ? o.wrap(r.getFirstRange(), l) : o.wrap(n.mapper.toViewRange(i.range), l) : o.unwrap(n.mapper.toViewRange(i.range), l)
                }
            }, {priority: "high"})
        }
    }

    getDispatcherForLinkedImage() {
        return e => {
            e.on("attribute:linkHref:imageBlock", (t, i, {writer: n, mapper: o}) => {
                const r = o.toViewElement(i.item), a = Array.from(r.getChildren()).find(l => l.is("element", "a"));
                if (a) for (const l of this._definitions) {
                    const c = nt(l.attributes);
                    if (l.callback(i.attributeNewValue)) {
                        for (const [u, d] of c) u === "class" ? n.addClass(d, a) : n.setAttribute(u, d, a);
                        l.classes && n.addClass(l.classes, a);
                        for (const u in l.styles) n.setStyle(u, l.styles[u], a)
                    } else {
                        for (const [u, d] of c) u === "class" ? n.removeClass(d, a) : n.removeAttribute(u, a);
                        l.classes && n.removeClass(l.classes, a);
                        for (const u in l.styles) n.removeStyle(u, a)
                    }
                }
            })
        }
    }
}

const cI = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
    uI = "^(?:(?:<protocols>):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))",
    dI = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i,
    hI = /^((\w+:(\/{2,})?)|(\W))/i, fI = ["https?", "ftps?", "mailto"], pn = "Ctrl+K";

function mI(s) {
    return s.is("attributeElement") && !!s.getCustomProperty("link")
}

function Bu(s, {writer: e}) {
    const t = e.createAttributeElement("a", {href: s}, {priority: 5});
    return e.setCustomProperty("link", !0, t), t
}

function Zm(s, e = fI) {
    const t = String(s), i = e.join("|"), n = new RegExp(`${uI.replace("<protocols>", i)}`, "i");
    return gI(t, n) ? t : "#"
}

function gI(s, e) {
    return !!s.replace(cI, "").match(e)
}

function pI(s, e) {
    const t = {"Open in a new tab": s("Open in a new tab"), Downloadable: s("Downloadable")};
    return e.forEach(i => ("label" in i && t[i.label] && (i.label = t[i.label]), i)), e
}

function wI(s) {
    const e = [];
    if (s) for (const [t, i] of Object.entries(s)) {
        const n = Object.assign({}, i, {id: `link${op(t)}`});
        e.push(n)
    }
    return e
}

function Pr(s, e) {
    return s ? e.checkAttribute(s.name, "linkHref") : !1
}

function bI(s) {
    return dI.test(s)
}

function Va(s, e) {
    const t = bI(s) ? "mailto:" : e, i = !!t && !Jm(s);
    return s && i ? t + s : s
}

function Jm(s) {
    return hI.test(s)
}

function _I(s) {
    window.open(s, "_blank", "noopener")
}

function Rr(s) {
    let e = "";
    for (const t of s.getItems()) {
        if (!t.is("$text") && !t.is("$textProxy")) return;
        e += t.data
    }
    return e
}

class vI extends O {
    manualDecorators = new ce;
    automaticDecorators = new lI;

    restoreManualDecoratorStates() {
        for (const e of this.manualDecorators) e.value = this._getDecoratorStateFromModel(e.id)
    }

    refresh() {
        const e = this.editor.model, t = e.document.selection, i = t.getSelectedElement() || re(t.getSelectedBlocks());
        Pr(i, e.schema) ? (this.value = i.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttribute(i, "linkHref")) : (this.value = t.getAttribute("linkHref"), this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref"));
        for (const n of this.manualDecorators) n.value = this._getDecoratorStateFromModel(n.id)
    }

    execute(e, t = {}, i) {
        const n = this.editor.model, o = n.document.selection, r = [], a = [];
        for (const l in t) t[l] ? r.push(l) : a.push(l);
        n.change(l => {
            const c = h => {
                l.setAttribute("linkHref", e, h), r.forEach(f => l.setAttribute(f, !0, h)), a.forEach(f => l.removeAttribute(f, h))
            }, u = (h, f) => {
                const m = Rr(h);
                if (!m) return h;
                let g = i;
                if (g || (g = f && f == m ? e : m), g != m) {
                    const _ = yI(m, g);
                    let v = 0;
                    for (const {offset: E, actual: V, expected: N} of _) {
                        const Z = E + v, A = l.createRange(h.start.getShiftedBy(Z), h.start.getShiftedBy(Z + V.length)),
                            S = kI(A, h).getAttributes(),
                            P = Array.from(S).filter(([ve]) => n.schema.getAttributeProperties(ve).isFormatting),
                            J = l.createText(N, P);
                        c(J), n.insertContent(J, A), v += N.length
                    }
                    return l.createRange(h.start, h.start.getShiftedBy(g.length))
                }
            }, d = h => {
                const {plugins: f} = this.editor;
                if (l.setSelection(h.end), f.has("TwoStepCaretMovement")) f.get("TwoStepCaretMovement")._handleForwardMovement(); else for (const m of ["linkHref", ...r, ...a]) l.removeSelectionAttribute(m)
            };
            if (o.isCollapsed) {
                const h = o.getFirstPosition();
                if (o.hasAttribute("linkHref")) {
                    const f = o.getAttribute("linkHref"), m = ro(h, "linkHref", f, n), g = u(m, f);
                    c(g || m), g && d(g)
                } else if (e !== "") {
                    const f = nt(o.getAttributes());
                    f.set("linkHref", e), r.forEach(g => {
                        f.set(g, !0)
                    });
                    const m = n.insertContent(l.createText(i || e, f), h);
                    d(m)
                }
            } else {
                const h = Array.from(o.getRanges()), f = n.schema.getValidRanges(h, "linkHref"), m = [];
                for (const v of o.getSelectedBlocks()) n.schema.checkAttribute(v, "linkHref") && m.push(l.createRangeOn(v));
                const g = m.slice();
                for (const v of f) this._isRangeToUpdate(v, m) && g.push(v);
                const _ = h.map(v => ({
                    start: Y.fromPosition(v.start, "toPrevious"),
                    end: Y.fromPosition(v.end, "toNext")
                }));
                for (let v of g) {
                    const E = (v.start.textNode || v.start.nodeAfter).getAttribute("linkHref");
                    v = u(v, E) || v, c(v)
                }
                l.setSelection(_.map(v => {
                    const E = v.start.toPosition(), V = v.end.toPosition();
                    return v.start.detach(), v.end.detach(), n.createRange(E, V)
                }))
            }
        })
    }

    _getDecoratorStateFromModel(e) {
        const t = this.editor.model, i = t.document.selection, n = i.getSelectedElement();
        return Pr(n, t.schema) ? n.getAttribute(e) : i.getAttribute(e)
    }

    _isRangeToUpdate(e, t) {
        for (const i of t) if (i.containsRange(e)) return !1;
        return !0
    }
}

function yI(s, e) {
    const t = Bi(s, e), i = {equal: 0, insert: 0, delete: 0}, n = [];
    let o = "", r = "";
    for (const a of [...t, null]) a == "insert" ? r += e[i.equal + i.insert] : a == "delete" ? o += s[i.equal + i.delete] : (o.length || r.length) && (n.push({
        offset: i.equal,
        actual: o,
        expected: r
    }), o = "", r = ""), a && i[a]++;
    return n
}

function kI(s, e) {
    if (!s.isCollapsed) return re(s.getItems());
    const t = s.start;
    return t.textNode ? t.textNode : !t.nodeBefore || t.isEqual(e.start) ? t.nodeAfter : t.nodeBefore
}

class CI extends O {
    refresh() {
        const e = this.editor.model, t = e.document.selection, i = t.getSelectedElement();
        Pr(i, e.schema) ? this.isEnabled = e.schema.checkAttribute(i, "linkHref") : this.isEnabled = e.schema.checkAttributeInSelection(t, "linkHref")
    }

    execute() {
        const e = this.editor, t = this.editor.model, i = t.document.selection, n = e.commands.get("link");
        t.change(o => {
            const r = i.isCollapsed ? [ro(i.getFirstPosition(), "linkHref", i.getAttribute("linkHref"), t)] : t.schema.getValidRanges(i.getRanges(), "linkHref");
            for (const a of r) if (o.removeAttribute("linkHref", a), n) for (const l of n.manualDecorators) o.removeAttribute(l.id, a)
        })
    }
}

class EI extends H() {
    id;
    defaultValue;
    label;
    attributes;
    classes;
    styles;

    constructor({id: e, label: t, attributes: i, classes: n, styles: o, defaultValue: r}) {
        super(), this.id = e, this.set("value", void 0), this.defaultValue = r, this.label = t, this.attributes = i, this.classes = n, this.styles = o
    }

    _createPattern() {
        return {attributes: this.attributes, classes: this.classes, styles: this.styles}
    }
}

const TI = "ck-link_selected", Fu = "automatic", AI = "manual", xI = /^(https?:)?\/\//;

class Ki extends w {
    _linkOpeners = [];

    static get pluginName() {
        return "LinkEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Gc, sm, $e]
    }

    constructor(e) {
        super(e), e.config.define("link", {
            allowCreatingEmptyLinks: !1,
            addTargetToExternalLinks: !1,
            toolbar: ["linkPreview", "|", "editLink", "linkProperties", "unlink"]
        })
    }

    init() {
        const e = this.editor, t = this.editor.config.get("link.allowedProtocols");
        e.model.schema.extend("$text", {allowAttributes: "linkHref"}), e.conversion.for("dataDowncast").attributeToElement({
            model: "linkHref",
            view: Bu
        }), e.conversion.for("editingDowncast").attributeToElement({
            model: "linkHref",
            view: (o, r) => Bu(Zm(o, t), r)
        }), e.conversion.for("upcast").elementToAttribute({
            view: {name: "a", attributes: {href: !0}},
            model: {key: "linkHref", value: o => o.getAttribute("href")}
        }), e.commands.add("link", new vI(e)), e.commands.add("unlink", new CI(e));
        const i = pI(e.t, wI(e.config.get("link.decorators")));
        this._enableAutomaticDecorators(i.filter(o => o.mode === Fu)), this._enableManualDecorators(i.filter(o => o.mode === AI)), e.plugins.get(Gc).registerAttribute("linkHref"), bC(e, "linkHref", "a", TI), this._enableLinkOpen(), this._enableSelectionAttributesFixer(), this._enableClipboardIntegration()
    }

    _registerLinkOpener(e) {
        this._linkOpeners.push(e)
    }

    _enableAutomaticDecorators(e) {
        const t = this.editor, n = t.commands.get("link").automaticDecorators;
        t.config.get("link.addTargetToExternalLinks") && n.add({
            id: "linkIsExternal",
            mode: Fu,
            callback: o => !!o && xI.test(o),
            attributes: {target: "_blank", rel: "noopener noreferrer"}
        }), n.add(e), n.length && t.conversion.for("downcast").add(n.getDispatcher())
    }

    _enableManualDecorators(e) {
        if (!e.length) return;
        const t = this.editor, n = t.commands.get("link").manualDecorators;
        e.forEach(o => {
            t.model.schema.extend("$text", {allowAttributes: o.id});
            const r = new EI(o);
            n.add(r), t.conversion.for("downcast").attributeToElement({
                model: r.id,
                view: (a, {writer: l, schema: c}, {item: u}) => {
                    if ((u.is("selection") || c.isInline(u)) && a) {
                        const d = l.createAttributeElement("a", r.attributes, {priority: 5});
                        r.classes && l.addClass(r.classes, d);
                        for (const h in r.styles) l.setStyle(h, r.styles[h], d);
                        return l.setCustomProperty("link", !0, d), d
                    }
                }
            }), t.conversion.for("upcast").elementToAttribute({
                view: {name: "a", ...r._createPattern()},
                model: {key: r.id}
            })
        })
    }

    _enableLinkOpen() {
        const e = this.editor, i = e.editing.view.document, n = o => {
            this._linkOpeners.some(r => r(o)) || _I(o)
        };
        this.listenTo(i, "click", (o, r) => {
            if (!(x.isMac ? r.domEvent.metaKey : r.domEvent.ctrlKey)) return;
            let l = r.domTarget;
            if (l.tagName.toLowerCase() != "a" && (l = l.closest("a")), !l) return;
            const c = l.getAttribute("href");
            c && (o.stop(), r.preventDefault(), n(c))
        }, {context: "$capture"}), this.listenTo(i, "keydown", (o, r) => {
            const l = e.commands.get("link").value;
            l && r.keyCode === M.enter && r.altKey && (o.stop(), n(l))
        })
    }

    _enableSelectionAttributesFixer() {
        const t = this.editor.model, i = t.document.selection;
        this.listenTo(i, "change:attribute", (n, {attributeKeys: o}) => {
            !o.includes("linkHref") || i.hasAttribute("linkHref") || t.change(r => {
                II(r, SI(t.schema))
            })
        })
    }

    _enableClipboardIntegration() {
        const e = this.editor, t = e.model, i = this.editor.config.get("link.defaultProtocol");
        i && this.listenTo(e.plugins.get("ClipboardPipeline"), "contentInsertion", (n, o) => {
            t.change(r => {
                const a = r.createRangeIn(o.content);
                for (const l of a.getItems()) if (l.hasAttribute("linkHref")) {
                    const c = Va(l.getAttribute("linkHref"), i);
                    r.setAttribute("linkHref", c, l)
                }
            })
        })
    }
}

function II(s, e) {
    s.removeSelectionAttribute("linkHref");
    for (const t of e) s.removeSelectionAttribute(t)
}

function SI(s) {
    return s.getDefinition("$text").allowAttributes.filter(t => t.startsWith("link"))
}

class PI extends I {
    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.set({href: void 0, withText: !0}), this.extendTemplate({
            attributes: {
                class: ["ck-link-toolbar__preview"],
                href: t.to("href"),
                target: "_blank",
                rel: "noopener noreferrer"
            }, on: {
                click: t.to(i => {
                    if (this.href) {
                        const n = () => i.preventDefault();
                        this.fire("navigate", this.href, n)
                    }
                })
            }
        }), this.template.tag = "a"
    }
}

class RI extends T {
    focusTracker = new se;
    keystrokes = new ue;
    backButtonView;
    saveButtonView;
    displayedTextInputView;
    urlInputView;
    children;
    providersListChildren;
    _validators;
    _focusables = new Ie;
    _focusCycler;

    constructor(e, t) {
        super(e), this._validators = t, this.backButtonView = this._createBackButton(), this.saveButtonView = this._createSaveButton(), this.displayedTextInputView = this._createDisplayedTextInput(), this.urlInputView = this._createUrlInput(), this.providersListChildren = this.createCollection(), this.children = this.createCollection([this._createHeaderView()]), this._createFormChildren(), this.listenTo(this.providersListChildren, "add", () => {
            this.stopListening(this.providersListChildren, "add"), this.children.add(this._createProvidersListView())
        }), this._focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"}
        }), this.setTemplate({
            tag: "form",
            attributes: {class: ["ck", "ck-form", "ck-link-form", "ck-responsive-form"], tabindex: "-1"},
            children: this.children
        })
    }

    render() {
        super.render(), li({view: this}), [this.urlInputView, this.saveButtonView, ...this.providersListChildren, this.backButtonView, this.displayedTextInputView].forEach(t => {
            this._focusables.add(t), this.focusTracker.add(t.element)
        }), this.keystrokes.listenTo(this.element)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    focus() {
        this._focusCycler.focusFirst()
    }

    isValid() {
        this.resetFormStatus();
        for (const e of this._validators) {
            const t = e(this);
            if (t) return this.urlInputView.errorText = t, !1
        }
        return !0
    }

    resetFormStatus() {
        this.urlInputView.errorText = null
    }

    _createBackButton() {
        const e = this.locale.t, t = new I(this.locale);
        return t.set({
            class: "ck-button-back",
            label: e("Back"),
            icon: Ht,
            tooltip: !0
        }), t.delegate("execute").to(this, "cancel"), t
    }

    _createSaveButton() {
        const e = this.locale.t, t = new I(this.locale);
        return t.set({
            label: e("Insert"),
            tooltip: !1,
            withText: !0,
            type: "submit",
            class: "ck-button-action ck-button-bold"
        }), t
    }

    _createHeaderView() {
        const e = this.locale.t, t = new ci(this.locale, {label: e("Link")});
        return t.children.add(this.backButtonView, 0), t
    }

    _createProvidersListView() {
        const e = new ui(this.locale);
        return e.extendTemplate({attributes: {class: ["ck-link-form__providers-list"]}}), e.items.bindTo(this.providersListChildren).using(t => {
            const i = new Ke(this.locale);
            return i.children.add(t), i
        }), e
    }

    _createDisplayedTextInput() {
        const e = this.locale.t, t = new Ut(this.locale, ti);
        return t.label = e("Displayed text"), t.class = "ck-labeled-field-view_full-width", t
    }

    _createUrlInput() {
        const e = this.locale.t, t = new Ut(this.locale, ti);
        return t.fieldView.inputMode = "url", t.label = e("Link URL"), t.class = "ck-labeled-field-view_full-width", t
    }

    _createFormChildren() {
        this.children.add(new Hs(this.locale, {
            children: [this.displayedTextInputView],
            class: ["ck-form__row_large-top-padding"]
        })), this.children.add(new Hs(this.locale, {
            children: [this.urlInputView, this.saveButtonView],
            class: ["ck-form__row_with-submit", "ck-form__row_large-top-padding", "ck-form__row_large-bottom-padding"]
        }))
    }

    get url() {
        const {element: e} = this.urlInputView.fieldView;
        return e ? e.value.trim() : null
    }
}

class VI extends T {
    focusTracker = new se;
    keystrokes = new ue;
    backButtonView;
    listView;
    listChildren;
    emptyListInformation;
    children;
    _focusables = new Ie;
    _focusCycler;

    constructor(e) {
        super(e), this.listChildren = this.createCollection(), this.backButtonView = this._createBackButton(), this.listView = this._createListView(), this.emptyListInformation = this._createEmptyLinksListItemView(), this.children = this.createCollection([this._createHeaderView(), this.emptyListInformation]), this.set("title", ""), this.set("emptyListPlaceholder", ""), this.set("hasItems", !1), this.listenTo(this.listChildren, "change", () => {
            this.hasItems = this.listChildren.length > 0
        }), this.on("change:hasItems", (t, i, n) => {
            n ? (this.children.remove(this.emptyListInformation), this.children.add(this.listView)) : (this.children.remove(this.listView), this.children.add(this.emptyListInformation))
        }), this.keystrokes.set("Esc", (t, i) => {
            this.fire("cancel"), i()
        }), this._focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"}
        }), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-link-providers"], tabindex: "-1"},
            children: this.children
        })
    }

    render() {
        super.render(), [this.listView, this.backButtonView].forEach(t => {
            this._focusables.add(t), this.focusTracker.add(t.element)
        }), this.keystrokes.listenTo(this.element)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    focus() {
        this._focusCycler.focusFirst()
    }

    _createListView() {
        const e = new ui(this.locale);
        return e.extendTemplate({attributes: {class: ["ck-link-providers__list"]}}), e.items.bindTo(this.listChildren).using(t => {
            const i = new Ke(this.locale);
            return i.children.add(t), i
        }), e
    }

    _createBackButton() {
        const e = this.locale.t, t = new I(this.locale);
        return t.set({
            class: "ck-button-back",
            label: e("Back"),
            icon: Ht,
            tooltip: !0
        }), t.delegate("execute").to(this, "cancel"), t
    }

    _createHeaderView() {
        const e = new ci(this.locale);
        return e.bind("label").to(this, "title"), e.children.add(this.backButtonView, 0), e
    }

    _createEmptyLinksListItemView() {
        const e = new T(this.locale);
        return e.setTemplate({
            tag: "p",
            attributes: {class: ["ck", "ck-link__empty-list-info"]},
            children: [{text: this.bindTemplate.to("emptyListPlaceholder")}]
        }), e
    }
}

class OI extends T {
    focusTracker = new se;
    keystrokes = new ue;
    backButtonView;
    children;
    listChildren;
    _focusables = new Ie;
    _focusCycler;

    constructor(e) {
        super(e), this.backButtonView = this._createBackButton(), this.listChildren = this.createCollection(), this.children = this.createCollection([this._createHeaderView(), this._createListView()]), this._focusCycler = new We({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {focusPrevious: "shift + tab", focusNext: "tab"}
        }), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-link-properties"], tabindex: "-1"},
            children: this.children
        }), this.keystrokes.set("Esc", (t, i) => {
            this.fire("back"), i()
        })
    }

    render() {
        super.render(), [...this.listChildren, this.backButtonView].forEach(t => {
            this._focusables.add(t), this.focusTracker.add(t.element)
        }), this.keystrokes.listenTo(this.element)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    focus() {
        this._focusCycler.focusFirst()
    }

    _createBackButton() {
        const e = this.locale.t, t = new I(this.locale);
        return t.set({
            class: "ck-button-back",
            label: e("Back"),
            icon: Ht,
            tooltip: !0
        }), t.delegate("execute").to(this, "back"), t
    }

    _createHeaderView() {
        const e = this.locale.t, t = new ci(this.locale, {label: e("Link properties")});
        return t.children.add(this.backButtonView, 0), t
    }

    _createListView() {
        const e = new ui(this.locale);
        return e.extendTemplate({attributes: {class: ["ck-link__list"]}}), e.items.bindTo(this.listChildren).using(t => {
            const i = new Ke(this.locale);
            return i.children.add(t), i
        }), e
    }
}

class MI extends I {
    arrowView;

    constructor(e) {
        super(e), this.set({withText: !0}), this.arrowView = this._createArrowView(), this.extendTemplate({attributes: {class: ["ck-link__button"]}})
    }

    render() {
        super.render(), this.children.add(this.arrowView)
    }

    _createArrowView() {
        const e = new ot;
        return e.content = gf, e
    }
}

const at = "link-ui";

class Qm extends w {
    toolbarView = null;
    formView = null;
    linkProviderItemsView = null;
    propertiesView = null;
    _balloon;
    _linksProviders = new ce;

    static get requires() {
        return [ii, Ki]
    }

    static get pluginName() {
        return "LinkUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = this.editor.t;
        this.set("selectedLinkableText", void 0), e.editing.view.addObserver(Z0), this._balloon = e.plugins.get(ii), this._registerComponents(), this._registerEditingOpeners(), this._enableBalloonActivators(), e.conversion.for("editingDowncast").markerToHighlight({
            model: at,
            view: {classes: ["ck-fake-link-selection"]}
        }), e.conversion.for("editingDowncast").markerToElement({
            model: at, view: (i, {writer: n}) => {
                if (!i.markerRange.isCollapsed) return null;
                const o = n.createUIElement("span");
                return n.addClass(["ck-fake-link-selection", "ck-fake-link-selection_collapsed"], o), o
            }
        }), e.accessibility.addKeystrokeInfos({
            keystrokes: [{
                label: t("Create link"),
                keystroke: pn
            }, {label: t("Move out of a link"), keystroke: [["arrowleft", "arrowleft"], ["arrowright", "arrowright"]]}]
        })
    }

    destroy() {
        super.destroy(), this.propertiesView && this.propertiesView.destroy(), this.formView && this.formView.destroy(), this.toolbarView && this.toolbarView.destroy(), this.linkProviderItemsView && this.linkProviderItemsView.destroy()
    }

    registerLinksListProvider(e) {
        const t = this._linksProviders.filter(i => (i.order || 0) <= (e.order || 0)).length;
        this._linksProviders.add(e, t)
    }

    _createViews() {
        const e = this.editor.commands.get("link");
        this.toolbarView = this._createToolbarView(), this.formView = this._createFormView(), e.manualDecorators.length && (this.propertiesView = this._createPropertiesView()), this._enableUserBalloonInteractions()
    }

    _createToolbarView() {
        const e = this.editor, t = new oo(e.locale), i = e.commands.get("link");
        t.class = "ck-link-toolbar";
        let n = e.config.get("link.toolbar");
        return i.manualDecorators.length || (n = n.filter(o => o !== "linkProperties")), t.fillFromConfig(n, e.ui.componentFactory), t.keystrokes.set("Esc", (o, r) => {
            this._hideUI(), r()
        }), t.keystrokes.set(pn, (o, r) => {
            this._addFormView(), r()
        }), e.ui.addToolbar(t, {
            isContextual: !0, beforeFocus: () => {
                this._getSelectedLinkElement() && !this._isToolbarVisible && this._showUI(!0)
            }, afterBlur: () => {
                this._hideUI(!1)
            }
        }), t
    }

    _createFormView() {
        const e = this.editor, t = e.locale.t, i = e.commands.get("link"), n = e.config.get("link.defaultProtocol"),
            o = new ($i(RI))(e.locale, BI(e));
        return o.displayedTextInputView.bind("isEnabled").to(this, "selectedLinkableText", r => r !== void 0), o.urlInputView.bind("isEnabled").to(i, "isEnabled"), o.saveButtonView.bind("isEnabled").to(i, "isEnabled"), o.saveButtonView.bind("label").to(i, "value", r => t(r ? "Update" : "Insert")), this.listenTo(o, "submit", () => {
            if (o.isValid()) {
                const r = o.urlInputView.fieldView.element.value, a = Va(r, n),
                    l = o.displayedTextInputView.fieldView.element.value;
                e.execute("link", a, this._getDecoratorSwitchesState(), l !== this.selectedLinkableText ? l : void 0), this._closeFormView()
            }
        }), this.listenTo(o.urlInputView, "change:errorText", () => {
            e.ui.update()
        }), this.listenTo(o, "cancel", () => {
            this._closeFormView()
        }), o.keystrokes.set("Esc", (r, a) => {
            this._closeFormView(), a()
        }), o.providersListChildren.bindTo(this._linksProviders).using(r => this._createLinksListProviderButton(r)), o
    }

    _createLinkProviderListView(e) {
        return e.getListItems().map(({href: t, label: i, icon: n}) => {
            const o = new I;
            return o.set({label: i, icon: n, tooltip: !1, withText: !0}), o.on("execute", () => {
                this.formView.resetFormStatus(), this.formView.urlInputView.fieldView.value = t, this.editor.editing.view.focus(), this._removeLinksProviderView(), this.formView.focus()
            }), o
        })
    }

    _createLinkProviderItemsView(e) {
        const t = this.editor, i = t.locale.t, n = new VI(t.locale), {emptyListPlaceholder: o, label: r} = e;
        return n.emptyListPlaceholder = o || i("No links available"), n.title = r, this.listenTo(n, "cancel", () => {
            t.editing.view.focus(), this._removeLinksProviderView(), this.formView.focus()
        }), n
    }

    _createPropertiesView() {
        const e = this.editor, t = this.editor.commands.get("link"), i = new ($i(OI))(e.locale);
        return this.listenTo(i, "back", () => {
            e.editing.view.focus(), this._removePropertiesView()
        }), i.listChildren.bindTo(t.manualDecorators).using(n => {
            const o = new Wi(e.locale);
            return o.set({
                label: n.label,
                withText: !0
            }), o.bind("isOn").toMany([n, t], "value", (r, a) => a === void 0 && r === void 0 ? !!n.defaultValue : !!r), o.on("execute", () => {
                n.set("value", !o.isOn), e.execute("link", t.value, this._getDecoratorSwitchesState())
            }), o
        }), i
    }

    _getDecoratorSwitchesState() {
        const e = this.editor.commands.get("link");
        return Array.from(e.manualDecorators).reduce((t, i) => {
            const n = e.value === void 0 && i.value === void 0 ? i.defaultValue : i.value;
            return {...t, [i.id]: !!n}
        }, {})
    }

    _registerEditingOpeners() {
        this.editor.plugins.get(Ki)._registerLinkOpener(t => {
            const i = this._getLinkProviderLinkByHref(t);
            if (!i) return !1;
            const {item: n, provider: o} = i;
            return o.navigate ? o.navigate(n) : !1
        })
    }

    _registerComponents() {
        const e = this.editor;
        e.ui.componentFactory.add("link", () => {
            const t = this._createButton(I);
            return t.set({tooltip: !0}), t
        }), e.ui.componentFactory.add("menuBar:link", () => {
            const t = this._createButton(K);
            return t.set({role: "menuitemcheckbox"}), t
        }), e.ui.componentFactory.add("linkPreview", t => {
            const i = new PI(t), n = e.config.get("link.allowedProtocols"), o = e.commands.get("link"), r = t.t;
            i.bind("isEnabled").to(o, "value", l => !!l), i.bind("href").to(o, "value", l => l && Zm(l, n));
            const a = l => {
                if (!l) {
                    i.label = void 0, i.icon = void 0, i.tooltip = r("Open link in new tab");
                    return
                }
                const c = this._getLinkProviderLinkByHref(l);
                if (c) {
                    const {label: u, tooltip: d, icon: h} = c.item;
                    i.label = u, i.tooltip = d || !1, i.icon = h
                } else i.label = l, i.icon = void 0, i.tooltip = r("Open link in new tab")
            };
            return a(o.value), this.listenTo(o, "change:value", (l, c, u) => {
                a(u)
            }), this.listenTo(i, "navigate", (l, c, u) => {
                const d = this._getLinkProviderLinkByHref(c);
                if (!d) return;
                const {provider: h, item: f} = d, {navigate: m} = h;
                m && m(f) && (l.stop(), u())
            }), i
        }), e.ui.componentFactory.add("unlink", t => {
            const i = e.commands.get("unlink"), n = new I(t), o = t.t;
            return n.set({
                label: o("Unlink"),
                icon: F1,
                tooltip: !0
            }), n.bind("isEnabled").to(i), this.listenTo(n, "execute", () => {
                e.execute("unlink"), this._hideUI()
            }), n
        }), e.ui.componentFactory.add("editLink", t => {
            const i = e.commands.get("link"), n = new I(t), o = t.t;
            return n.set({
                label: o("Edit link"),
                icon: b1,
                tooltip: !0
            }), n.bind("isEnabled").to(i), this.listenTo(n, "execute", () => {
                this._addFormView()
            }), n
        }), e.ui.componentFactory.add("linkProperties", t => {
            const i = e.commands.get("link"), n = new I(t), o = t.t;
            return n.set({
                label: o("Link properties"),
                icon: x1,
                tooltip: !0
            }), n.bind("isEnabled").to(i, "isEnabled", i, "value", i, "manualDecorators", (r, a, l) => r && !!a && l.length > 0), this.listenTo(n, "execute", () => {
                this._addPropertiesView()
            }), n
        })
    }

    _createLinksListProviderButton(e) {
        const t = this.editor.locale, i = new MI(t);
        return i.set({label: e.label}), this.listenTo(i, "execute", () => {
            this._showLinksProviderView(e)
        }), i
    }

    _createButton(e) {
        const t = this.editor, i = t.locale, n = t.commands.get("link"), o = new e(t.locale), r = i.t;
        return o.set({
            label: r("Link"),
            icon: mf,
            keystroke: pn,
            isToggleable: !0
        }), o.bind("isEnabled").to(n, "isEnabled"), o.bind("isOn").to(n, "value", a => !!a), this.listenTo(o, "execute", () => {
            t.editing.view.scrollToTheSelection(), this._showUI(!0), this._getSelectedLinkElement() && this._addFormView()
        }), o
    }

    _enableBalloonActivators() {
        const e = this.editor, t = e.editing.view.document;
        this.listenTo(t, "click", () => {
            this._getSelectedLinkElement() && this._showUI()
        }), e.keystrokes.set(pn, (i, n) => {
            n(), e.commands.get("link").isEnabled && (e.editing.view.scrollToTheSelection(), this._showUI(!0))
        })
    }

    _enableUserBalloonInteractions() {
        this.editor.keystrokes.set("Tab", (e, t) => {
            this._isToolbarVisible && !this.toolbarView.focusTracker.isFocused && (this.toolbarView.focus(), t())
        }, {priority: "high"}), this.editor.keystrokes.set("Esc", (e, t) => {
            this._isUIVisible && (this._hideUI(), t())
        }), Ji({
            emitter: this.formView,
            activator: () => this._isUIInPanel,
            contextElements: () => [this._balloon.view.element],
            callback: () => {
                this._hideUI(!1)
            }
        })
    }

    _addToolbarView() {
        this.toolbarView || this._createViews(), !this._isToolbarInPanel && this._balloon.add({
            view: this.toolbarView,
            position: this._getBalloonPositionData(),
            balloonClassName: "ck-toolbar-container"
        })
    }

    _addFormView() {
        if (this.formView || this._createViews(), this._isFormInPanel) return;
        const e = this.editor.commands.get("link");
        this.formView.disableCssTransitions(), this.formView.resetFormStatus(), this.formView.backButtonView.isVisible = e.isEnabled && !!e.value, this._balloon.add({
            view: this.formView,
            position: this._getBalloonPositionData()
        }), this.selectedLinkableText = this._getSelectedLinkableText(), this.formView.displayedTextInputView.fieldView.value = this.selectedLinkableText || "", this.formView.urlInputView.fieldView.value = e.value || "", this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions()
    }

    _addPropertiesView() {
        this.propertiesView || this._createViews(), !this._arePropertiesInPanel && (this.propertiesView.disableCssTransitions(), this._balloon.add({
            view: this.propertiesView,
            position: this._getBalloonPositionData()
        }), this.propertiesView.enableCssTransitions(), this.propertiesView.focus())
    }

    _showLinksProviderView(e) {
        this.linkProviderItemsView && this._removeLinksProviderView(), this.linkProviderItemsView = this._createLinkProviderItemsView(e), this._addLinkProviderItemsView(e)
    }

    _addLinkProviderItemsView(e) {
        this.linkProviderItemsView.listChildren.clear(), this.linkProviderItemsView.listChildren.addMany(this._createLinkProviderListView(e)), this._balloon.add({
            view: this.linkProviderItemsView,
            position: this._getBalloonPositionData()
        }), this.linkProviderItemsView.focus()
    }

    _closeFormView() {
        const e = this.editor.commands.get("link");
        this.selectedLinkableText = void 0, e.value !== void 0 ? this._removeFormView() : this._hideUI()
    }

    _removePropertiesView() {
        this._arePropertiesInPanel && this._balloon.remove(this.propertiesView)
    }

    _removeLinksProviderView() {
        this._isLinksListInPanel && this._balloon.remove(this.linkProviderItemsView)
    }

    _removeFormView(e = !0) {
        this._isFormInPanel && (this.formView.saveButtonView.focus(), this.formView.displayedTextInputView.fieldView.reset(), this.formView.urlInputView.fieldView.reset(), this._balloon.remove(this.formView), e && this.editor.editing.view.focus(), this._hideFakeVisualSelection())
    }

    _showUI(e = !1) {
        this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._isToolbarVisible ? this._addFormView() : this._addToolbarView(), e && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addToolbarView(), e && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI()
    }

    _hideUI(e = !0) {
        const t = this.editor;
        this._isUIInPanel && (this.stopListening(t.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), e && t.editing.view.focus(), this._removeLinksProviderView(), this._removePropertiesView(), this._removeFormView(e), this._isToolbarInPanel && this._balloon.remove(this.toolbarView), this._hideFakeVisualSelection())
    }

    _startUpdatingUI() {
        const e = this.editor, t = e.editing.view.document;
        let i = this._getSelectedLinkElement(), n = r();
        const o = () => {
            const a = this._getSelectedLinkElement(), l = r();
            i && !a || !i && l !== n ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), i = a, n = l
        };

        function r() {
            return t.selection.focus.getAncestors().reverse().find(a => a.is("element"))
        }

        this.listenTo(e.ui, "update", o), this.listenTo(this._balloon, "change:visibleView", o)
    }

    get _arePropertiesInPanel() {
        return !!this.propertiesView && this._balloon.hasView(this.propertiesView)
    }

    get _isLinksListInPanel() {
        return !!this.linkProviderItemsView && this._balloon.hasView(this.linkProviderItemsView)
    }

    get _isFormInPanel() {
        return !!this.formView && this._balloon.hasView(this.formView)
    }

    get _isToolbarInPanel() {
        return !!this.toolbarView && this._balloon.hasView(this.toolbarView)
    }

    get _isPropertiesVisible() {
        return !!this.propertiesView && this._balloon.visibleView === this.propertiesView
    }

    get _isFormVisible() {
        return !!this.formView && this._balloon.visibleView == this.formView
    }

    get _isToolbarVisible() {
        return !!this.toolbarView && this._balloon.visibleView === this.toolbarView
    }

    get _isUIInPanel() {
        return this._arePropertiesInPanel || this._isLinksListInPanel || this._isFormInPanel || this._isToolbarInPanel
    }

    get _isUIVisible() {
        return this._isPropertiesVisible || this._isLinksListInPanel || this._isFormVisible || this._isToolbarVisible
    }

    _getBalloonPositionData() {
        const e = this.editor.editing.view, t = e.document;
        if (this.editor.model.markers.has(at)) {
            const n = this.editor.editing.mapper.markerNameToElements(at);
            if (n) {
                const o = Array.from(n),
                    r = e.createRange(e.createPositionBefore(o[0]), e.createPositionAfter(o[o.length - 1]));
                return {target: e.domConverter.viewRangeToDom(r)}
            }
        }
        return {
            target: () => {
                const n = this._getSelectedLinkElement();
                return n ? e.domConverter.mapViewToDom(n) : e.domConverter.viewRangeToDom(t.selection.getFirstRange())
            }
        }
    }

    _getSelectedLinkElement() {
        const e = this.editor.editing.view, t = e.document.selection, i = t.getSelectedElement();
        if (t.isCollapsed || i && ie(i)) return Xo(t.getFirstPosition());
        {
            const n = t.getFirstRange().getTrimmed(), o = Xo(n.start), r = Xo(n.end);
            return !o || o != r ? null : e.createRangeIn(o).getTrimmed().isEqual(n) ? o : null
        }
    }

    _getSelectedLinkableText() {
        const e = this.editor.model, t = this.editor.editing, i = this._getSelectedLinkElement();
        if (!i) return Rr(e.document.selection.getFirstRange());
        const n = t.view.createRangeOn(i), o = t.mapper.toModelRange(n);
        return Rr(o)
    }

    _getLinkProviderLinkByHref(e) {
        if (!e) return null;
        for (const t of this._linksProviders) {
            const i = t.getItem ? t.getItem(e) : t.getListItems().find(n => n.href === e);
            if (i) return {provider: t, item: i}
        }
        return null
    }

    _showFakeVisualSelection() {
        const e = this.editor.model;
        e.change(t => {
            const i = e.document.selection.getFirstRange();
            if (e.markers.has(at)) t.updateMarker(at, {range: i}); else if (i.start.isAtEnd) {
                const n = i.start.getLastMatchingPosition(({item: o}) => !e.schema.isContent(o), {boundaries: i});
                t.addMarker(at, {usingOperation: !1, affectsData: !1, range: t.createRange(n, i.end)})
            } else t.addMarker(at, {usingOperation: !1, affectsData: !1, range: i})
        })
    }

    _hideFakeVisualSelection() {
        const e = this.editor.model;
        e.markers.has(at) && e.change(t => {
            t.removeMarker(at)
        })
    }
}

function Xo(s) {
    return s.getAncestors().find(e => mI(e)) || null
}

function BI(s) {
    const e = s.t, t = s.config.get("link.allowCreatingEmptyLinks");
    return [i => {
        if (!t && !i.url.length) return e("Link URL must not be empty.")
    }]
}

const FI = 4,
    Ym = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63}))|localhost)(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i"),
    LI = 2;

class Xm extends w {
    static get requires() {
        return [mt, Ki]
    }

    static get pluginName() {
        return "AutoLink"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const t = this.editor.model.document.selection;
        t.on("change:range", () => {
            this.isEnabled = !t.anchor.parent.is("element", "codeBlock")
        }), this._enableTypingHandling()
    }

    afterInit() {
        this._enableEnterHandling(), this._enableShiftEnterHandling(), this._enablePasteLinking()
    }

    _expandLinkRange(e, t) {
        return t.textNode && t.textNode.hasAttribute("linkHref") ? ro(t, "linkHref", t.textNode.getAttribute("linkHref"), e) : null
    }

    _selectEntireLinks(e, t) {
        const n = this.editor.model, o = n.document.selection, r = o.getFirstPosition(), a = o.getLastPosition();
        let l = t.getJoined(this._expandLinkRange(n, r) || t);
        l && (l = l.getJoined(this._expandLinkRange(n, a) || t)), l && (l.start.isBefore(r) || l.end.isAfter(a)) && e.setSelection(l)
    }

    _enablePasteLinking() {
        const e = this.editor, t = e.model, i = t.document.selection, n = e.plugins.get("ClipboardPipeline"),
            o = e.commands.get("link");
        n.on("inputTransformation", (r, a) => {
            if (!this.isEnabled || !o.isEnabled || i.isCollapsed || a.method !== "paste" || i.rangeCount > 1) return;
            const l = i.getFirstRange(), c = a.dataTransfer.getData("text/plain");
            if (!c) return;
            const u = c.match(Ym);
            u && u[2] === c && (t.change(d => {
                this._selectEntireLinks(d, l), o.execute(c)
            }), r.stop())
        }, {priority: "high"})
    }

    _enableTypingHandling() {
        const e = this.editor, t = new ya(e.model, i => {
            let n = i;
            if (!DI(n)) return;
            n = n.slice(0, -1), "!.:,;?".includes(n[n.length - 1]) && (n = n.slice(0, -1));
            const o = Lu(n);
            if (o) return {url: o, removedTrailingCharacters: i.length - n.length}
        });
        t.on("matched:data", (i, n) => {
            const {batch: o, range: r, url: a, removedTrailingCharacters: l} = n;
            if (!o.isTyping) return;
            const c = r.end.getShiftedBy(-l), u = c.getShiftedBy(-a.length), d = e.model.createRange(u, c);
            this._applyAutoLink(a, d)
        }), t.bind("isEnabled").to(this)
    }

    _enableEnterHandling() {
        const e = this.editor, t = e.model, i = e.commands.get("enter");
        i && i.on("execute", () => {
            const n = t.document.selection.getFirstPosition();
            let o;
            n.parent.previousSibling?.is("element") ? o = t.createRangeIn(n.parent.previousSibling) : o = t.createRange(t.createPositionAt(n.parent, 0), n), this._checkAndApplyAutoLinkOnRange(o)
        })
    }

    _enableShiftEnterHandling() {
        const e = this.editor, t = e.model, i = e.commands.get("shiftEnter");
        i && i.on("execute", () => {
            const n = t.document.selection.getFirstPosition(),
                o = t.createRange(t.createPositionAt(n.parent, 0), n.getShiftedBy(-1));
            this._checkAndApplyAutoLinkOnRange(o)
        })
    }

    _checkAndApplyAutoLinkOnRange(e) {
        const t = this.editor.model, {text: i, range: n} = rm(e, t), o = Lu(i);
        if (o) {
            const r = t.createRange(n.end.getShiftedBy(-o.length), n.end);
            this._applyAutoLink(o, r)
        }
    }

    _applyAutoLink(e, t) {
        const i = this.editor.model, n = this.editor.config.get("link.defaultProtocol"), o = Va(e, n);
        !this.isEnabled || !NI(t, i) || !Jm(o) || zI(t) || this._persistAutoLink(o, t)
    }

    _persistAutoLink(e, t) {
        const i = this.editor.model, n = this.editor.plugins.get("Delete");
        i.enqueueChange(o => {
            o.setAttribute("linkHref", e, t), i.enqueueChange(() => {
                n.requestUndoOnBackspace()
            })
        })
    }
}

function DI(s) {
    return s.length > FI && s[s.length - 1] === " " && s[s.length - 2] !== " "
}

function Lu(s) {
    const e = Ym.exec(s);
    return e ? e[LI] : null
}

function NI(s, e) {
    return e.schema.checkAttributeInSelection(e.createSelection(s), "linkHref")
}

function zI(s) {
    const e = s.start.nodeAfter;
    return !!e && e.hasAttribute("linkHref")
}

class HI extends w {
    static get requires() {
        return [Ki, Qm, Xm]
    }

    static get pluginName() {
        return "Link"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

class UI extends w {
    static get requires() {
        return ["ImageEditing", "ImageUtils", Ki]
    }

    static get pluginName() {
        return "LinkImageEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    afterInit() {
        const e = this.editor, t = e.model.schema;
        e.plugins.has("ImageBlockEditing") && t.extend("imageBlock", {allowAttributes: ["linkHref"]}), e.conversion.for("upcast").add($I(e)), e.conversion.for("downcast").add(WI(e)), this._enableAutomaticDecorators(), this._enableManualDecorators()
    }

    _enableAutomaticDecorators() {
        const e = this.editor, i = e.commands.get("link").automaticDecorators;
        i.length && e.conversion.for("downcast").add(i.getDispatcherForLinkedImage())
    }

    _enableManualDecorators() {
        const e = this.editor, t = e.commands.get("link");
        for (const i of t.manualDecorators) e.plugins.has("ImageBlockEditing") && e.model.schema.extend("imageBlock", {allowAttributes: i.id}), e.plugins.has("ImageInlineEditing") && e.model.schema.extend("imageInline", {allowAttributes: i.id}), e.conversion.for("downcast").add(qI(i)), e.conversion.for("upcast").add(jI(e, i))
    }
}

function $I(s) {
    const e = s.plugins.has("ImageInlineEditing"), t = s.plugins.get("ImageUtils");
    return i => {
        i.on("element:a", (n, o, r) => {
            const a = o.viewItem, l = t.findViewImgElement(a);
            if (!l) return;
            const c = l.findAncestor(f => t.isBlockImageView(f));
            if (e && !c) return;
            const u = {attributes: ["href"]};
            if (!r.consumable.consume(a, u)) return;
            const d = a.getAttribute("href");
            if (!d) return;
            let h = o.modelCursor.parent;
            if (!h.is("element", "imageBlock")) {
                const f = r.convertItem(l, o.modelCursor);
                o.modelRange = f.modelRange, o.modelCursor = f.modelCursor, h = o.modelCursor.nodeBefore
            }
            h && h.is("element", "imageBlock") && r.writer.setAttribute("linkHref", d, h)
        }, {priority: "high"})
    }
}

function WI(s) {
    const e = s.plugins.get("ImageUtils");
    return t => {
        t.on("attribute:linkHref:imageBlock", (i, n, o) => {
            if (!o.consumable.consume(n.item, i.name)) return;
            const r = o.mapper.toViewElement(n.item), a = o.writer,
                l = Array.from(r.getChildren()).find(d => d.is("element", "a")), c = e.findViewImgElement(r),
                u = c.parent.is("element", "picture") ? c.parent : c;
            if (l) n.attributeNewValue ? a.setAttribute("href", n.attributeNewValue, l) : (a.move(a.createRangeOn(u), a.createPositionAt(r, 0)), a.remove(l)); else {
                const d = a.createContainerElement("a", {href: n.attributeNewValue});
                a.insert(a.createPositionAt(r, 0), d), a.move(a.createRangeOn(u), a.createPositionAt(d, 0))
            }
        }, {priority: "high"})
    }
}

function qI(s) {
    return e => {
        e.on(`attribute:${s.id}:imageBlock`, (t, i, n) => {
            const o = n.mapper.toViewElement(i.item), r = Array.from(o.getChildren()).find(a => a.is("element", "a"));
            if (r) {
                if (s.value === void 0) {
                    for (const a in s.attributes) n.writer.removeAttribute(a, r);
                    s.classes && n.writer.removeClass(s.classes, r);
                    for (const a in s.styles) n.writer.removeStyle(a, r);
                    return
                }
                for (const [a, l] of nt(s.attributes)) n.writer.setAttribute(a, l, r);
                s.classes && n.writer.addClass(s.classes, r);
                for (const a in s.styles) n.writer.setStyle(a, s.styles[a], r)
            }
        })
    }
}

function jI(s, e) {
    const t = s.plugins.has("ImageInlineEditing"), i = s.plugins.get("ImageUtils");
    return n => {
        n.on("element:a", (o, r, a) => {
            const l = r.viewItem, c = i.findViewImgElement(l);
            if (!c) return;
            const u = c.findAncestor(m => i.isBlockImageView(m));
            if (t && !u) return;
            const h = new He(e._createPattern()).match(l);
            if (!h || !a.consumable.consume(l, h.match)) return;
            const f = r.modelCursor.nodeBefore || r.modelCursor.parent;
            a.writer.setAttribute(e.id, !0, f)
        }, {priority: "high"})
    }
}

class GI extends w {
    static get requires() {
        return [Ki, Qm, "ImageBlockEditing"]
    }

    static get pluginName() {
        return "LinkImageUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.editing.view.document;
        this.listenTo(t, "click", (i, n) => {
            this._isSelectedLinkedImage(e.model.document.selection) && (n.preventDefault(), i.stop())
        }, {priority: "high"}), this._createToolbarLinkImageButton()
    }

    _createToolbarLinkImageButton() {
        const e = this.editor, t = e.t;
        e.ui.componentFactory.add("linkImage", i => {
            const n = new I(i), o = e.plugins.get("LinkUI"), r = e.commands.get("link");
            return n.set({
                isEnabled: !0,
                label: t("Link image"),
                icon: mf,
                keystroke: pn,
                tooltip: !0,
                isToggleable: !0
            }), n.bind("isEnabled").to(r, "isEnabled"), n.bind("isOn").to(r, "value", a => !!a), this.listenTo(n, "execute", () => {
                this._isSelectedLinkedImage(e.model.document.selection) ? o._addToolbarView() : o._showUI(!0)
            }), n
        })
    }

    _isSelectedLinkedImage(e) {
        const t = e.getSelectedElement();
        return this.editor.plugins.get("ImageUtils").isImage(t) && t.hasAttribute("linkHref")
    }
}

class KI extends w {
    static get requires() {
        return [UI, GI]
    }

    static get pluginName() {
        return "LinkImage"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class Ze {
    _startElement;
    _referenceIndent;
    _isForward;
    _includeSelf;
    _sameAttributes;
    _sameIndent;
    _lowerIndent;
    _higherIndent;

    constructor(e, t) {
        this._startElement = e, this._referenceIndent = e.getAttribute("listIndent"), this._isForward = t.direction == "forward", this._includeSelf = !!t.includeSelf, this._sameAttributes = U(t.sameAttributes || []), this._sameIndent = !!t.sameIndent, this._lowerIndent = !!t.lowerIndent, this._higherIndent = !!t.higherIndent
    }

    static first(e, t) {
        const n = new this(e, t)[Symbol.iterator]();
        return re(n)
    }

    * [Symbol.iterator]() {
        const e = [];
        for (const {node: t} of new Zn(this._getStartNode(), this._isForward ? "forward" : "backward")) {
            const i = t.getAttribute("listIndent");
            if (i < this._referenceIndent) {
                if (!this._lowerIndent) break;
                this._referenceIndent = i
            } else if (i > this._referenceIndent) {
                if (!this._higherIndent) continue;
                if (!this._isForward) {
                    e.push(t);
                    continue
                }
            } else {
                if (!this._sameIndent) {
                    if (this._higherIndent) {
                        e.length && (yield* e, e.length = 0);
                        break
                    }
                    continue
                }
                if (this._sameAttributes.some(n => t.getAttribute(n) !== this._startElement.getAttribute(n))) break
            }
            e.length && (yield* e, e.length = 0), yield t
        }
    }

    _getStartNode() {
        return this._includeSelf ? this._startElement : this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling
    }
}

class Zn {
    _node;
    _isForward;
    _previousNodesByIndent = [];
    _previous = null;
    _previousNodeIndent = null;

    constructor(e, t = "forward") {
        this._node = e, this._isForward = t === "forward"
    }

    [Symbol.iterator]() {
        return this
    }

    next() {
        if (!le(this._node)) return {done: !0, value: void 0};
        const e = this._node.getAttribute("listIndent");
        let t = null;
        if (this._previous) {
            const n = this._previousNodeIndent;
            e > n ? this._previousNodesByIndent[n] = this._previous : e < n ? (t = this._previousNodesByIndent[e] || null, this._previousNodesByIndent.length = e) : t = this._previous
        }
        const i = {node: this._node, previous: this._previous, previousNodeInList: t};
        return this._previous = this._node, this._previousNodeIndent = e, this._node = this._isForward ? this._node.nextSibling : this._node.previousSibling, {
            value: i,
            done: !1
        }
    }
}

class ZI {
    _listHead;

    constructor(e) {
        this._listHead = e
    }

    [Symbol.iterator]() {
        return new Zn(this._listHead)
    }
}

class Zi {
    static next() {
        return pe()
    }
}

function le(s) {
    return !!s && s.is("element") && s.hasAttribute("listItemId")
}

function Oa(s, e = {}) {
    return [...Wt(s, {...e, direction: "backward"}), ...Wt(s, {...e, direction: "forward"})]
}

function Wt(s, e = {}) {
    const t = e.direction == "forward",
        i = Array.from(new Ze(s, {...e, includeSelf: t, sameIndent: !0, sameAttributes: "listItemId"}));
    return t ? i : i.reverse()
}

function JI(s) {
    return Array.from(new Ze(s, {direction: "forward", higherIndent: !0}))
}

function eg(s, e) {
    const t = new Ze(s, {sameIndent: !0, sameAttributes: "listType", ...e}),
        i = new Ze(s, {sameIndent: !0, sameAttributes: "listType", includeSelf: !0, direction: "forward", ...e});
    return [...Array.from(t).reverse(), ...i]
}

function ni(s) {
    return !Ze.first(s, {sameIndent: !0, sameAttributes: "listItemId"})
}

function Du(s) {
    return !Ze.first(s, {direction: "forward", sameIndent: !0, sameAttributes: "listItemId"})
}

function Jn(s, e = {}) {
    s = U(s);
    const t = e.withNested !== !1, i = new Set;
    for (const n of s) for (const o of Oa(n, {higherIndent: t})) i.add(o);
    return hi(i)
}

function QI(s) {
    s = U(s);
    const e = new Set;
    for (const t of s) for (const i of eg(t)) e.add(i);
    return hi(e)
}

function Ma(s, e) {
    const t = Wt(s, {direction: "forward"}), i = Zi.next();
    for (const n of t) e.setAttribute("listItemId", i, n);
    return t
}

function Vr(s, e, t) {
    const i = {};
    for (const [o, r] of e.getAttributes()) o.startsWith("list") && (i[o] = r);
    const n = Wt(s, {direction: "forward"});
    for (const o of n) t.setAttributes(i, o);
    return n
}

function Or(s, e, {expand: t, indentBy: i = 1} = {}) {
    s = U(s);
    const n = t ? Jn(s) : s;
    for (const o of n) {
        const r = o.getAttribute("listIndent") + i;
        r < 0 ? fo(o, e) : e.setAttribute("listIndent", r, o)
    }
    return n
}

function YI(s, e) {
    s = U(s);
    const t = Jn(s), i = new Set, n = Math.min(...t.map(r => r.getAttribute("listIndent"))), o = new Map;
    for (const r of t) o.set(r, Ze.first(r, {lowerIndent: !0}));
    for (const r of t) {
        if (i.has(r)) continue;
        i.add(r);
        const a = r.getAttribute("listIndent") - 1;
        if (a < 0) {
            fo(r, e);
            continue
        }
        if (r.getAttribute("listIndent") == n) {
            const l = tS(r, o.get(r), e);
            for (const c of l) i.add(c);
            if (l.length) continue
        }
        e.setAttribute("listIndent", a, r)
    }
    return hi(i)
}

function fo(s, e) {
    s = U(s);
    for (const t of s) t.is("element", "listItem") && e.rename(t, "paragraph");
    for (const t of s) for (const i of t.getAttributeKeys()) i.startsWith("list") && e.removeAttribute(i, t);
    return s
}

function Nn(s) {
    if (!s.length) return !1;
    const e = s[0].getAttribute("listItemId");
    return e ? !s.some(t => t.getAttribute("listItemId") != e) : !1
}

function XI(s, e) {
    const t = [];
    let i = Number.POSITIVE_INFINITY;
    for (const {node: n} of new Zn(s.nextSibling)) {
        const o = n.getAttribute("listIndent");
        if (o == 0) break;
        o < i && (i = o);
        const r = o - i;
        e.setAttribute("listIndent", r, n), t.push(n)
    }
    return t
}

function hi(s) {
    return Array.from(s).filter(e => e.root.rootName !== "$graveyard").sort((e, t) => e.index - t.index)
}

function zn(s) {
    const e = s.document.selection.getSelectedElement();
    return e && s.schema.isObject(e) && s.schema.isBlock(e) ? e : null
}

function er(s, e) {
    return e.checkChild(s.parent, "listItem") && e.checkChild(s, "$text") && !e.isObject(s)
}

function eS(s) {
    return s == "numbered" || s == "customNumbered"
}

function tS(s, e, t) {
    return Wt(e, {direction: "forward"}).pop().index > s.index ? Vr(s, e, t) : []
}

class Nu extends O {
    _direction;

    constructor(e, t) {
        super(e), this._direction = t
    }

    refresh() {
        this.isEnabled = this._checkEnabled()
    }

    execute() {
        const e = this.editor.model, t = zu(e.document.selection);
        e.change(i => {
            const n = [];
            Nn(t) && !ni(t[0]) ? (this._direction == "forward" && n.push(...Or(t, i)), n.push(...Ma(t[0], i))) : this._direction == "forward" ? n.push(...Or(t, i, {expand: !0})) : n.push(...YI(t, i));
            for (const o of n) {
                if (!o.hasAttribute("listType")) continue;
                const r = Ze.first(o, {sameIndent: !0});
                r && i.setAttribute("listType", r.getAttribute("listType"), o)
            }
            this._fireAfterExecute(n)
        })
    }

    _fireAfterExecute(e) {
        this.fire("afterExecute", hi(new Set(e)))
    }

    _checkEnabled() {
        let e = zu(this.editor.model.document.selection), t = e[0];
        if (!t) return !1;
        if (this._direction == "backward" || Nn(e) && !ni(e[0])) return !0;
        e = Jn(e), t = e[0];
        const i = Ze.first(t, {sameIndent: !0});
        return i ? i.getAttribute("listType") == t.getAttribute("listType") : !1
    }
}

function zu(s) {
    const e = Array.from(s.getSelectedBlocks()), t = e.findIndex(i => !le(i));
    return t != -1 && (e.length = t), e
}

class hs extends O {
    type;
    _listWalkerOptions;

    constructor(e, t, i = {}) {
        super(e), this.type = t, this._listWalkerOptions = i.multiLevel ? {
            higherIndent: !0,
            lowerIndent: !0,
            sameAttributes: []
        } : void 0
    }

    refresh() {
        this.value = this._getValue(), this.isEnabled = this._checkEnabled()
    }

    execute(e = {}) {
        const t = this.editor.model, i = t.document, n = zn(t),
            o = Array.from(i.selection.getSelectedBlocks()).filter(a => t.schema.checkAttribute(a, "listType") || er(a, t.schema)),
            r = e.forceValue !== void 0 ? !e.forceValue : this.value;
        t.change(a => {
            if (r) {
                const l = o[o.length - 1], c = Wt(l, {direction: "forward"}), u = [];
                c.length > 1 && u.push(...Ma(c[1], a)), u.push(...fo(o, a)), u.push(...XI(l, a)), this._fireAfterExecute(u)
            } else if ((n || i.selection.isCollapsed) && le(o[0])) {
                const l = eg(n || o[0], this._listWalkerOptions);
                for (const c of l) a.setAttributes({...e.additionalAttributes, listType: this.type}, c);
                this._fireAfterExecute(l)
            } else {
                const l = [];
                for (const c of o) if (!c.hasAttribute("listType")) !c.is("element", "listItem") && er(c, t.schema) && a.rename(c, "listItem"), a.setAttributes({
                    ...e.additionalAttributes,
                    listIndent: 0,
                    listItemId: Zi.next(),
                    listType: this.type
                }, c), l.push(c); else for (const u of Jn(c, {withNested: !1})) u.getAttribute("listType") != this.type && (a.setAttributes({
                    ...e.additionalAttributes,
                    listType: this.type
                }, u), l.push(u));
                this._fireAfterExecute(l)
            }
        })
    }

    _fireAfterExecute(e) {
        this.fire("afterExecute", hi(new Set(e)))
    }

    _getValue() {
        const e = this.editor.model.document.selection, t = Array.from(e.getSelectedBlocks());
        if (!t.length) return !1;
        for (const i of t) if (i.getAttribute("listType") != this.type) return !1;
        return !0
    }

    _checkEnabled() {
        const e = this.editor.model, t = e.schema, i = e.document.selection, n = Array.from(i.getSelectedBlocks());
        if (!n.length) return !1;
        if (this.value) return !0;
        for (const o of n) if (t.checkAttribute(o, "listType") || er(o, t)) return !0;
        return !1
    }
}

class Hu extends O {
    _direction;

    constructor(e, t) {
        super(e), this._direction = t
    }

    refresh() {
        this.isEnabled = this._checkEnabled()
    }

    execute({shouldMergeOnBlocksContentLevel: e = !1} = {}) {
        const t = this.editor.model, i = t.document.selection, n = [];
        t.change(o => {
            const {firstElement: r, lastElement: a} = this._getMergeSubjectElements(i, e),
                l = r.getAttribute("listIndent") || 0, c = a.getAttribute("listIndent"),
                u = a.getAttribute("listItemId");
            if (l != c) {
                const d = JI(a);
                n.push(...Or([a, ...d], o, {indentBy: l - c, expand: l < c}))
            }
            if (e) {
                let d = i;
                i.isCollapsed && (d = o.createSelection(o.createRange(o.createPositionAt(r, "end"), o.createPositionAt(a, 0)))), t.deleteContent(d, {doNotResetEntireContent: i.isCollapsed});
                const h = d.getLastPosition().parent, f = h.nextSibling;
                n.push(h), f && f !== a && f.getAttribute("listItemId") == u && n.push(...Vr(f, h, o))
            } else n.push(...Vr(a, r, o));
            this._fireAfterExecute(n)
        })
    }

    _fireAfterExecute(e) {
        this.fire("afterExecute", hi(new Set(e)))
    }

    _checkEnabled() {
        const e = this.editor.model, t = e.document.selection, i = zn(e);
        if (t.isCollapsed || i) {
            const n = i || t.getFirstPosition().parent;
            if (!le(n)) return !1;
            const o = this._direction == "backward" ? n.previousSibling : n.nextSibling;
            if (!o || Nn([n, o])) return !1
        } else {
            const n = t.getLastPosition(), o = t.getFirstPosition();
            if (n.parent === o.parent || !le(n.parent)) return !1
        }
        return !0
    }

    _getMergeSubjectElements(e, t) {
        const i = this.editor.model, n = zn(i);
        let o, r;
        if (e.isCollapsed || n) {
            const a = n || e.getFirstPosition().parent, l = ni(a);
            this._direction == "backward" ? (r = a, l && !t ? o = Ze.first(a, {
                sameIndent: !0,
                lowerIndent: !0
            }) : o = a.previousSibling) : (o = a, r = a.nextSibling)
        } else o = e.getFirstPosition().parent, r = e.getLastPosition().parent;
        return {firstElement: o, lastElement: r}
    }
}

class Uu extends O {
    _direction;

    constructor(e, t) {
        super(e), this._direction = t
    }

    refresh() {
        this.isEnabled = this._checkEnabled()
    }

    execute() {
        this.editor.model.change(t => {
            const i = Ma(this._getStartBlock(), t);
            this._fireAfterExecute(i)
        })
    }

    _fireAfterExecute(e) {
        this.fire("afterExecute", hi(new Set(e)))
    }

    _checkEnabled() {
        const e = this.editor.model.document.selection, t = this._getStartBlock();
        return e.isCollapsed && le(t) && !ni(t)
    }

    _getStartBlock() {
        const t = this.editor.model.document.selection.getFirstPosition().parent;
        return this._direction == "before" ? t : t.nextSibling
    }
}

class iS extends w {
    static get pluginName() {
        return "ListUtils"
    }

    static get isOfficialPlugin() {
        return !0
    }

    expandListBlocksToCompleteList(e) {
        return QI(e)
    }

    isFirstBlockOfListItem(e) {
        return ni(e)
    }

    isListItemBlock(e) {
        return le(e)
    }

    expandListBlocksToCompleteItems(e, t = {}) {
        return Jn(e, t)
    }

    isNumberedListType(e) {
        return eS(e)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function nS(s) {
    return s.is("element", "ol") || s.is("element", "ul")
}

function Mr(s) {
    return s.is("element", "li")
}

function sS(s) {
    let e = 0, t = s.parent;
    for (; t;) {
        if (Mr(t)) e++; else {
            const i = t.previousSibling;
            i && Mr(i) && e++
        }
        t = t.parent
    }
    return e
}

function oS(s, e, t, i = ig(t, e)) {
    return s.createAttributeElement(tg(t), null, {priority: 2 * e / 100 - 100, id: i})
}

function rS(s, e, t) {
    return s.createAttributeElement("li", null, {priority: (2 * e + 1) / 100 - 100, id: t})
}

function tg(s) {
    return s == "numbered" || s == "customNumbered" ? "ol" : "ul"
}

function ig(s, e) {
    return `list-${s}-${e}`
}

function Ye(s, e, t) {
    const i = s.nodeBefore;
    if (le(i)) {
        let n = i;
        for (const {node: o} of new Zn(n, "backward")) if (n = o, t.has(n) || (t.add(n), e.has(i))) return;
        e.add(n)
    } else {
        const n = s.nodeAfter;
        le(n) && e.add(n)
    }
}

function aS(s, e) {
    let t = 0, i = -1, n = null, o = !1;
    for (const {node: r} of s) {
        const a = r.getAttribute("listIndent");
        if (a > t) {
            let l;
            n === null ? (n = a - t, l = t) : (n > a && (n = a), l = a - n), l > i + 1 && (l = i + 1), e.setAttribute("listIndent", l, r), o = !0, i = l
        } else n = null, t = a + 1, i = a
    }
    return o
}

function lS(s, e, t) {
    const i = new Set;
    let n = !1;
    for (const {node: o} of s) {
        if (i.has(o)) continue;
        let r = o.getAttribute("listType"), a = o.getAttribute("listItemId");
        if (e.has(a) && (a = Zi.next()), e.add(a), o.is("element", "listItem")) {
            o.getAttribute("listItemId") != a && (t.setAttribute("listItemId", a, o), n = !0);
            continue
        }
        for (const l of Wt(o, {direction: "forward"})) i.add(l), l.getAttribute("listType") != r && (a = Zi.next(), r = l.getAttribute("listType")), l.getAttribute("listItemId") != a && (t.setAttribute("listItemId", a, l), n = !0)
    }
    return n
}

function cS() {
    return (s, e, t) => {
        const {writer: i, schema: n} = t;
        if (!e.modelRange) return;
        const o = Array.from(e.modelRange.getItems({shallow: !0})).filter(d => n.checkAttribute(d, "listItemId"));
        if (!o.length) return;
        const r = Zi.next(), a = sS(e.viewItem);
        let l = e.viewItem.parent && e.viewItem.parent.is("element", "ol") ? "numbered" : "bulleted";
        const c = o[0].getAttribute("listType");
        c && (l = c);
        const u = {listItemId: r, listIndent: a, listType: l};
        for (const d of o) d.hasAttribute("listItemId") || i.setAttributes(u, d);
        o.length > 1 && o[1].getAttribute("listItemId") != u.listItemId && t.keepEmptyElement(o[0])
    }
}

function uS(s, e, t, i) {
    return () => {
        const a = s.document.differ.getChanges(), l = [], c = new Set, u = new Set, d = new Set;
        for (const h of a) if (h.type == "insert" && h.name != "$text") Ye(h.position, c, d), h.attributes.has("listItemId") ? u.add(h.position.nodeAfter) : Ye(h.position.getShiftedBy(h.length), c, d); else if (h.type == "remove" && h.attributes.has("listItemId")) Ye(h.position, c, d); else if (h.type == "attribute") {
            const f = h.range.start.nodeAfter;
            t.includes(h.attributeKey) ? (Ye(h.range.start, c, d), h.attributeNewValue === null ? (Ye(h.range.start.getShiftedBy(1), c, d), o(f) && l.push(f)) : u.add(f)) : le(f) && o(f) && l.push(f)
        }
        for (const h of c.values()) l.push(...n(h, u));
        for (const h of new Set(l)) e.reconvertItem(h)
    };

    function n(a, l) {
        const c = [], u = new Set, d = [];
        for (const {node: h, previous: f} of new Zn(a)) {
            if (u.has(h)) continue;
            const m = h.getAttribute("listIndent");
            f && m < f.getAttribute("listIndent") && (d.length = m + 1), d[m] = Object.fromEntries(Array.from(h.getAttributes()).filter(([_]) => t.includes(_)));
            const g = Wt(h, {direction: "forward"});
            for (const _ of g) u.add(_), (o(_, g) || r(_, d, l)) && c.push(_)
        }
        return c
    }

    function o(a, l) {
        const c = e.mapper.toViewElement(a);
        if (!c) return !1;
        if (i.fire("checkElement", {modelElement: a, viewElement: c})) return !0;
        if (!a.is("element", "paragraph") && !a.is("element", "listItem")) return !1;
        const d = sg(a, t, l);
        return d && c.is("element", "p") ? !0 : !!(!d && c.is("element", "span"))
    }

    function r(a, l, c) {
        if (c.has(a)) return !1;
        const u = e.mapper.toViewElement(a);
        let d = l.length - 1;
        for (let h = u.parent; !h.is("editableElement"); h = h.parent) {
            const f = Mr(h), m = nS(h);
            if (!m && !f) continue;
            const g = `checkAttributes:${f ? "item" : "list"}`;
            if (i.fire(g, {viewElement: h, modelAttributes: l[d]})) break;
            if (m && (d--, d < 0)) return !1
        }
        return !0
    }
}

function $u(s, e, t, {dataPipeline: i} = {}) {
    const n = wS(s);
    return (o, r, a) => {
        const {writer: l, mapper: c, consumable: u} = a, d = r.item;
        if (!s.includes(r.attributeKey) || !n(d, u)) return;
        const h = hS(d, c, t);
        ng(h, l, c), gS(h, l);
        const f = mS(d, h, e, l, {dataPipeline: i});
        pS(d, f, e, l)
    }
}

function dS(s) {
    return (e, t, i) => {
        const {writer: n, mapper: o} = i, r = e.name.split(":")[1];
        if (!s.checkAttribute(r, "listItemId")) return;
        const a = o.toViewPosition(t.position), l = t.position.getShiftedBy(t.length),
            c = o.toViewPosition(l, {isPhantom: !0}), d = n.createRange(a, c).getTrimmed().end.nodeBefore;/* istanbul ignore next -- @preserve */
        d && ng(d, n, o)
    }
}

function Wu(s, {dataPipeline: e} = {}) {
    return (t, {writer: i}) => {
        if (!sg(t, s)) return null;
        if (!e) return i.createContainerElement("span", {class: "ck-list-bogus-paragraph"});
        const n = i.createContainerElement("p");
        return i.setCustomProperty("dataPipeline:transparentRendering", !0, n), n
    }
}

function hS(s, e, t) {
    const i = t.createRangeOn(s);
    return e.toViewRange(i).getTrimmed().end.nodeBefore
}

function fS(s, e) {
    return (t, i) => {
        if (i.modelPosition.offset > 0) return;
        const n = i.modelPosition.parent;
        if (!le(n) || !s.some(c => c.scope == "itemMarker" && c.canInjectMarkerIntoElement && c.canInjectMarkerIntoElement(n))) return;
        const o = i.mapper.toViewElement(n), r = e.createRangeIn(o), a = r.getWalker();
        let l = r.start;
        for (const {item: c} of a) {
            if (c.is("element") && i.mapper.toModelElement(c) || c.is("$textProxy")) break;
            c.is("element") && c.getCustomProperty("listItemMarker") && (l = e.createPositionAfter(c), a.skip(({previousPosition: u}) => !u.isEqual(l)))
        }
        i.viewPosition = l
    }
}

function ng(s, e, t) {
    for (; s.parent.is("attributeElement") && s.parent.getCustomProperty("listItemWrapper");) e.unwrap(e.createRangeOn(s), s.parent);
    const i = [];
    n(e.createPositionBefore(s).getWalker({direction: "backward"})), n(e.createRangeIn(s).getWalker());
    for (const o of i) e.remove(o);

    function n(o) {
        for (const {item: r} of o) {
            if (r.is("element") && t.toModelElement(r)) break;
            r.is("element") && r.getCustomProperty("listItemMarker") && i.push(r)
        }
    }
}

function mS(s, e, t, i, {dataPipeline: n}) {
    let o = i.createRangeOn(e);
    if (!ni(s)) return o;
    for (const r of t) {
        if (r.scope != "itemMarker") continue;
        const a = r.createElement(i, s, {dataPipeline: n});
        if (!a || (i.setCustomProperty("listItemMarker", !0, a), r.canInjectMarkerIntoElement && r.canInjectMarkerIntoElement(s) ? i.insert(i.createPositionAt(e, 0), a) : (i.insert(o.start, a), o = i.createRange(i.createPositionBefore(a), i.createPositionAfter(e))), !r.createWrapperElement || !r.canWrapElement)) continue;
        const l = r.createWrapperElement(i, s, {dataPipeline: n});
        i.setCustomProperty("listItemWrapper", !0, l), r.canWrapElement(s) ? o = i.wrap(o, l) : (o = i.wrap(i.createRangeOn(a), l), o = i.createRange(o.start, i.createPositionAfter(e)))
    }
    return o
}

function gS(s, e) {
    let t = s.parent;
    for (; t.is("attributeElement") && ["ul", "ol", "li"].includes(t.name);) {
        const i = t.parent;
        e.unwrap(e.createRangeOn(s), t), t = i
    }
}

function pS(s, e, t, i) {
    if (!s.hasAttribute("listIndent")) return;
    const n = s.getAttribute("listIndent");
    let o = s;
    for (let r = n; r >= 0; r--) {
        const a = rS(i, r, o.getAttribute("listItemId")), l = oS(i, r, o.getAttribute("listType"));
        for (const c of t) (c.scope == "list" || c.scope == "item") && o.hasAttribute(c.attributeName) && c.setAttributeOnDowncast(i, o.getAttribute(c.attributeName), c.scope == "list" ? l : a);
        if (e = i.wrap(e, a), e = i.wrap(e, l), r == 0 || (o = Ze.first(o, {lowerIndent: !0}), !o)) break
    }
}

function wS(s) {
    return (e, t) => {
        const i = [];
        for (const n of s) e.hasAttribute(n) && i.push(`attribute:${n}`);
        return i.every(n => t.test(e, n) !== !1) ? (i.forEach(n => t.consume(e, n)), !0) : !1
    }
}

function sg(s, e, t = Oa(s)) {
    if (!le(s)) return !1;
    for (const i of s.getAttributeKeys()) if (!(i.startsWith("selection:") || i == "htmlEmptyBlock") && !e.includes(i)) return !1;
    return t.length < 2
}

const Ts = ["listType", "listIndent", "listItemId"];

class bS extends w {
    _downcastStrategies = [];

    static get pluginName() {
        return "ListEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Gn, mt, iS, $e]
    }

    constructor(e) {
        super(e), e.config.define("list.multiBlock", !0)
    }

    init() {
        const e = this.editor, t = e.model, i = e.config.get("list.multiBlock");
        if (e.plugins.has("LegacyListEditing")) throw new p("list-feature-conflict", this, {conflictPlugin: "LegacyListEditing"});
        t.schema.register("$listItem", {allowAttributes: Ts}), i ? (t.schema.extend("$container", {allowAttributesOf: "$listItem"}), t.schema.extend("$block", {allowAttributesOf: "$listItem"}), t.schema.extend("$blockObject", {allowAttributesOf: "$listItem"})) : t.schema.register("listItem", {
            inheritAllFrom: "$block",
            allowAttributesOf: "$listItem"
        });
        for (const n of Ts) t.schema.setAttributeProperties(n, {copyOnReplace: !0});
        e.commands.add("numberedList", new hs(e, "numbered")), e.commands.add("bulletedList", new hs(e, "bulleted")), e.commands.add("customNumberedList", new hs(e, "customNumbered", {multiLevel: !0})), e.commands.add("customBulletedList", new hs(e, "customBulleted", {multiLevel: !0})), e.commands.add("indentList", new Nu(e, "forward")), e.commands.add("outdentList", new Nu(e, "backward")), e.commands.add("splitListItemBefore", new Uu(e, "before")), e.commands.add("splitListItemAfter", new Uu(e, "after")), i && (e.commands.add("mergeListItemBackward", new Hu(e, "backward")), e.commands.add("mergeListItemForward", new Hu(e, "forward"))), this._setupDeleteIntegration(), this._setupEnterIntegration(), this._setupTabIntegration(), this._setupClipboardIntegration(), this._setupAccessibilityIntegration()
    }

    afterInit() {
        const t = this.editor.commands, i = t.get("indent"), n = t.get("outdent");
        i && i.registerChildCommand(t.get("indentList"), {priority: "high"}), n && n.registerChildCommand(t.get("outdentList"), {priority: "lowest"}), this._setupModelPostFixing(), this._setupConversion()
    }

    registerDowncastStrategy(e) {
        this._downcastStrategies.push(e)
    }

    getListAttributeNames() {
        return [...Ts, ...this._downcastStrategies.map(e => e.attributeName)]
    }

    _setupDeleteIntegration() {
        const e = this.editor, t = e.commands.get("mergeListItemBackward"), i = e.commands.get("mergeListItemForward");
        this.listenTo(e.editing.view.document, "delete", (n, o) => {
            const r = e.model.document.selection;
            zn(e.model) || e.model.change(() => {
                const a = r.getFirstPosition();
                if (r.isCollapsed && o.direction == "backward") {
                    if (!a.isAtStart) return;
                    const l = a.parent;
                    if (!le(l)) return;
                    if (!Ze.first(l, {
                        sameAttributes: "listType",
                        sameIndent: !0
                    }) && l.getAttribute("listIndent") === 0) Du(l) || e.execute("splitListItemAfter"), e.execute("outdentList"); else {
                        if (!t || !t.isEnabled) return;
                        t.execute({shouldMergeOnBlocksContentLevel: qu(e.model, "backward")})
                    }
                    o.preventDefault(), n.stop()
                } else {
                    if (r.isCollapsed && !r.getLastPosition().isAtEnd || !i || !i.isEnabled) return;
                    i.execute({shouldMergeOnBlocksContentLevel: qu(e.model, "forward")}), o.preventDefault(), n.stop()
                }
            })
        }, {context: "li"})
    }

    _setupEnterIntegration() {
        const e = this.editor, t = e.model, i = e.commands, n = i.get("enter");
        this.listenTo(e.editing.view.document, "enter", (o, r) => {
            const a = t.document, l = a.selection.getFirstPosition().parent;
            if (a.selection.isCollapsed && le(l) && l.isEmpty && !r.isSoft) {
                const c = ni(l), u = Du(l);
                c && u ? (e.execute("outdentList"), r.preventDefault(), o.stop()) : c && !u ? (e.execute("splitListItemAfter"), r.preventDefault(), o.stop()) : u && (e.execute("splitListItemBefore"), r.preventDefault(), o.stop())
            }
        }, {context: "li"}), this.listenTo(n, "afterExecute", () => {
            const o = i.get("splitListItemBefore");
            if (o.refresh(), !o.isEnabled) return;
            const a = e.model.document.selection.getLastPosition().parent;
            Oa(a).length === 2 && o.execute()
        })
    }

    _setupTabIntegration() {
        const e = this.editor;
        this.listenTo(e.editing.view.document, "tab", (t, i) => {
            const n = i.shiftKey ? "outdentList" : "indentList";
            this.editor.commands.get(n).isEnabled && (e.execute(n), i.stopPropagation(), i.preventDefault(), t.stop())
        }, {context: "li"})
    }

    _setupConversion() {
        const e = this.editor, t = e.model, i = this.getListAttributeNames(), n = e.config.get("list.multiBlock"),
            o = n ? "paragraph" : "listItem";
        e.conversion.for("upcast").elementToElement({
            view: "li",
            model: (a, {writer: l}) => l.createElement(o, {listType: ""})
        }).elementToElement({
            view: "p",
            model: (a, {writer: l}) => a.parent && a.parent.is("element", "li") ? l.createElement(o, {listType: ""}) : null,
            converterPriority: "high"
        }).add(a => {
            a.on("element:li", cS())
        }), n || e.conversion.for("downcast").elementToElement({
            model: "listItem",
            view: "p"
        }), e.conversion.for("editingDowncast").elementToElement({
            model: o,
            view: Wu(i),
            converterPriority: "high"
        }).add(a => {
            a.on("attribute", $u(i, this._downcastStrategies, t)), a.on("remove", dS(t.schema))
        }), e.conversion.for("dataDowncast").elementToElement({
            model: o,
            view: Wu(i, {dataPipeline: !0}),
            converterPriority: "high"
        }).add(a => {
            a.on("attribute", $u(i, this._downcastStrategies, t, {dataPipeline: !0}))
        });
        const r = fS(this._downcastStrategies, e.editing.view);
        e.editing.mapper.on("modelToViewPosition", r), e.data.mapper.on("modelToViewPosition", r), this.listenTo(t.document, "change:data", uS(t, e.editing, i, this), {priority: "high"}), this.on("checkAttributes:item", (a, {
            viewElement: l,
            modelAttributes: c
        }) => {
            l.id != c.listItemId && (a.return = !0, a.stop())
        }), this.on("checkAttributes:list", (a, {viewElement: l, modelAttributes: c}) => {
            (l.name != tg(c.listType) || l.id != ig(c.listType, c.listIndent)) && (a.return = !0, a.stop())
        })
    }

    _setupModelPostFixing() {
        const e = this.editor.model, t = this.getListAttributeNames();
        e.document.registerPostFixer(i => _S(e, i, t, this)), this.on("postFixer", (i, {listNodes: n, writer: o}) => {
            i.return = aS(n, o) || i.return
        }, {priority: "high"}), this.on("postFixer", (i, {listNodes: n, writer: o, seenIds: r}) => {
            i.return = lS(n, r, o) || i.return
        }, {priority: "high"})
    }

    _setupClipboardIntegration() {
        const e = this.editor.model, t = this.editor.plugins.get("ClipboardPipeline");
        this.listenTo(e, "insertContent", vS(e), {priority: "high"}), this.listenTo(t, "outputTransformation", (i, n) => {
            e.change(o => {
                const r = Array.from(n.content.getChildren()), a = r[r.length - 1];
                if (r.length > 1 && a.is("element") && a.isEmpty && r.slice(0, -1).every(le) && o.remove(a), n.method == "copy" || n.method == "cut") {
                    const l = Array.from(n.content.getChildren());
                    Nn(l) && fo(l, o)
                }
            })
        })
    }

    _setupAccessibilityIntegration() {
        const e = this.editor, t = e.t;
        e.accessibility.addKeystrokeInfoGroup({
            id: "list",
            label: t("Keystrokes that can be used in a list"),
            keystrokes: [{
                label: t("Increase list item indent"),
                keystroke: "Tab"
            }, {label: t("Decrease list item indent"), keystroke: "Shift+Tab"}]
        })
    }
}

function _S(s, e, t, i) {
    const n = s.document.differ.getChanges(), o = new Set, r = new Set, a = i.editor.config.get("list.multiBlock");
    let l = !1;
    for (const u of n) {
        if (u.type == "insert" && u.name != "$text") {
            const d = u.position.nodeAfter;
            if (!s.schema.checkAttribute(d, "listItemId")) for (const h of Array.from(d.getAttributeKeys())) t.includes(h) && (e.removeAttribute(h, d), l = !0);
            Ye(u.position, r, o), u.attributes.has("listItemId") || Ye(u.position.getShiftedBy(u.length), r, o);
            for (const {item: h, previousPosition: f} of s.createRangeIn(d)) le(h) && Ye(f, r, o)
        } else u.type == "remove" ? Ye(u.position, r, o) : u.type == "attribute" && t.includes(u.attributeKey) && (Ye(u.range.start, r, o), u.attributeNewValue === null && Ye(u.range.start.getShiftedBy(1), r, o));
        if (!a && u.type == "attribute" && Ts.includes(u.attributeKey)) {
            const d = u.range.start.nodeAfter;
            u.attributeNewValue === null && d && d.is("element", "listItem") ? (e.rename(d, "paragraph"), l = !0) : u.attributeOldValue === null && d && d.is("element") && d.name != "listItem" && (e.rename(d, "listItem"), l = !0)
        }
    }
    const c = new Set;
    for (const u of r.values()) l = i.fire("postFixer", {
        listNodes: new ZI(u),
        listHead: u,
        writer: e,
        seenIds: c
    }) || l;
    return l
}

function vS(s) {
    return (e, [t, i]) => {
        const n = t.is("documentFragment") ? Array.from(t.getChildren()) : [t];
        if (!n.length) return;
        const r = (i ? s.createSelection(i) : s.document.selection).getFirstPosition();
        let a;
        if (le(r.parent)) a = r.parent; else if (le(r.nodeBefore) && le(r.nodeAfter)) a = r.nodeBefore; else return;
        s.change(l => {
            const c = a.getAttribute("listType"), u = a.getAttribute("listIndent"),
                d = n[0].getAttribute("listIndent") || 0, h = Math.max(u - d, 0);
            for (const f of n) {
                const m = le(f);
                a.is("element", "listItem") && f.is("element", "paragraph") && l.rename(f, "listItem"), l.setAttributes({
                    listIndent: (m ? f.getAttribute("listIndent") : 0) + h,
                    listItemId: m ? f.getAttribute("listItemId") : Zi.next(),
                    listType: c
                }, f)
            }
        })
    }
}

function qu(s, e) {
    const t = s.document.selection;
    if (!t.isCollapsed) return !zn(s);
    if (e === "forward") return !0;
    const n = t.getFirstPosition().parent, o = n.previousSibling;
    return s.schema.isObject(o) ? !1 : o.isEmpty ? !0 : Nn([n, o])
}

function ju(s, e, t, i) {
    s.ui.componentFactory.add(e, () => {
        const n = Gu(I, s, e, t, i);
        return n.set({tooltip: !0, isToggleable: !0}), n
    }), s.ui.componentFactory.add(`menuBar:${e}`, () => {
        const n = Gu(K, s, e, t, i);
        return n.set({role: "menuitemcheckbox", isToggleable: !0}), n
    })
}

function Gu(s, e, t, i, n) {
    const o = e.commands.get(t), r = new s(e.locale);
    return r.set({label: i, icon: n}), r.bind("isOn", "isEnabled").to(o, "value", "isEnabled"), r.on("execute", () => {
        e.execute(t), e.editing.view.focus()
    }), r
}

class yS extends w {
    static get pluginName() {
        return "ListUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor.t;
        this.editor.ui.componentFactory.has("numberedList") || ju(this.editor, "numberedList", e("Numbered List"), u1), this.editor.ui.componentFactory.has("bulletedList") || ju(this.editor, "bulletedList", e("Bulleted List"), Gv)
    }
}

class kS extends w {
    static get requires() {
        return [bS, yS]
    }

    static get pluginName() {
        return "List"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

const CS = [{listStyle: "disc", typeAttribute: "disc", listType: "bulleted"}, {
    listStyle: "circle",
    typeAttribute: "circle",
    listType: "bulleted"
}, {listStyle: "square", typeAttribute: "square", listType: "bulleted"}, {
    listStyle: "decimal",
    typeAttribute: "1",
    listType: "numbered"
}, {listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered"}, {
    listStyle: "lower-roman",
    typeAttribute: "i",
    listType: "numbered"
}, {listStyle: "upper-roman", typeAttribute: "I", listType: "numbered"}, {
    listStyle: "lower-alpha",
    typeAttribute: "a",
    listType: "numbered"
}, {listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered"}, {
    listStyle: "lower-latin",
    typeAttribute: "a",
    listType: "numbered"
}, {listStyle: "upper-latin", typeAttribute: "A", listType: "numbered"}];
for (const {listStyle: s, typeAttribute: e, listType: t} of CS) ;/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Ku(s, e) {
    const t = (i, n, o) => {
        if (!o.consumable.consume(n.item, i.name)) return;
        const r = n.attributeNewValue, a = o.writer, l = o.mapper.toViewElement(n.item),
            c = [...l.getChildren()].find(d => d.getCustomProperty("media-content"));
        a.remove(c);
        const u = s.getMediaViewElement(a, r, e);
        a.insert(a.createPositionAt(l, 0), u)
    };
    return i => {
        i.on("attribute:url:media", t)
    }
}

function ES(s, e, t) {
    return e.setCustomProperty("media", !0, s), Xi(s, e, {label: t})
}

function Zu(s, e, t, i) {
    return s.createContainerElement("figure", {class: "media"}, [e.getMediaViewElement(s, t, i), s.createSlot()])
}

function Ju(s) {
    const e = s.getSelectedElement();
    return e && e.is("element", "media") ? e : null
}

function og(s, e, t, i) {
    s.change(n => {
        const o = n.createElement("media", {url: e});
        s.insertObject(o, t, null, {setSelection: "on", findOptimalPosition: i ? "auto" : void 0})
    })
}

class TS extends O {
    refresh() {
        const e = this.editor.model, t = e.document.selection, i = Ju(t);
        this.value = i ? i.getAttribute("url") : void 0, this.isEnabled = xS(t) || AS(t, e)
    }

    execute(e) {
        const t = this.editor.model, i = t.document.selection, n = Ju(i);
        n ? t.change(o => {
            o.setAttribute("url", e, n)
        }) : og(t, e, i, !0)
    }
}

function AS(s, e) {
    let i = ka(s, e).start.parent;
    return i.isEmpty && !e.schema.isLimit(i) && (i = i.parent), e.schema.checkChild(i, "media")
}

function xS(s) {
    const e = s.getSelectedElement();
    return !!e && e.name === "media"
}

const IS = "0 0 64 42";

class SS {
    locale;
    providerDefinitions;

    constructor(e, t) {
        const i = t.providers, n = t.extraProviders || [], o = new Set(t.removeProviders), r = i.concat(n).filter(a => {
            const l = a.name;
            return l ? !o.has(l) : (L("media-embed-no-provider-name", {provider: a}), !1)
        });
        this.locale = e, this.providerDefinitions = r
    }

    hasMedia(e) {
        return !!this._getMedia(e)
    }

    getMediaViewElement(e, t, i) {
        return this._getMedia(t).getViewElement(e, i)
    }

    _getMedia(e) {
        if (!e) return new Qu(this.locale);
        e = e.trim();
        for (const t of this.providerDefinitions) {
            const i = t.html, n = U(t.url);
            for (const o of n) {
                const r = this._getUrlMatches(e, o);
                if (r) return new Qu(this.locale, e, r, i)
            }
        }
        return null
    }

    _getUrlMatches(e, t) {
        let i = e.match(t);
        if (i) return i;
        let n = e.replace(/^https?:\/\//, "");
        return i = n.match(t), i || (n = n.replace(/^www\./, ""), i = n.match(t), i) ? i : null
    }
}

class Qu {
    url;
    _locale;
    _match;
    _previewRenderer;

    constructor(e, t, i, n) {
        this.url = this._getValidUrl(t), this._locale = e, this._match = i, this._previewRenderer = n
    }

    getViewElement(e, t) {
        const i = {};
        let n;
        if (t.renderForEditingView || t.renderMediaPreview && this.url && this._previewRenderer) {
            this.url && (i["data-oembed-url"] = this.url), t.renderForEditingView && (i.class = "ck-media__wrapper");
            const o = this._getPreviewHtml(t);
            n = e.createRawElement("div", i, (r, a) => {
                a.setContentOf(r, o)
            })
        } else this.url && (i.url = this.url), n = e.createEmptyElement(t.elementName, i);
        return e.setCustomProperty("media-content", !0, n), n
    }

    _getPreviewHtml(e) {
        return this._previewRenderer ? this._previewRenderer(this._match) : this.url && e.renderForEditingView ? this._getPlaceholderHtml() : ""
    }

    _getPlaceholderHtml() {
        const e = new ot, t = this._locale.t;
        return e.content = l1, e.viewBox = IS, new Te({
            tag: "div",
            attributes: {class: "ck ck-reset_all ck-media__placeholder"},
            children: [{tag: "div", attributes: {class: "ck-media__placeholder__icon"}, children: [e]}, {
                tag: "a",
                attributes: {
                    class: "ck-media__placeholder__url",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    href: this.url,
                    "data-cke-tooltip-text": t("Open media in new tab")
                },
                children: [{tag: "span", attributes: {class: "ck-media__placeholder__url__text"}, children: [this.url]}]
            }]
        }).render().outerHTML
    }

    _getValidUrl(e) {
        return e ? e.match(/^https?/) ? e : "https://" + e : null
    }
}

class Gs extends w {
    static get pluginName() {
        return "MediaEmbedEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    registry;

    constructor(e) {
        super(e), e.config.define("mediaEmbed", {
            elementName: "oembed",
            providers: [{
                name: "dailymotion",
                url: [/^dailymotion\.com\/video\/(\w+)/, /^dai.ly\/(\w+)/],
                html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`
            }, {
                name: "spotify",
                url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/],
                html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`
            }, {
                name: "youtube",
                url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/, /^(?:m\.)?youtube\.com\/shorts\/([\w-]+)(?:\?t=(\d+))?/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/, /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/, /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/],
                html: t => {
                    const i = t[1], n = t[2];
                    return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${i}${n ? `?start=${n}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`
                }
            }, {
                name: "vimeo",
                url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/],
                html: t => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`
            }, {
                name: "instagram",
                url: [/^instagram\.com\/p\/(\w+)/, /^instagram\.com\/reel\/(\w+)/]
            }, {name: "twitter", url: [/^twitter\.com/, /^x\.com/]}, {
                name: "googleMaps",
                url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/]
            }, {name: "flickr", url: /^flickr\.com/}, {name: "facebook", url: /^facebook\.com/}]
        }), this.registry = new SS(e.locale, e.config.get("mediaEmbed"))
    }

    init() {
        const e = this.editor, t = e.model.schema, i = e.t, n = e.conversion,
            o = e.config.get("mediaEmbed.previewsInData"), r = e.config.get("mediaEmbed.elementName"),
            a = this.registry;
        e.commands.add("mediaEmbed", new TS(e)), t.register("media", {
            inheritAllFrom: "$blockObject",
            allowAttributes: ["url"]
        }), n.for("dataDowncast").elementToStructure({
            model: "media", view: (l, {writer: c}) => {
                const u = l.getAttribute("url");
                return Zu(c, a, u, {elementName: r, renderMediaPreview: !!u && o})
            }
        }), n.for("dataDowncast").add(Ku(a, {
            elementName: r,
            renderMediaPreview: o
        })), n.for("editingDowncast").elementToStructure({
            model: "media", view: (l, {writer: c}) => {
                const u = l.getAttribute("url"), d = Zu(c, a, u, {elementName: r, renderForEditingView: !0});
                return ES(d, c, i("media widget"))
            }
        }), n.for("editingDowncast").add(Ku(a, {
            elementName: r,
            renderForEditingView: !0
        })), n.for("upcast").elementToElement({
            view: l => ["oembed", r].includes(l.name) && l.getAttribute("url") ? {name: !0} : null,
            model: (l, {writer: c}) => {
                const u = l.getAttribute("url");
                return a.hasMedia(u) ? c.createElement("media", {url: u}) : null
            }
        }).elementToElement({
            view: {name: "div", attributes: {"data-oembed-url": !0}}, model: (l, {writer: c}) => {
                const u = l.getAttribute("data-oembed-url");
                return a.hasMedia(u) ? c.createElement("media", {url: u}) : null
            }
        }).add(l => {
            const c = (u, d, h) => {
                if (!h.consumable.consume(d.viewItem, {name: !0, classes: "media"})) return;
                const {modelRange: f, modelCursor: m} = h.convertChildren(d.viewItem, d.modelCursor);
                d.modelRange = f, d.modelCursor = m, re(f.getItems()) || h.consumable.revert(d.viewItem, {
                    name: !0,
                    classes: "media"
                })
            };
            l.on("element:figure", c)
        })
    }
}

const PS = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;

class RS extends w {
    static get requires() {
        return [Ea, mt, Ta]
    }

    static get pluginName() {
        return "AutoMediaEmbed"
    }

    static get isOfficialPlugin() {
        return !0
    }

    _timeoutId;
    _positionToInsert;

    constructor(e) {
        super(e), this._timeoutId = null, this._positionToInsert = null
    }

    init() {
        const e = this.editor, t = e.model.document, i = e.plugins.get("ClipboardPipeline");
        this.listenTo(i, "inputTransformation", () => {
            const o = t.selection.getFirstRange(), r = Y.fromPosition(o.start);
            r.stickiness = "toPrevious";
            const a = Y.fromPosition(o.end);
            a.stickiness = "toNext", t.once("change:data", () => {
                this._embedMediaBetweenPositions(r, a), r.detach(), a.detach()
            }, {priority: "high"})
        }), e.commands.get("undo").on("execute", () => {
            this._timeoutId && (C.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null)
        }, {priority: "high"})
    }

    _embedMediaBetweenPositions(e, t) {
        const i = this.editor, n = i.plugins.get(Gs).registry, o = new Ce(e, t),
            r = o.getWalker({ignoreElementEnd: !0});
        let a = "";
        for (const c of r) c.item.is("$textProxy") && (a += c.item.data);
        if (a = a.trim(), !a.match(PS)) {
            o.detach();
            return
        }
        if (!n.hasMedia(a)) {
            o.detach();
            return
        }
        if (!i.commands.get("mediaEmbed").isEnabled) {
            o.detach();
            return
        }
        this._positionToInsert = Y.fromPosition(e), this._timeoutId = C.window.setTimeout(() => {
            i.model.change(c => {
                this._timeoutId = null, c.remove(o), o.detach();
                let u = null;
                this._positionToInsert.root.rootName !== "$graveyard" && (u = this._positionToInsert), og(i.model, a, u, !1), this._positionToInsert.detach(), this._positionToInsert = null
            }), i.plugins.get(mt).requestUndoOnBackspace()
        }, 100)
    }
}

class VS extends T {
    focusTracker;
    keystrokes;
    urlInputView;
    _validators;
    _urlInputViewInfoDefault;
    _urlInputViewInfoTip;

    constructor(e, t) {
        super(t), this.focusTracker = new se, this.keystrokes = new ue, this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this._validators = e, this.setTemplate({
            tag: "form",
            attributes: {class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1"},
            children: [this.urlInputView]
        })
    }

    render() {
        super.render(), li({view: this}), this.focusTracker.add(this.urlInputView.element), this.keystrokes.listenTo(this.element)
    }

    destroy() {
        super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy()
    }

    focus() {
        this.urlInputView.focus()
    }

    get url() {
        return this.urlInputView.fieldView.element.value.trim()
    }

    set url(e) {
        this.urlInputView.fieldView.value = e.trim()
    }

    isValid() {
        this.resetFormStatus();
        for (const e of this._validators) {
            const t = e(this);
            if (t) return this.urlInputView.errorText = t, !1
        }
        return !0
    }

    resetFormStatus() {
        this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault
    }

    _createUrlInput() {
        const e = this.locale.t, t = new Ut(this.locale, ti), i = t.fieldView;
        return this._urlInputViewInfoDefault = e("Paste the media URL in the input."), this._urlInputViewInfoTip = e("Tip: Paste the URL into the content to embed faster."), t.label = e("Media URL"), t.infoText = this._urlInputViewInfoDefault, i.inputMode = "url", i.on("input", () => {
            t.infoText = i.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = i.element.value.trim()
        }), t
    }
}

class OS extends w {
    static get requires() {
        return [Gs, Me]
    }

    static get pluginName() {
        return "MediaEmbedUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    _formView;

    init() {
        const e = this.editor;
        e.ui.componentFactory.add("mediaEmbed", () => {
            const t = this.editor.locale.t, i = this._createDialogButton(I);
            return i.tooltip = !0, i.label = t("Insert media"), i
        }), e.ui.componentFactory.add("menuBar:mediaEmbed", () => {
            const t = this.editor.locale.t, i = this._createDialogButton(K);
            return i.label = t("Media"), i
        })
    }

    _createDialogButton(e) {
        const t = this.editor, i = new e(t.locale), n = t.commands.get("mediaEmbed"),
            o = this.editor.plugins.get("Dialog");
        return i.icon = c1, i.bind("isEnabled").to(n, "isEnabled"), i.on("execute", () => {
            o.id === "mediaEmbed" ? o.hide() : this._showDialog()
        }), i
    }

    _showDialog() {
        const e = this.editor, t = e.plugins.get("Dialog"), i = e.commands.get("mediaEmbed"), n = e.locale.t,
            o = i.value !== void 0;
        if (!this._formView) {
            const r = e.plugins.get(Gs).registry;
            this._formView = new ($i(VS))(MS(e.t, r), e.locale), this._formView.on("submit", () => this._handleSubmitForm())
        }
        t.show({
            id: "mediaEmbed",
            title: n("Media embed"),
            content: this._formView,
            isModal: !0,
            onShow: () => {
                this._formView.url = i.value || "", this._formView.resetFormStatus(), this._formView.urlInputView.fieldView.select()
            },
            actionButtons: [{
                label: n("Cancel"),
                withText: !0,
                onExecute: () => t.hide()
            }, {
                label: n(o ? "Save" : "Insert"),
                class: "ck-button-action",
                withText: !0,
                onExecute: () => this._handleSubmitForm()
            }]
        })
    }

    _handleSubmitForm() {
        const e = this.editor, t = e.plugins.get("Dialog");
        this._formView.isValid() && (e.execute("mediaEmbed", this._formView.url), t.hide(), e.editing.view.focus())
    }
}

function MS(s, e) {
    return [t => {
        if (!t.url.length) return s("The URL must not be empty.")
    }, t => {
        if (!e.hasMedia(t.url)) return s("This media URL is not supported.")
    }]
}

class BS extends w {
    static get requires() {
        return [Gs, OS, RS, di]
    }

    static get pluginName() {
        return "MediaEmbed"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const Yu = {"(": ")", "[": "]", "{": "}"};

class FS extends O {
    constructor(e) {
        super(e), this._isEnabledBasedOnSelection = !1
    }

    refresh() {
        const e = this.editor.model, t = e.document;
        this.isEnabled = e.schema.checkAttributeInSelection(t.selection, "mention")
    }

    execute(e) {
        const t = this.editor.model, n = t.document.selection,
            o = typeof e.mention == "string" ? {id: e.mention} : e.mention, r = o.id, a = e.range || n.getFirstRange();
        if (!t.canEditAt(a)) return;
        const l = e.text || r, c = rg({_text: l, id: r}, o);
        if (!r.startsWith(e.marker)) throw new p("mentioncommand-incorrect-id", this);
        t.change(u => {
            const d = nt(n.getAttributes()), h = new Map(d.entries());
            h.set("mention", c);
            const f = t.insertContent(u.createText(l, h), a), m = f.start.nodeBefore, g = f.end.nodeAfter,
                _ = g && g.is("$text") && g.data.startsWith(" ");
            let v = !1;
            if (m && g && m.is("$text") && g.is("$text")) {
                const E = m.data.slice(-1), V = E in Yu, N = V && g.data.startsWith(Yu[E]);
                v = V && N
            }
            !v && !_ && t.insertContent(u.createText(" ", d), a.start.getShiftedBy(l.length))
        })
    }
}

class LS extends w {
    static get pluginName() {
        return "MentionEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = e.model, i = t.document;
        t.schema.extend("$text", {allowAttributes: "mention"}), e.conversion.for("upcast").elementToAttribute({
            view: {
                name: "span",
                attributes: "data-mention",
                classes: "mention"
            }, model: {key: "mention", value: n => ag(n)}
        }), e.conversion.for("downcast").attributeToElement({
            model: "mention",
            view: NS
        }), e.conversion.for("downcast").add(DS), i.registerPostFixer(n => US(n, i, t.schema)), i.registerPostFixer(n => $S(n, i)), i.registerPostFixer(n => zS(n, i)), e.commands.add("mention", new FS(e))
    }
}

function rg(s, e) {
    return Object.assign({uid: pe()}, s, e || {})
}

function ag(s, e) {
    const t = s.getAttribute("data-mention"), i = s.getChild(0);
    if (!i) return;
    const n = {id: t, _text: i.data};
    return rg(n, e)
}

function DS(s) {
    s.on("attribute:mention", (e, t, i) => {
        const n = t.attributeNewValue;
        if (!t.item.is("$textProxy") || !n) return;
        const o = t.range.start;
        (o.textNode || o.nodeAfter).data != n._text && i.consumable.consume(t.item, e.name)
    }, {priority: "highest"})
}

function NS(s, {writer: e}) {
    if (!s) return;
    const t = {class: "mention", "data-mention": s.id}, i = {id: s.uid, priority: 20};
    return e.createAttributeElement("span", t, i)
}

function zS(s, e) {
    const t = e.selection, i = t.focus;
    return t.isCollapsed && t.hasAttribute("mention") && HS(i) ? (s.removeSelectionAttribute("mention"), !0) : !1
}

function HS(s) {
    const e = s.isAtStart;
    return s.nodeBefore && s.nodeBefore.is("$text") || e
}

function US(s, e, t) {
    const i = e.differ.getChanges();
    let n = !1;
    for (const o of i) {
        if (o.type == "attribute") continue;
        const r = o.position;
        if (o.name == "$text") {
            const a = r.textNode && r.textNode.nextSibling;
            n = Jt(r.textNode, s) || n, n = Jt(a, s) || n, n = Jt(r.nodeBefore, s) || n, n = Jt(r.nodeAfter, s) || n
        }
        if (o.name != "$text" && o.type == "insert") {
            const a = r.nodeAfter;
            for (const l of s.createRangeIn(a).getItems()) n = Jt(l, s) || n
        }
        if (o.type == "insert" && t.isInline(o.name)) {
            const a = r.nodeAfter && r.nodeAfter.nextSibling;
            n = Jt(r.nodeBefore, s) || n, n = Jt(a, s) || n
        }
    }
    return n
}

function $S(s, e) {
    const t = e.differ.getChanges();
    let i = !1;
    for (const n of t) if (n.type === "attribute" && n.attributeKey != "mention") {
        const o = n.range.start.nodeBefore, r = n.range.end.nodeAfter;
        for (const a of [o, r]) lg(a) && a.getAttribute(n.attributeKey) != n.attributeNewValue && (s.setAttribute(n.attributeKey, n.attributeNewValue, a), i = !0)
    }
    return i
}

function lg(s) {
    if (!s || !(s.is("$text") || s.is("$textProxy")) || !s.hasAttribute("mention")) return !1;
    const e = s.data, i = s.getAttribute("mention")._text;
    return e != i
}

function Jt(s, e) {
    return lg(s) ? (e.removeAttribute("mention", s), !0) : !1
}

class WS extends ui {
    selected;
    position;

    constructor(e) {
        super(e), this.extendTemplate({attributes: {class: ["ck-mentions"], tabindex: "-1"}})
    }

    selectFirst() {
        this.select(0)
    }

    selectNext() {
        const e = this.selected, t = this.items.getIndex(e);
        this.select(t + 1)
    }

    selectPrevious() {
        const e = this.selected, t = this.items.getIndex(e);
        this.select(t - 1)
    }

    select(e) {
        let t = 0;
        e > 0 && e < this.items.length ? t = e : e < 0 && (t = this.items.length - 1);
        const i = this.items.get(t);
        this.selected !== i && (this.selected && this.selected.removeHighlight(), i.highlight(), this.selected = i, this._isItemVisibleInScrolledArea(i) || (this.element.scrollTop = i.element.offsetTop))
    }

    executeSelected() {
        this.selected.fire("execute")
    }

    _isItemVisibleInScrolledArea(e) {
        return new R(this.element).contains(new R(e.element))
    }
}

class qS extends T {
    domElement;

    constructor(e, t) {
        super(e), this.template = void 0, this.domElement = t, this.domElement.classList.add("ck-button"), this.set("isOn", !1), this.on("change:isOn", (i, n, o) => {
            o ? (this.domElement.classList.add("ck-on"), this.domElement.classList.remove("ck-off")) : (this.domElement.classList.add("ck-off"), this.domElement.classList.remove("ck-on"))
        }), this.listenTo(this.domElement, "click", () => {
            this.fire("execute")
        })
    }

    render() {
        super.render(), this.element = this.domElement
    }

    focus() {
        this.domElement.focus()
    }
}

class jS extends Ke {
    item;
    marker;

    highlight() {
        const e = this.children.first;
        e.isOn = !0
    }

    removeHighlight() {
        const e = this.children.first;
        e.isOn = !1
    }
}

const fs = 3, GS = [M.arrowup, M.arrowdown, M.esc], KS = [M.enter, M.tab];

class ZS extends w {
    _mentionsView;
    _mentionsConfigurations;
    _balloon;
    _items = new ce;
    _lastRequested;
    _requestFeedDebounced;

    static get pluginName() {
        return "MentionUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [ii]
    }

    constructor(e) {
        super(e), this._mentionsView = this._createMentionView(), this._mentionsConfigurations = new Map, this._requestFeedDebounced = it(this._requestFeed, 100), e.config.define("mention", {feeds: []})
    }

    init() {
        const e = this.editor, t = e.config.get("mention.commitKeys") || KS, i = GS.concat(t);
        this._balloon = e.plugins.get(ii), e.editing.view.document.on("keydown", (r, a) => {
            o(a.keyCode) && this._isUIVisible && (a.preventDefault(), r.stop(), a.keyCode == M.arrowdown && this._mentionsView.selectNext(), a.keyCode == M.arrowup && this._mentionsView.selectPrevious(), t.includes(a.keyCode) && this._mentionsView.executeSelected(), a.keyCode == M.esc && this._hideUIAndRemoveMarker())
        }, {priority: "highest"}), Ji({
            emitter: this._mentionsView,
            activator: () => this._isUIVisible,
            contextElements: () => [this._balloon.view.element],
            callback: () => this._hideUIAndRemoveMarker()
        });
        const n = e.config.get("mention.feeds");
        for (const r of n) {
            const {feed: a, marker: l, dropdownLimit: c} = r;
            if (!iP(l)) throw new p("mentionconfig-incorrect-marker", null, {marker: l});
            const u = typeof a == "function" ? a.bind(this.editor) : XS(a), d = r.itemRenderer,
                h = {marker: l, feedCallback: u, itemRenderer: d, dropdownLimit: c};
            this._mentionsConfigurations.set(l, h)
        }
        this._setupTextWatcher(n), this.listenTo(e, "change:isReadOnly", () => {
            this._hideUIAndRemoveMarker()
        }), this.on("requestFeed:response", (r, a) => this._handleFeedResponse(a)), this.on("requestFeed:error", () => this._hideUIAndRemoveMarker());

        function o(r) {
            return i.includes(r)
        }
    }

    destroy() {
        super.destroy(), this._mentionsView.destroy()
    }

    get _isUIVisible() {
        return this._balloon.visibleView === this._mentionsView
    }

    _createMentionView() {
        const e = this.editor.locale, t = new WS(e);
        return t.items.bindTo(this._items).using(i => {
            const {item: n, marker: o} = i, {dropdownLimit: r} = this._mentionsConfigurations.get(o),
                a = r || this.editor.config.get("mention.dropdownLimit") || 10;
            if (t.items.length >= a) return null;
            const l = new jS(e), c = this._renderItem(n, o);
            return c.delegate("execute").to(l), l.children.add(c), l.item = n, l.marker = o, l.on("execute", () => {
                t.fire("execute", {item: n, marker: o})
            }), l
        }), t.on("execute", (i, n) => {
            const o = this.editor, r = o.model, a = n.item, l = n.marker, c = o.model.markers.get("mention"),
                u = r.createPositionAt(r.document.selection.focus), d = r.createPositionAt(c.getStart()),
                h = r.createRange(d, u);
            this._hideUIAndRemoveMarker(), o.execute("mention", {
                mention: a,
                text: a.text,
                marker: l,
                range: h
            }), o.editing.view.focus()
        }), t
    }

    _getItemRenderer(e) {
        const {itemRenderer: t} = this._mentionsConfigurations.get(e);
        return t
    }

    _requestFeed(e, t) {
        this._lastRequested = t;
        const {feedCallback: i} = this._mentionsConfigurations.get(e), n = i(t);
        if (!(n instanceof Promise)) {
            this.fire("requestFeed:response", {feed: n, marker: e, feedText: t});
            return
        }
        n.then(r => {
            this._lastRequested == t ? this.fire("requestFeed:response", {
                feed: r,
                marker: e,
                feedText: t
            }) : this.fire("requestFeed:discarded", {feed: r, marker: e, feedText: t})
        }).catch(r => {
            this.fire("requestFeed:error", {error: r}), L("mention-feed-callback-error", {marker: e})
        })
    }

    _setupTextWatcher(e) {
        const t = this.editor, i = e.map(r => ({...r, pattern: ug(r.marker, r.minimumCharacters || 0)})),
            n = new ya(t.model, QS(i));
        n.on("matched", (r, a) => {
            const l = cg(i, a.text), u = t.model.document.selection.focus,
                d = t.model.createPositionAt(u.parent, l.position);
            if (eP(u) || tP(d)) {
                this._hideUIAndRemoveMarker();
                return
            }
            const h = YS(l, a.text), f = l.marker.length + h.length, m = u.getShiftedBy(-f),
                g = u.getShiftedBy(-h.length), _ = t.model.createRange(m, g);
            if (tr(t)) {
                const v = t.model.markers.get("mention");
                t.model.change(E => {
                    E.updateMarker(v, {range: _})
                })
            } else t.model.change(v => {
                v.addMarker("mention", {range: _, usingOperation: !1, affectsData: !1})
            });
            this._requestFeedDebounced(l.marker, h)
        }), n.on("unmatched", () => {
            this._hideUIAndRemoveMarker()
        });
        const o = t.commands.get("mention");
        return n.bind("isEnabled").to(o), n
    }

    _handleFeedResponse(e) {
        const {feed: t, marker: i} = e;
        if (!tr(this.editor)) return;
        this._items.clear();
        for (const o of t) {
            const r = typeof o != "object" ? {id: o, text: o} : o;
            this._items.add({item: r, marker: i})
        }
        const n = this.editor.model.markers.get("mention");
        this._items.length ? this._showOrUpdateUI(n) : this._hideUIAndRemoveMarker()
    }

    _showOrUpdateUI(e) {
        this._isUIVisible ? this._balloon.updatePosition(this._getBalloonPanelPositionData(e, this._mentionsView.position)) : this._balloon.add({
            view: this._mentionsView,
            position: this._getBalloonPanelPositionData(e, this._mentionsView.position),
            singleViewMode: !0,
            balloonClassName: "ck-mention-balloon"
        }), this._mentionsView.position = this._balloon.view.position, this._mentionsView.selectFirst()
    }

    _hideUIAndRemoveMarker() {
        this._balloon.hasView(this._mentionsView) && this._balloon.remove(this._mentionsView), tr(this.editor) && this.editor.model.change(e => e.removeMarker("mention")), this._mentionsView.position = void 0
    }

    _renderItem(e, t) {
        const i = this.editor;
        let n, o = e.id;
        const r = this._getItemRenderer(t);
        if (r) {
            const a = r(e);
            typeof a != "string" ? n = new qS(i.locale, a) : o = a
        }
        if (!n) {
            const a = new I(i.locale);
            a.label = o, a.withText = !0, n = a
        }
        return n
    }

    _getBalloonPanelPositionData(e, t) {
        const i = this.editor, n = i.editing, o = n.view.domConverter, r = n.mapper, a = i.locale.uiLanguageDirection;
        return {
            target: () => {
                let l = e.getRange();
                l.start.root.rootName == "$graveyard" && (l = i.model.document.selection.getFirstRange());
                const c = r.toViewRange(l);
                return R.getDomRangeRects(o.viewRangeToDom(c)).pop()
            }, limiter: () => {
                const l = this.editor.editing.view, u = l.document.selection.editableElement;
                return u ? l.domConverter.mapViewToDom(u.root) : null
            }, positions: JS(t, a)
        }
    }
}

function JS(s, e) {
    const t = {
        caret_se: i => ({top: i.bottom + fs, left: i.right, name: "caret_se", config: {withArrow: !1}}),
        caret_ne: (i, n) => ({top: i.top - n.height - fs, left: i.right, name: "caret_ne", config: {withArrow: !1}}),
        caret_sw: (i, n) => ({top: i.bottom + fs, left: i.right - n.width, name: "caret_sw", config: {withArrow: !1}}),
        caret_nw: (i, n) => ({
            top: i.top - n.height - fs,
            left: i.right - n.width,
            name: "caret_nw",
            config: {withArrow: !1}
        })
    };
    return Object.prototype.hasOwnProperty.call(t, s) ? [t[s]] : e !== "rtl" ? [t.caret_se, t.caret_sw, t.caret_ne, t.caret_nw] : [t.caret_sw, t.caret_se, t.caret_nw, t.caret_ne]
}

function cg(s, e) {
    let t;
    for (const i of s) {
        const n = e.lastIndexOf(i.marker);
        n > 0 && !e.substring(n - 1).match(i.pattern) || (!t || n >= t.position) && (t = {
            marker: i.marker,
            position: n,
            minimumCharacters: i.minimumCharacters,
            pattern: i.pattern
        })
    }
    return t
}

function ug(s, e) {
    const t = e == 0 ? "*" : `{${e},}`,
        i = x.features.isRegExpUnicodePropertySupported ? `\\p{Ps}\\p{Pi}"'` : `\\(\\[{"'`, n = ".";
    s = s.replace(/[.*+?^${}()\-|[\]\\]/g, "\\$&");
    const o = `(?:^|[ ${i}])(${s})(${n}${t})$`;
    return new RegExp(o, "u")
}

function QS(s) {
    return t => {
        const i = cg(s, t);
        if (!i) return !1;
        let n = 0;
        i.position !== 0 && (n = i.position - 1);
        const o = t.substring(n);
        return i.pattern.test(o)
    }
}

function YS(s, e) {
    let t = 0;
    s.position !== 0 && (t = s.position - 1);
    const i = ug(s.marker, 0);
    return e.substring(t).match(i)[2]
}

function XS(s) {
    return e => s.filter(i => (typeof i == "string" ? i : String(i.id)).toLowerCase().includes(e.toLowerCase()))
}

function eP(s) {
    const e = s.textNode && s.textNode.hasAttribute("mention"), t = s.nodeBefore;
    return e || t && t.is("$text") && t.hasAttribute("mention")
}

function tP(s) {
    const e = s.nodeAfter;
    return e && e.is("$text") && e.hasAttribute("mention")
}

function iP(s) {
    return !!s
}

function tr(s) {
    return s.model.markers.has("mention")
}

class nP extends w {
    toMentionAttribute(e, t) {
        return ag(e, t)
    }

    static get pluginName() {
        return "Mention"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [LS, ZS]
    }
}/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function sP(s, e) {
    const t = [];
    for (const i of e.createRangeIn(s)) {
        const n = i.item;
        n.is("element", "a") && !n.hasAttribute("href") && (n.hasAttribute("id") || n.hasAttribute("name")) && t.push(n)
    }
    for (const i of t) {
        const n = i.parent.getChildIndex(i) + 1, o = i.getChildren();
        e.insertChild(n, o, i.parent)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function dg(s) {
    const e = parseFloat(s);
    return s.endsWith("pt") ? Si(e * 96 / 72) : s.endsWith("pc") ? Si(e * 12 * 96 / 72) : s.endsWith("in") ? Si(e * 96) : s.endsWith("cm") ? Si(e * 96 / 2.54) : s.endsWith("mm") ? Si(e / 10 * 96 / 2.54) : s
}

function Xu(s) {
    return s !== void 0 && s.endsWith("px")
}

function Si(s) {
    return Math.round(s) + "px"
}

function oP(s, e, t) {
    if (!s.childCount) return;
    const i = new pt(s.document), n = aP(s, i);
    if (!n.length) return;
    const o = {}, r = [];
    for (const a of n) if (a.indent !== void 0) {
        lP(a) || (r.length = 0);
        const l = `${a.id}:${a.indent}`, c = Math.min(a.indent - 1, r.length);
        if (c < r.length && r[c].id !== a.id && (r.length = c), c < r.length - 1) r.length = c + 1; else {
            const d = cP(a, e);
            if (c > r.length - 1 || r[c].listElement.name != d.type) {
                c == 0 && d.type == "ol" && a.id !== void 0 && o[l] && (d.startIndex = o[l]);
                const h = fP(d, i, t);
                if (Xu(a.marginLeft) && (c == 0 || Xu(r[c - 1].marginLeft))) {
                    let f = a.marginLeft;
                    c > 0 && (f = Si(parseFloat(f) - parseFloat(r[c - 1].marginLeft))), i.setStyle("padding-left", f, h)
                }
                if (r.length == 0) {
                    const f = a.element.parent, m = f.getChildIndex(a.element) + 1;
                    i.insertChild(m, h, f)
                } else {
                    const f = r[c - 1].listItemElements;
                    i.appendChild(h, f[f.length - 1])
                }
                r[c] = {
                    ...a,
                    listElement: h,
                    listItemElements: []
                }, c == 0 && a.id !== void 0 && (o[l] = d.startIndex || 1)
            }
        }
        const u = a.element.name == "li" ? a.element : i.createElement("li");
        i.appendChild(u, r[c].listElement), r[c].listItemElements.push(u), c == 0 && a.id !== void 0 && o[l]++, a.element != u && i.appendChild(a.element, u), gP(a.element, i), i.removeStyle("text-indent", a.element), i.removeStyle("margin-left", a.element)
    } else {
        const l = r.find(c => c.marginLeft == a.marginLeft);
        if (l) {
            const c = l.listItemElements;
            i.appendChild(a.element, c[c.length - 1]), i.removeStyle("margin-left", a.element)
        } else r.length = 0
    }
}

function rP(s, e) {
    for (const t of e.createRangeIn(s)) {
        const i = t.item;
        if (i.is("element", "li")) {
            const n = i.getChild(0);
            n && n.is("element", "p") && e.unwrapElement(n)
        }
    }
}

function aP(s, e) {
    const t = e.createRangeIn(s), i = [], n = new Set;
    for (const o of t.getItems()) {
        if (!o.is("element") || !o.name.match(/^(p|h\d+|li|div)$/)) continue;
        let r = pP(o);
        if (r !== void 0 && parseFloat(r) == 0 && !Array.from(o.getClassNames()).find(a => a.startsWith("MsoList")) && (r = void 0), o.hasStyle("mso-list") || r !== void 0 && n.has(r)) {
            const a = mP(o);
            i.push({element: o, id: a.id, order: a.order, indent: a.indent, marginLeft: r}), r !== void 0 && n.add(r)
        } else n.clear()
    }
    return i
}

function lP(s) {
    const e = s.element.previousSibling;
    return ed(e || s.element.parent)
}

function ed(s) {
    return s.is("element", "ol") || s.is("element", "ul")
}

function cP(s, e) {
    const t = new RegExp(`@list l${s.id}:level${s.indent}\\s*({[^}]*)`, "gi"),
        i = /mso-level-number-format:([^;]{0,100});/gi, n = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi,
        o = new RegExp(`@list\\s+l${s.id}:level\\d\\s*{[^{]*mso-level-text:"%\\d\\\\.`, "gi"),
        r = new RegExp(`@list l${s.id}:level\\d\\s*{[^{]*mso-level-number-format:`, "gi"), a = o.exec(e), l = r.exec(e),
        c = a && !l, u = t.exec(e);
    let d = "decimal", h = "ol", f = null;
    if (u && u[1]) {
        const m = i.exec(u[1]);
        if (m && m[1] && (d = m[1].trim(), h = d !== "bullet" && d !== "image" ? "ol" : "ul"), d === "bullet") {
            const g = uP(s.element);
            g && (d = g)
        } else {
            const g = n.exec(u[1]);
            g && g[1] && (f = parseInt(g[1]))
        }
        c && (h = "ol")
    }
    return {type: h, startIndex: f, style: hP(d), isLegalStyleList: c}
}

function uP(s) {
    if (s.name == "li" && s.parent.name == "ul" && s.parent.hasAttribute("type")) return s.parent.getAttribute("type");
    const e = dP(s);
    if (!e) return null;
    const t = e._data;
    return t === "o" ? "circle" : t === "·" ? "disc" : t === "§" ? "square" : null
}

function dP(s) {
    if (s.getChild(0).is("$text")) return null;
    for (const e of s.getChildren()) {
        if (!e.is("element", "span")) continue;
        const t = e.getChild(0);
        if (t) return t.is("$text") ? t : t.getChild(0)
    }/* istanbul ignore next -- @preserve */
    return null
}

function hP(s) {
    if (s.startsWith("arabic-leading-zero")) return "decimal-leading-zero";
    switch (s) {
        case"alpha-upper":
            return "upper-alpha";
        case"alpha-lower":
            return "lower-alpha";
        case"roman-upper":
            return "upper-roman";
        case"roman-lower":
            return "lower-roman";
        case"circle":
        case"disc":
        case"square":
            return s;
        default:
            return null
    }
}

function fP(s, e, t) {
    const i = e.createElement(s.type);
    return s.style && e.setStyle("list-style-type", s.style, i), s.startIndex && s.startIndex > 1 && e.setAttribute("start", s.startIndex, i), s.isLegalStyleList && t && e.addClass("legal-list", i), i
}

function mP(s) {
    const e = s.getStyle("mso-list");
    if (e === void 0) return {};
    const t = e.match(/(^|\s{1,100})l(\d+)/i), i = e.match(/\s{0,100}lfo(\d+)/i), n = e.match(/\s{0,100}level(\d+)/i);
    return t && i && n ? {id: t[2], order: i[1], indent: parseInt(n[1])} : {indent: 1}
}

function gP(s, e) {
    const t = new He({name: "span", styles: {"mso-list": "Ignore"}}), i = e.createRangeIn(s);
    for (const n of i) n.type === "elementStart" && t.match(n.item) && e.remove(n.item)
}

function pP(s) {
    const e = s.getStyle("margin-left");
    return e === void 0 || e.endsWith("px") ? e : dg(e)
}

function wP(s, e) {
    if (!s.childCount) return;
    const t = new pt(s.document), i = _P(s, t);
    vP(i, s, t), kP(i, s, t), yP(s, t);
    const n = CP(s, t);
    n.length && TP(n, EP(e), t)
}

function bP(s) {
    return btoa(s.match(/\w{2}/g).map(e => String.fromCharCode(parseInt(e, 16))).join(""))
}

function _P(s, e) {
    const t = e.createRangeIn(s), i = new He({name: /v:(.+)/}), n = [];
    for (const o of t) {
        if (o.type != "elementStart") continue;
        const r = o.item, a = r.previousSibling, l = a && a.is("element") ? a.name : null, c = ["Chart"],
            u = i.match(r), d = r.getAttribute("o:gfxdata"), h = l === "v:shapetype",
            f = d && c.some(m => r.getAttribute("id").includes(m));
        u && d && !h && !f && n.push(o.item.getAttribute("id"))
    }
    return n
}

function vP(s, e, t) {
    const i = t.createRangeIn(e), n = new He({name: "img"}), o = [];
    for (const r of i) if (r.item.is("element") && n.match(r.item)) {
        const a = r.item, l = a.getAttribute("v:shapes") ? a.getAttribute("v:shapes").split(" ") : [];
        l.length && l.every(c => s.indexOf(c) > -1) ? o.push(a) : a.getAttribute("src") || o.push(a)
    }
    for (const r of o) t.remove(r)
}

function yP(s, e) {
    const t = e.createRangeIn(s), i = new He({name: /v:(.+)/}), n = [];
    for (const o of t) o.type == "elementStart" && i.match(o.item) && n.push(o.item);
    for (const o of n) e.remove(o)
}

function kP(s, e, t) {
    const i = t.createRangeIn(e), n = [];
    for (const a of i) if (a.type == "elementStart" && a.item.is("element", "v:shape")) {
        const l = a.item.getAttribute("id");
        if (s.includes(l)) continue;
        o(a.item.parent.getChildren(), l) || n.push(a.item)
    }
    for (const a of n) {
        const l = {src: r(a)};
        a.hasAttribute("alt") && (l.alt = a.getAttribute("alt"));
        const c = t.createElement("img", l);
        t.insertChild(a.index + 1, c, a.parent)
    }

    function o(a, l) {
        for (const c of a) {/* istanbul ignore else -- @preserve */
            if (c.is("element") && (c.name == "img" && c.getAttribute("v:shapes") == l || o(c.getChildren(), l))) return !0
        }
        return !1
    }

    function r(a) {
        for (const l of a.getChildren()) {/* istanbul ignore else -- @preserve */
            if (l.is("element") && l.getAttribute("src")) return l.getAttribute("src")
        }
    }
}

function CP(s, e) {
    const t = e.createRangeIn(s), i = new He({name: "img"}), n = [];
    let o = 0;
    for (const r of t) r.item.is("element") && i.match(r.item) && (r.item.getAttribute("src").startsWith("file://") && n.push({
        element: r.item,
        imageIndex: o
    }), o++);
    return n
}

function EP(s) {
    if (!s) return [];
    const e = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/,
        t = new RegExp("(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}", "g"), i = s.match(t), n = [];
    if (i) for (const o of i) {
        let r = !1;
        o.includes("\\pngblip") ? r = "image/png" : o.includes("\\jpegblip") && (r = "image/jpeg"), r && n.push({
            hex: o.replace(e, "").replace(/[^\da-fA-F]/g, ""),
            type: r
        })
    }
    return n
}

function TP(s, e, t) {
    for (let i = 0; i < s.length; i++) {
        const {element: n, imageIndex: o} = s[i], r = e[o];
        if (r) {
            const a = `data:${r.type};base64,${bP(r.hex)}`;
            t.setAttribute("src", a, n)
        }
    }
}

function AP(s) {
    const e = [], t = new pt(s.document);
    for (const {item: i} of t.createRangeIn(s)) if (i.is("element")) {
        for (const n of i.getClassNames()) /\bmso/gi.exec(n) && t.removeClass(n, i);
        for (const n of i.getStyleNames()) /\bmso/gi.exec(n) && t.removeStyle(n, i);
        (i.is("element", "w:sdt") || i.is("element", "w:sdtpr") && i.isEmpty || i.is("element", "o:p") && i.isEmpty) && e.push(i)
    }
    for (const i of e) {
        const n = i.parent, o = n.getChildIndex(i);
        t.insertChild(o, i.getChildren(), n), t.remove(i)
    }
}

function xP(s, e) {
    for (const t of e.createRangeIn(s).getItems()) {
        if (!t.is("element", "table") && !t.is("element", "td") && !t.is("element", "th")) continue;
        const i = ["left", "top", "right", "bottom"];
        if (i.every(o => !t.hasStyle(`border-${o}-style`))) e.setStyle("border-style", "none", t); else for (const o of i) t.hasStyle(`border-${o}-style`) || e.setStyle(`border-${o}-style`, "none", t);
        const n = ["width", "height", ...i.map(o => `border-${o}-width`), ...i.map(o => `padding-${o}`)];
        for (const o of n) t.hasStyle(o) && e.setStyle(o, dg(t.getStyle(o)), t)
    }
}

const IP = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i,
    SP = /xmlns:o="urn:schemas-microsoft-com/i;

class PP {
    document;
    hasMultiLevelListPlugin;

    constructor(e, t = !1) {
        this.document = e, this.hasMultiLevelListPlugin = t
    }

    isActive(e) {
        return IP.test(e) || SP.test(e)
    }

    execute(e) {
        const t = new pt(this.document), {body: i, stylesString: n} = e._parsedData;
        sP(i, t), oP(i, n, this.hasMultiLevelListPlugin), wP(i, e.dataTransfer.getData("text/rtf")), xP(i, t), AP(i), e.content = i
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function RP(s, e) {
    for (const t of s.getChildren()) if (t.is("element", "b") && t.getStyle("font-weight") === "normal") {
        const i = s.getChildIndex(t);
        e.remove(t), e.insertChild(i, t.getChildren(), s)
    }
}

function VP(s, e) {
    const t = new Ys(e.document.stylesProcessor), i = new eo(t, {renderingMode: "data"}), n = i.blockElements,
        o = i.inlineObjectElements, r = [];
    for (const a of e.createRangeIn(s)) {
        const l = a.item;
        if (l.is("element", "br")) {
            const c = td(l, "forward", e, {blockElements: n, inlineObjectElements: o}),
                u = td(l, "backward", e, {blockElements: n, inlineObjectElements: o}), d = id(c, n);
            (id(u, n) || d) && r.push(l)
        }
    }
    for (const a of r) a.hasClass("Apple-interchange-newline") ? e.remove(a) : e.replace(a, e.createElement("p"))
}

function td(s, e, t, {blockElements: i, inlineObjectElements: n}) {
    let o = t.createPositionAt(s, e == "forward" ? "after" : "before");
    return o = o.getLastMatchingPosition(({item: r}) => r.is("element") && !i.includes(r.name) && !n.includes(r.name), {direction: e}), e == "forward" ? o.nodeAfter : o.nodeBefore
}

function id(s, e) {
    return !!s && s.is("element") && e.includes(s.name)
}

const OP = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;

class MP {
    document;

    constructor(e) {
        this.document = e
    }

    isActive(e) {
        return OP.test(e)
    }

    execute(e) {
        const t = new pt(this.document), {body: i} = e._parsedData;
        RP(i, t), rP(i, t), VP(i, t), e.content = i
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function BP(s, e) {
    for (const t of s.getChildren()) t.is("element", "table") && t.hasAttribute("xmlns") && e.removeAttribute("xmlns", t)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function FP(s, e) {
    for (const t of s.getChildren()) if (t.is("element", "google-sheets-html-origin")) {
        const i = s.getChildIndex(t);
        e.remove(t), e.insertChild(i, t.getChildren(), s)
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function LP(s, e) {
    for (const t of s.getChildren()) t.is("element", "table") && t.getStyle("width") === "0px" && e.removeStyle("width", t)
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function DP(s, e) {
    for (const t of Array.from(s.getChildren())) t.is("element", "style") && e.remove(t)
}

const NP = /<google-sheets-html-origin/i;

class zP {
    document;

    constructor(e) {
        this.document = e
    }

    isActive(e) {
        return NP.test(e)
    }

    execute(e) {
        const t = new pt(this.document), {body: i} = e._parsedData;
        FP(i, t), BP(i, t), LP(i, t), DP(i, t), e.content = i
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function HP(s) {
    return nd(nd(s)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><")
}

function UP(s) {
    s.querySelectorAll("span[style*=spacerun]").forEach(e => {
        const t = e, i = t.innerText.length || 0;
        t.innerText = Array(i + 1).join("  ").substr(0, i)
    })
}

function nd(s) {
    return s.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (e, t) => t.length === 1 ? " " : Array(t.length + 1).join("  ").substr(0, t.length))
}

function $P(s, e) {
    const t = new DOMParser;
    s = s.replace(/<!--\[if gte vml 1]>/g, ""), s = s.replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, "");
    const i = HP(jP(s)), n = t.parseFromString(i, "text/html");
    UP(n);
    const o = n.body.innerHTML, r = WP(n, e), a = qP(n);
    return {body: r, bodyString: o, styles: a.styles, stylesString: a.stylesString}
}

function WP(s, e) {
    const t = new Ys(e), i = new eo(t, {renderingMode: "data"}), n = s.createDocumentFragment(), o = s.body.childNodes;
    for (; o.length > 0;) n.appendChild(o[0]);
    return i.domToView(n, {skipComments: !0})
}

function qP(s) {
    const e = [], t = [], i = Array.from(s.getElementsByTagName("style"));
    for (const n of i) n.sheet && n.sheet.cssRules && n.sheet.cssRules.length && (e.push(n.sheet), t.push(n.innerHTML));
    return {styles: e, stylesString: t.join(" ")}
}

function jP(s) {
    const e = "</body>", t = "</html>", i = s.indexOf(e);
    if (i < 0) return s;
    const n = s.indexOf(t, i + e.length);
    return s.substring(0, i + e.length) + (n >= 0 ? s.substring(n) : "")
}

class GP extends w {
    static get pluginName() {
        return "PasteFromOffice"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [$e]
    }

    init() {
        const e = this.editor, t = e.plugins.get("ClipboardPipeline"), i = e.editing.view.document, n = [],
            o = this.editor.plugins.has("MultiLevelList");
        n.push(new PP(i, o)), n.push(new MP(i)), n.push(new zP(i)), t.on("inputTransformation", (r, a) => {
            if (a._isTransformedWithPasteFromOffice || e.model.document.selection.getFirstPosition().parent.is("element", "codeBlock")) return;
            const c = a.dataTransfer.getData("text/html"), u = n.find(d => d.isActive(c));
            u && (a._parsedData || (a._parsedData = $P(c, i.stylesProcessor)), u.execute(a), a._isTransformedWithPasteFromOffice = !0)
        }, {priority: "high"})
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const ms = "removeFormat";

class KP extends w {
    static get pluginName() {
        return "RemoveFormatUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        e.ui.componentFactory.add(ms, () => {
            const t = this._createButton(I);
            return t.set({tooltip: !0}), t
        }), e.ui.componentFactory.add(`menuBar:${ms}`, () => this._createButton(K))
    }

    _createButton(e) {
        const t = this.editor, i = t.locale, n = t.commands.get(ms), o = new e(t.locale), r = i.t;
        return o.set({
            label: r("Remove Format"),
            icon: E1
        }), o.bind("isEnabled").to(n, "isEnabled"), this.listenTo(o, "execute", () => {
            t.execute(ms), t.editing.view.focus()
        }), o
    }
}

class ZP extends O {
    refresh() {
        const e = this.editor.model;
        this.isEnabled = !!re(this._getFormattingItems(e.document.selection, e.schema))
    }

    execute() {
        const e = this.editor.model, t = e.schema;
        e.change(i => {
            for (const n of this._getFormattingItems(e.document.selection, t)) if (n.is("selection")) for (const o of this._getFormattingAttributes(n, t)) i.removeSelectionAttribute(o); else {
                const o = i.createRangeOn(n);
                for (const r of this._getFormattingAttributes(n, t)) i.removeAttribute(r, o)
            }
        })
    }

    * _getFormattingItems(e, t) {
        const i = n => !!re(this._getFormattingAttributes(n, t));
        for (const n of e.getRanges()) for (const o of n.getItems()) !t.isBlock(o) && i(o) && (yield o);
        for (const n of e.getSelectedBlocks()) i(n) && (yield n);
        i(e) && (yield e)
    }

    * _getFormattingAttributes(e, t) {
        for (const [i] of e.getAttributes()) {
            const n = t.getAttributeProperties(i);
            n && n.isFormatting && (yield i)
        }
    }
}

class JP extends w {
    static get pluginName() {
        return "RemoveFormatEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor;
        e.commands.add("removeFormat", new ZP(e))
    }
}

class QP extends w {
    static get requires() {
        return [JP, KP]
    }

    static get pluginName() {
        return "RemoveFormat"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */const gs = "SourceEditingMode";

class YP extends w {
    static get pluginName() {
        return "SourceEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Hi]
    }

    _elementReplacer;
    _replacedRoots;
    _dataFromRoots;

    constructor(e) {
        super(e), this.set("isSourceEditingMode", !1), this._elementReplacer = new eh, this._replacedRoots = new Map, this._dataFromRoots = new Map, e.config.define("sourceEditing.allowCollaborationFeatures", !1)
    }

    init() {
        this._checkCompatibility();
        const e = this.editor, t = e.locale.t;
        e.ui.componentFactory.add("sourceEditing", () => {
            const i = this._createButton(I);
            return i.set({label: t("Source"), icon: I1, tooltip: !0, class: "ck-source-editing-button"}), i
        }), e.ui.componentFactory.add("menuBar:sourceEditing", () => {
            const i = this._createButton(K);
            return i.set({label: t("Show source"), role: "menuitemcheckbox"}), i
        }), this._isAllowedToHandleSourceEditingMode() && (this.on("change:isSourceEditingMode", (i, n, o) => {
            o ? (this._hideVisibleDialog(), this._showSourceEditing(), this._disableCommands()) : (this._hideSourceEditing(), this._enableCommands())
        }), this.on("change:isEnabled", (i, n, o) => this._handleReadOnlyMode(!o)), this.listenTo(e, "change:isReadOnly", (i, n, o) => this._handleReadOnlyMode(o))), e.data.on("get", () => {
            this.isSourceEditingMode && this.updateEditorData()
        }, {priority: "high"})
    }

    updateEditorData() {
        const e = this.editor, t = {};
        for (const [i, n] of this._replacedRoots) {
            const o = this._dataFromRoots.get(i), r = n.dataset.value;
            o !== r && (t[i] = r, this._dataFromRoots.set(i, r))
        }
        Object.keys(t).length && e.data.set(t, {batchType: {isUndoable: !0}, suppressErrorInCollaboration: !0})
    }

    _checkCompatibility() {
        const e = this.editor, t = e.config.get("sourceEditing.allowCollaborationFeatures");
        if (!t && e.plugins.has("RealTimeCollaborativeEditing")) throw new p("source-editing-incompatible-with-real-time-collaboration", null);
        !t && ["CommentsEditing", "TrackChangesEditing", "RevisionHistory"].some(n => e.plugins.has(n)) && console.warn("You initialized the editor with the source editing feature and at least one of the collaboration features. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the collaboration features."), e.plugins.has("RestrictedEditingModeEditing") && console.warn("You initialized the editor with the source editing feature and restricted editing feature. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the restricted editing feature.")
    }

    _showSourceEditing() {
        const e = this.editor, t = e.editing.view, i = e.model;
        i.change(n => {
            n.setSelection(null), n.removeSelectionAttribute(i.document.selection.getAttributeKeys())
        });
        for (const [n, o] of t.domRoots) {
            const r = XP(e.data.get({rootName: n})),
                a = Oe(o.ownerDocument, "textarea", {rows: "1", "aria-label": "Source code editing area"}),
                l = Oe(o.ownerDocument, "div", {class: "ck-source-editing-area", "data-value": r}, [a]);
            a.value = r, a.setSelectionRange(0, 0), a.addEventListener("input", () => {
                l.dataset.value = a.value, e.ui.update()
            }), t.change(c => {
                const u = t.document.getRoot(n);
                c.addClass("ck-hidden", u)
            }), e.ui.setEditableElement("sourceEditing:" + n, a), this._replacedRoots.set(n, l), this._elementReplacer.replace(o, l), this._dataFromRoots.set(n, r)
        }
        this._hideDocumentOutline(), this._refreshAnnotationsVisibility(), this._focusSourceEditing()
    }

    _hideSourceEditing() {
        const t = this.editor.editing.view;
        this.updateEditorData(), t.change(i => {
            for (const [n] of this._replacedRoots) i.removeClass("ck-hidden", t.document.getRoot(n))
        }), this._elementReplacer.restore(), this._replacedRoots.clear(), this._dataFromRoots.clear(), this._showDocumentOutline(), this._refreshAnnotationsVisibility(), t.focus()
    }

    _hideDocumentOutline() {
        this.editor.plugins.has("DocumentOutlineUI") && (this.editor.plugins.get("DocumentOutlineUI").view.element.style.display = "none")
    }

    _showDocumentOutline() {
        this.editor.plugins.has("DocumentOutlineUI") && (this.editor.plugins.get("DocumentOutlineUI").view.element.style.display = "")
    }

    _refreshAnnotationsVisibility() {
        this.editor.plugins.has("Annotations") && this.editor.plugins.get("Annotations").refreshVisibility()
    }

    _focusSourceEditing() {
        const e = this.editor, [t] = this._replacedRoots.values(), i = t.querySelector("textarea");
        e.editing.view.document.isFocused = !1, i.focus()
    }

    _disableCommands() {
        const e = this.editor;
        for (const t of e.commands.commands()) t.forceDisabled(gs);
        e.plugins.has("CommentsArchiveUI") && e.plugins.get("CommentsArchiveUI").forceDisabled(gs)
    }

    _enableCommands() {
        const e = this.editor;
        for (const t of e.commands.commands()) t.clearForceDisabled(gs);
        e.plugins.has("CommentsArchiveUI") && e.plugins.get("CommentsArchiveUI").clearForceDisabled(gs)
    }

    _handleReadOnlyMode(e) {
        if (this.isSourceEditingMode) for (const [, t] of this._replacedRoots) t.querySelector("textarea").readOnly = e
    }

    _isAllowedToHandleSourceEditingMode() {
        const t = this.editor.ui.view.editable;
        return t && !t.hasExternalElement
    }

    _hideVisibleDialog() {
        if (this.editor.plugins.has("Dialog")) {
            const e = this.editor.plugins.get("Dialog");
            e.isOpen && e.hide()
        }
    }

    _createButton(e) {
        const t = this.editor, i = new e(t.locale);
        return i.set({
            withText: !0,
            isToggleable: !0
        }), i.bind("isOn").to(this, "isSourceEditingMode"), i.bind("isEnabled").to(this, "isEnabled", t, "isReadOnly", t.plugins.get(Hi), "hasAny", (n, o, r) => !(!n || o || r)), this.listenTo(i, "execute", () => {
            this.isSourceEditingMode = !this.isSourceEditingMode
        }), i
    }
}

function XP(s) {
    return e2(s) ? hw(s) : s
}

function e2(s) {
    return s.startsWith("<")
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function te(s, e, t, i, n = 1) {
    e != null && n !== void 0 && n !== null && e > n ? i.setAttribute(s, e, t) : i.removeAttribute(s, t)
}

function fi(s, e, t = {}) {
    const i = s.createElement("tableCell", t);
    return s.insertElement("paragraph", i), s.insert(i, e), i
}

function Br(s, e) {
    const t = e.parent.parent,
        i = parseInt(t.getAttribute("headingColumns") || "0"), {column: n} = s.getCellLocation(e);
    return !!i && n < i
}

function t2() {
    return s => {
        s.on("element:figure", (e, t, i) => {
            if (!i.consumable.test(t.viewItem, {name: !0, classes: "table"})) return;
            const n = s2(t.viewItem);
            if (!n || !i.consumable.test(n, {name: !0})) return;
            i.consumable.consume(t.viewItem, {name: !0, classes: "table"});
            const o = i.convertItem(n, t.modelCursor), r = re(o.modelRange.getItems());
            if (!r) {
                i.consumable.revert(t.viewItem, {name: !0, classes: "table"});
                return
            }
            i.convertChildren(t.viewItem, i.writer.createPositionAt(r, "end")), i.updateConversionResult(r, t)
        })
    }
}

function i2() {
    return s => {
        s.on("element:table", (e, t, i) => {
            const n = t.viewItem;
            if (!i.consumable.test(n, {name: !0})) return;
            const {rows: o, headingRows: r, headingColumns: a} = o2(n), l = {};
            a && (l.headingColumns = a), r && (l.headingRows = r);
            const c = i.writer.createElement("table", l);
            if (i.safeInsert(c, t.modelCursor)) {
                if (i.consumable.consume(n, {name: !0}), o.forEach(u => i.convertItem(u, i.writer.createPositionAt(c, "end"))), i.convertChildren(n, i.writer.createPositionAt(c, "end")), c.isEmpty) {
                    const u = i.writer.createElement("tableRow");
                    i.writer.insert(u, i.writer.createPositionAt(c, "end")), fi(i.writer, i.writer.createPositionAt(u, "end"))
                }
                i.updateConversionResult(c, t)
            }
        })
    }
}

function n2() {
    return s => {
        s.on("element:tr", (e, t) => {
            t.viewItem.isEmpty && t.modelCursor.index == 0 && e.stop()
        }, {priority: "high"})
    }
}

function sd(s) {
    return e => {
        e.on(`element:${s}`, (t, i, {writer: n}) => {
            if (!i.modelRange) return;
            const o = i.modelRange.start.nodeAfter, r = n.createPositionAt(o, 0);
            if (i.viewItem.isEmpty) {
                n.insertElement("paragraph", r);
                return
            }
            const a = Array.from(o.getChildren());
            if (a.every(l => l.is("element", "$marker"))) {
                const l = n.createElement("paragraph");
                n.insert(l, n.createPositionAt(o, 0));
                for (const c of a) n.move(n.createRangeOn(c), n.createPositionAt(l, "end"))
            }
        }, {priority: "low"})
    }
}

function s2(s) {
    for (const e of s.getChildren()) if (e.is("element", "table")) return e
}

function o2(s) {
    let e = 0, t;
    const i = [], n = [];
    let o;
    for (const r of Array.from(s.getChildren())) {
        if (r.name !== "tbody" && r.name !== "thead" && r.name !== "tfoot") continue;
        r.name === "thead" && !o && (o = r);
        const a = Array.from(r.getChildren()).filter(c => c.is("element", "tr"));
        let l = null;
        for (const c of a) {
            const u = Array.from(c.getChildren()).filter(d => d.is("element", "td") || d.is("element", "th"));
            if (o && r === o || r.name === "tbody" && u.length > 0 && (l === null || u.length === l) && u.every(d => d.is("element", "th"))) e++, i.push(c); else {
                n.push(c);
                const d = r2(c);
                (!t || d < t) && (t = d)
            }
            l = Math.max(l || 0, u.length)
        }
    }
    return {headingRows: e, headingColumns: t || 0, rows: [...i, ...n]}
}

function r2(s) {
    let e = 0, t = 0;
    const i = Array.from(s.getChildren()).filter(n => n.name === "th" || n.name === "td");
    for (; t < i.length && i[t].name === "th";) {
        const n = i[t], o = parseInt(n.getAttribute("colspan") || "1");
        e = e + o, t++
    }
    return e
}/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
class ${_table;_startRow;_endRow;_startColumn;_endColumn;_includeAllSlots;_skipRows;_row;_rowIndex;_column;_cellIndex;_spannedCells;_nextCellAtColumn;_jumpedToStartRow=!1;constructor(e,t={}
)
{
    this._table = e, this._startRow = t.row !== void 0 ? t.row : t.startRow || 0, this._endRow = t.row !== void 0 ? t.row : t.endRow, this._startColumn = t.column !== void 0 ? t.column : t.startColumn || 0, this._endColumn = t.column !== void 0 ? t.column : t.endColumn, this._includeAllSlots = !!t.includeAllSlots, this._skipRows = new Set, this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = new Map, this._nextCellAtColumn = -1
}
[Symbol.iterator]()
{
    return this
}
next()
{
    this._canJumpToStartRow() && this._jumpToNonSpannedRowClosestToStartRow();
    const e = this._table.getChild(this._rowIndex);
    if (!e || this._isOverEndRow()) return {done: !0, value: void 0};
    if (!e.is("element", "tableRow")) return this._rowIndex++, this.next();
    if (this._isOverEndColumn()) return this._advanceToNextRow();
    let t = null;
    const i = this._getSpanned();
    if (i) this._includeAllSlots && !this._shouldSkipSlot() && (t = this._formatOutValue(i.cell, i.row, i.column)); else {
        const n = e.getChild(this._cellIndex);
        if (!n) return this._advanceToNextRow();
        const o = parseInt(n.getAttribute("colspan") || "1"), r = parseInt(n.getAttribute("rowspan") || "1");
        (o > 1 || r > 1) && this._recordSpans(n, r, o), this._shouldSkipSlot() || (t = this._formatOutValue(n)), this._nextCellAtColumn = this._column + o
    }
    return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, t || this.next()
}
skipRow(e)
{
    this._skipRows.add(e)
}
_advanceToNextRow()
{
    return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next()
}
_isOverEndRow()
{
    return this._endRow !== void 0 && this._row > this._endRow
}
_isOverEndColumn()
{
    return this._endColumn !== void 0 && this._column > this._endColumn
}
_formatOutValue(e, t = this._row, i = this._column)
{
    return {done: !1, value: new a2(this, e, t, i)}
}
_shouldSkipSlot()
{
    const e = this._skipRows.has(this._row), t = this._row < this._startRow, i = this._column < this._startColumn,
        n = this._endColumn !== void 0 && this._column > this._endColumn;
    return e || t || i || n
}
_getSpanned()
{
    const e = this._spannedCells.get(this._row);
    return e && e.get(this._column) || null
}
_recordSpans(e, t, i)
{
    const n = {cell: e, row: this._row, column: this._column};
    for (let o = this._row; o < this._row + t; o++) for (let r = this._column; r < this._column + i; r++) (o != this._row || r != this._column) && this._markSpannedCell(o, r, n)
}
_markSpannedCell(e, t, i)
{
    this._spannedCells.has(e) || this._spannedCells.set(e, new Map), this._spannedCells.get(e).set(t, i)
}
_canJumpToStartRow()
{
    return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow
}
_jumpToNonSpannedRowClosestToStartRow()
{
    const e = this._getRowLength(0);
    for (let t = this._startRow; !this._jumpedToStartRow; t--) e === this._getRowLength(t) && (this._row = t, this._rowIndex = t, this._jumpedToStartRow = !0)
}
_getRowLength(e)
{
    return [...this._table.getChild(e).getChildren()].reduce((i, n) => i + parseInt(n.getAttribute("colspan") || "1"), 0)
}
}

class a2 {
    cell;
    row;
    column;
    cellAnchorRow;
    cellAnchorColumn;
    _cellIndex;
    _rowIndex;
    _table;

    constructor(e, t, i, n) {
        this.cell = t, this.row = e._row, this.column = e._column, this.cellAnchorRow = i, this.cellAnchorColumn = n, this._cellIndex = e._cellIndex, this._rowIndex = e._rowIndex, this._table = e._table
    }

    get isAnchor() {
        return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn
    }

    get cellWidth() {
        return parseInt(this.cell.getAttribute("colspan") || "1")
    }

    get cellHeight() {
        return parseInt(this.cell.getAttribute("rowspan") || "1")
    }

    get rowIndex() {
        return this._rowIndex
    }

    getPositionBefore() {
        return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex)
    }
}

function od(s, e) {
    return (t, {writer: i}) => {
        const n = t.getAttribute("headingRows") || 0, o = i.createContainerElement("table", null, []),
            r = i.createContainerElement("figure", {class: "table"}, o);
        n > 0 && i.insert(i.createPositionAt(o, "end"), i.createContainerElement("thead", null, i.createSlot(a => a.is("element", "tableRow") && a.index < n))), n < s.getRows(t) && i.insert(i.createPositionAt(o, "end"), i.createContainerElement("tbody", null, i.createSlot(a => a.is("element", "tableRow") && a.index >= n)));
        for (const {
            positionOffset: a,
            filter: l
        } of e.additionalSlots) i.insert(i.createPositionAt(o, a), i.createSlot(l));
        return i.insert(i.createPositionAt(o, "after"), i.createSlot(a => a.is("element", "tableRow") ? !1 : !e.additionalSlots.some(({filter: l}) => l(a)))), e.asWidget ? c2(r, i) : r
    }
}

function l2() {
    return (s, {writer: e}) => s.isEmpty ? e.createEmptyElement("tr") : e.createContainerElement("tr")
}

function rd(s = {}) {
    return (e, {writer: t}) => {
        const i = e.parent, n = i.parent, o = n.getChildIndex(i), r = new $(n, {row: o}),
            a = n.getAttribute("headingRows") || 0, l = n.getAttribute("headingColumns") || 0;
        let c = null;
        for (const u of r) if (u.cell == e) {
            const h = u.row < a || u.column < l ? "th" : "td";
            c = s.asWidget ? um(t.createEditableElement(h), t, {withAriaRole: !1}) : t.createContainerElement(h);
            break
        }
        return c
    }
}

function ad(s = {}) {
    return (e, {writer: t}) => {
        if (!e.parent.is("element", "tableCell") || !hg(e)) return null;
        if (s.asWidget) return t.createContainerElement("span", {class: "ck-table-bogus-paragraph"});
        {
            const i = t.createContainerElement("p");
            return t.setCustomProperty("dataPipeline:transparentRendering", !0, i), i
        }
    }
}

function hg(s) {
    return s.parent.childCount == 1 && !u2(s)
}

function c2(s, e) {
    return e.setCustomProperty("table", !0, s), Xi(s, e, {hasSelectionHandle: !0})
}

function u2(s) {
    for (const e of s.getAttributeKeys()) if (!(e.startsWith("selection:") || e == "htmlEmptyBlock")) return !0;
    return !1
}

class d2 extends O {
    refresh() {
        const e = this.editor.model, t = e.document.selection, i = e.schema;
        this.isEnabled = h2(t, i)
    }

    execute(e = {}) {
        const t = this.editor, i = t.model, n = t.plugins.get("TableUtils"),
            o = t.config.get("table.defaultHeadings.rows"), r = t.config.get("table.defaultHeadings.columns");
        e.headingRows === void 0 && o && (e.headingRows = o), e.headingColumns === void 0 && r && (e.headingColumns = r), i.change(a => {
            const l = n.createTable(a, e);
            i.insertObject(l, null, null, {findOptimalPosition: "auto"}), a.setSelection(a.createPositionAt(l.getNodeByPath([0, 0, 0]), 0))
        })
    }
}

function h2(s, e) {
    const t = s.getFirstPosition().parent, i = t === t.root ? t : t.parent;
    return e.checkChild(i, "table")
}

class ld extends O {
    order;

    constructor(e, t = {}) {
        super(e), this.order = t.order || "below"
    }

    refresh() {
        const e = this.editor.model.document.selection,
            i = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
        this.isEnabled = i
    }

    execute() {
        const e = this.editor, t = e.model.document.selection, i = e.plugins.get("TableUtils"),
            n = this.order === "above", o = i.getSelectionAffectedTableCells(t), r = i.getRowIndexes(o),
            a = n ? r.first : r.last, l = o[0].findAncestor("table");
        i.insertRows(l, {at: n ? a : a + 1, copyStructureFromAbove: !n})
    }
}

class cd extends O {
    order;

    constructor(e, t = {}) {
        super(e), this.order = t.order || "right"
    }

    refresh() {
        const e = this.editor.model.document.selection,
            i = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(e).length;
        this.isEnabled = i
    }

    execute() {
        const e = this.editor, t = e.model.document.selection, i = e.plugins.get("TableUtils"),
            n = this.order === "left", o = i.getSelectionAffectedTableCells(t), r = i.getColumnIndexes(o),
            a = n ? r.first : r.last, l = o[0].findAncestor("table");
        i.insertColumns(l, {columns: 1, at: n ? a : a + 1})
    }
}

class ud extends O {
    direction;

    constructor(e, t = {}) {
        super(e), this.direction = t.direction || "horizontally"
    }

    refresh() {
        const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
        this.isEnabled = t.length === 1
    }

    execute() {
        const e = this.editor.plugins.get("TableUtils"),
            t = e.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
        this.direction === "horizontally" ? e.splitCellHorizontally(t, 2) : e.splitCellVertically(t, 2)
    }
}

function fg(s, e, t) {
    const {startRow: i, startColumn: n, endRow: o, endColumn: r} = e, a = t.createElement("table"),
        l = s.getAttribute("tableType");
    l && t.setAttribute("tableType", l, a);
    const c = o - i + 1;
    for (let d = 0; d < c; d++) t.insertElement("tableRow", a, "end");
    const u = [...new $(s, {startRow: i, endRow: o, startColumn: n, endColumn: r, includeAllSlots: !0})];
    for (const {row: d, column: h, cell: f, isAnchor: m, cellAnchorRow: g, cellAnchorColumn: _} of u) {
        const v = d - i, E = a.getChild(v);
        if (!m) (g < i || _ < n) && fi(t, t.createPositionAt(E, "end")); else {
            const V = t.cloneElement(f);
            t.append(V, E), bg(V, d, h, o, r, t)
        }
    }
    return f2(a, s, i, n, t), a
}

function mg(s, e, t = 0) {
    const i = [], n = new $(s, {startRow: t, endRow: e - 1});
    for (const o of n) {
        const {row: r, cellHeight: a} = o, l = r + a - 1;
        r < e && e <= l && i.push(o)
    }
    return i
}

function gg(s, e, t) {
    const i = s.parent, n = i.parent, o = i.index, r = parseInt(s.getAttribute("rowspan")), a = e - o, l = {},
        c = r - a;
    c > 1 && (l.rowspan = c);
    const u = parseInt(s.getAttribute("colspan") || "1");
    u > 1 && (l.colspan = u);
    const d = o, h = d + a, f = [...new $(n, {startRow: d, endRow: h, includeAllSlots: !0})];
    let m = null, g;
    for (const _ of f) {
        const {row: v, column: E, cell: V} = _;
        V === s && g === void 0 && (g = E), g !== void 0 && g === E && v === h && (m = fi(t, _.getPositionBefore(), l))
    }
    return te("rowspan", a, s, t), m
}

function pg(s, e) {
    const t = [], i = new $(s);
    for (const n of i) {
        const {column: o, cellWidth: r} = n, a = o + r - 1;
        o < e && e <= a && t.push(n)
    }
    return t
}

function wg(s, e, t, i) {
    const n = parseInt(s.getAttribute("colspan")), o = t - e, r = {}, a = n - o;
    a > 1 && (r.colspan = a);
    const l = parseInt(s.getAttribute("rowspan") || "1");
    l > 1 && (r.rowspan = l);
    const c = fi(i, i.createPositionAfter(s), r);
    return te("colspan", o, s, i), c
}

function bg(s, e, t, i, n, o) {
    const r = parseInt(s.getAttribute("colspan") || "1"), a = parseInt(s.getAttribute("rowspan") || "1");
    if (t + r - 1 > n) {
        const u = n - t + 1;
        te("colspan", u, s, o, 1)
    }
    if (e + a - 1 > i) {
        const u = i - e + 1;
        te("rowspan", u, s, o, 1)
    }
}

function f2(s, e, t, i, n) {
    const o = parseInt(e.getAttribute("headingRows") || "0");
    if (o > 0) {
        const a = o - t;
        te("headingRows", a, s, n, 0)
    }
    const r = parseInt(e.getAttribute("headingColumns") || "0");
    if (r > 0) {
        const a = r - i;
        te("headingColumns", a, s, n, 0)
    }
}

function Fr(s, e) {
    const t = e.getColumns(s), i = new Array(t).fill(0);
    for (const {column: o} of new $(s)) i[o]++;
    const n = i.reduce((o, r, a) => r ? o : [...o, a], []);
    if (n.length > 0) {
        const o = n[n.length - 1];
        return e.removeColumns(s, {at: o}), !0
    }
    return !1
}

function Lr(s, e) {
    const t = [], i = e.getRows(s);
    for (let n = 0; n < i; n++) s.getChild(n).isEmpty && t.push(n);
    if (t.length > 0) {
        const n = t[t.length - 1];
        return e.removeRows(s, {at: n}), !0
    }
    return !1
}

function Ba(s, e) {
    Fr(s, e) || Lr(s, e)
}

function _g(s, e) {
    const t = Array.from(new $(s, {startColumn: e.firstColumn, endColumn: e.lastColumn, row: e.lastRow}));
    if (t.every(({cellHeight: o}) => o === 1)) return e.lastRow;
    const n = t[0].cellHeight - 1;
    return e.lastRow + n
}

function vg(s, e) {
    const t = Array.from(new $(s, {startRow: e.firstRow, endRow: e.lastRow, column: e.lastColumn}));
    if (t.every(({cellWidth: o}) => o === 1)) return e.lastColumn;
    const n = t[0].cellWidth - 1;
    return e.lastColumn + n
}

class ps extends O {
    direction;
    isHorizontal;

    constructor(e, t) {
        super(e), this.direction = t.direction, this.isHorizontal = this.direction == "right" || this.direction == "left"
    }

    refresh() {
        const e = this._getMergeableCell();
        this.value = e, this.isEnabled = !!e
    }

    execute() {
        const e = this.editor.model, t = e.document,
            n = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(t.selection)[0], o = this.value,
            r = this.direction;
        e.change(a => {
            const l = r == "right" || r == "down", c = l ? n : o, u = l ? o : n, d = u.parent;
            p2(u, c, a);
            const h = this.isHorizontal ? "colspan" : "rowspan", f = parseInt(n.getAttribute(h) || "1"),
                m = parseInt(o.getAttribute(h) || "1");
            a.setAttribute(h, f + m, c), a.setSelection(a.createRangeIn(c));
            const g = this.editor.plugins.get("TableUtils"), _ = d.findAncestor("table");
            Ba(_, g)
        })
    }

    _getMergeableCell() {
        const t = this.editor.model.document, i = this.editor.plugins.get("TableUtils"),
            n = i.getTableCellsContainingSelection(t.selection)[0];
        if (!n) return;
        const o = this.isHorizontal ? m2(n, this.direction, i) : g2(n, this.direction, i);
        if (!o) return;
        const r = this.isHorizontal ? "rowspan" : "colspan", a = parseInt(n.getAttribute(r) || "1");
        if (parseInt(o.getAttribute(r) || "1") === a) return o
    }
}

function m2(s, e, t) {
    const n = s.parent.parent, o = e == "right" ? s.nextSibling : s.previousSibling,
        r = (n.getAttribute("headingColumns") || 0) > 0;
    if (!o) return;
    const a = e == "right" ? s : o,
        l = e == "right" ? o : s, {column: c} = t.getCellLocation(a), {column: u} = t.getCellLocation(l),
        d = parseInt(a.getAttribute("colspan") || "1"), h = Br(t, a), f = Br(t, l);
    return r && h != f ? void 0 : c + d === u ? o : void 0
}

function g2(s, e, t) {
    const i = s.parent, n = i.parent, o = n.getChildIndex(i);
    if (e == "down" && o === t.getRows(n) - 1 || e == "up" && o === 0) return null;
    const r = parseInt(s.getAttribute("rowspan") || "1"), a = n.getAttribute("headingRows") || 0,
        l = e == "down" && o + r === a, c = e == "up" && o === a;
    if (a && (l || c)) return null;
    const u = parseInt(s.getAttribute("rowspan") || "1"), d = e == "down" ? o + u : o, h = [...new $(n, {endRow: d})],
        m = h.find(_ => _.cell === s).column,
        g = h.find(({row: _, cellHeight: v, column: E}) => E !== m ? !1 : e == "down" ? _ === d : d === _ + v);
    return g && g.cell ? g.cell : null
}

function p2(s, e, t) {
    dd(s) || (dd(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(s), t.createPositionAt(e, "end"))), t.remove(s)
}

function dd(s) {
    const e = s.getChild(0);
    return s.childCount == 1 && e.is("element", "paragraph") && e.isEmpty
}

class w2 extends O {
    refresh() {
        const e = this.editor.plugins.get("TableUtils"),
            t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), i = t[0];
        if (i) {
            const n = i.findAncestor("table"), r = e.getRows(n) - 1, a = e.getRowIndexes(t),
                l = a.first === 0 && a.last === r;
            this.isEnabled = !l
        } else this.isEnabled = !1
    }

    execute() {
        const e = this.editor.model, t = this.editor.plugins.get("TableUtils"),
            i = t.getSelectionAffectedTableCells(e.document.selection), n = t.getRowIndexes(i), o = i[0],
            r = o.findAncestor("table"), a = t.getCellLocation(o).column;
        e.change(l => {
            const c = n.last - n.first + 1;
            t.removeRows(r, {at: n.first, rows: c});
            const u = b2(r, n.first, a, t.getRows(r));
            l.setSelection(l.createPositionAt(u, 0))
        })
    }
}

function b2(s, e, t, i) {
    const n = s.getChild(Math.min(e, i - 1));
    let o = n.getChild(0), r = 0;
    for (const a of n.getChildren()) {
        if (r > t) return o;
        o = a, r += parseInt(a.getAttribute("colspan") || "1")
    }
    return o
}

class _2 extends O {
    refresh() {
        const e = this.editor.plugins.get("TableUtils"),
            t = e.getSelectionAffectedTableCells(this.editor.model.document.selection), i = t[0];
        if (i) {
            const n = i.findAncestor("table"), o = e.getColumns(n), {first: r, last: a} = e.getColumnIndexes(t);
            this.isEnabled = a - r < o - 1
        } else this.isEnabled = !1
    }

    execute() {
        const e = this.editor.plugins.get("TableUtils"), [t, i] = y2(this.editor.model.document.selection, e),
            n = t.parent.parent, o = [...new $(n)],
            r = {first: o.find(l => l.cell === t).column, last: o.find(l => l.cell === i).column}, a = v2(o, t, i, r);
        this.editor.model.change(l => {
            const c = r.last - r.first + 1;
            e.removeColumns(n, {at: r.first, columns: c}), l.setSelection(l.createPositionAt(a, 0))
        })
    }
}

function v2(s, e, t, i) {
    return parseInt(t.getAttribute("colspan") || "1") > 1 ? t : e.previousSibling || t.nextSibling ? t.nextSibling || e.previousSibling : i.first ? s.reverse().find(({column: o}) => o < i.first).cell : s.reverse().find(({column: o}) => o > i.last).cell
}

function y2(s, e) {
    const t = e.getSelectionAffectedTableCells(s), i = t[0], n = t.pop(), o = [i, n];
    return i.isBefore(n) ? o : o.reverse()
}

class k2 extends O {
    refresh() {
        const e = this.editor.plugins.get("TableUtils"), t = this.editor.model,
            i = e.getSelectionAffectedTableCells(t.document.selection);
        if (i.length === 0) {
            this.isEnabled = !1, this.value = !1;
            return
        }
        const n = i[0].findAncestor("table");
        this.isEnabled = t.schema.checkAttribute(n, "headingRows"), this.value = i.every(o => this._isInHeading(o, o.parent.parent))
    }

    execute(e = {}) {
        if (e.forceValue === this.value) return;
        const t = this.editor.plugins.get("TableUtils"), i = this.editor.model,
            n = t.getSelectionAffectedTableCells(i.document.selection), o = n[0].findAncestor("table"), {
                first: r,
                last: a
            } = t.getRowIndexes(n), l = this.value ? r : a + 1, c = o.getAttribute("headingRows") || 0;
        i.change(u => {
            if (l) {
                const d = l > c ? c : 0, h = mg(o, l, d);
                for (const {cell: f} of h) gg(f, l, u)
            }
            te("headingRows", l, o, u, 0)
        })
    }

    _isInHeading(e, t) {
        const i = parseInt(t.getAttribute("headingRows") || "0");
        return !!i && e.parent.index < i
    }
}

class C2 extends O {
    refresh() {
        const e = this.editor.plugins.get("TableUtils"), t = this.editor.model,
            i = e.getSelectionAffectedTableCells(t.document.selection);
        if (i.length === 0) {
            this.isEnabled = !1, this.value = !1;
            return
        }
        const n = i[0].findAncestor("table");
        this.isEnabled = t.schema.checkAttribute(n, "headingColumns"), this.value = i.every(o => Br(e, o))
    }

    execute(e = {}) {
        if (e.forceValue === this.value) return;
        const t = this.editor.plugins.get("TableUtils"), i = this.editor.model,
            n = t.getSelectionAffectedTableCells(i.document.selection), o = n[0].findAncestor("table"), {
                first: r,
                last: a
            } = t.getColumnIndexes(n), l = this.value ? r : a + 1;
        i.change(c => {
            if (l) {
                const u = pg(o, l);
                for (const {cell: d, column: h} of u) wg(d, h, l, c)
            }
            te("headingColumns", l, o, c, 0)
        })
    }
}

function E2(s) {
    if (s.is("element", "tableColumnGroup")) return s;
    const e = s.getChildren();
    return Array.from(e).find(t => t.is("element", "tableColumnGroup"))
}

function T2(s) {
    const e = E2(s);
    return e ? Array.from(e.getChildren()) : []
}

class fe extends w {
    static get pluginName() {
        return "TableUtils"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        this.decorate("insertColumns"), this.decorate("insertRows")
    }

    getCellLocation(e) {
        const t = e.parent, i = t.parent, n = i.getChildIndex(t), o = new $(i, {row: n});
        for (const {cell: r, row: a, column: l} of o) if (r === e) return {row: a, column: l};/* istanbul ignore next -- @preserve */
    }

    createTable(e, t) {
        const i = e.createElement("table"), n = t.rows || 2, o = t.columns || 2;
        return ir(e, i, 0, n, o), t.headingRows && te("headingRows", Math.min(t.headingRows, n), i, e, 0), t.headingColumns && te("headingColumns", Math.min(t.headingColumns, o), i, e, 0), i
    }

    insertRows(e, t = {}) {
        const i = this.editor.model, n = t.at || 0, o = t.rows || 1, r = t.copyStructureFromAbove !== void 0,
            a = t.copyStructureFromAbove ? n - 1 : n, l = this.getRows(e), c = this.getColumns(e);
        if (n > l) throw new p("tableutils-insertrows-insert-out-of-range", this, {options: t});
        i.change(u => {
            const d = e.getAttribute("headingRows") || 0;
            if (d > n && te("headingRows", d + o, e, u, 0), !r && (n === 0 || n === l)) {
                ir(u, e, n, o, c);
                return
            }
            const h = r ? Math.max(n, a) : n, f = new $(e, {endRow: h}), m = new Array(c).fill(1);
            for (const {row: g, column: _, cellHeight: v, cellWidth: E, cell: V} of f) {
                const N = g + v - 1, Z = g < n && n <= N, A = g <= a && a <= N;
                Z ? (u.setAttribute("rowspan", v + o, V), m[_] = -E) : r && A && (m[_] = E)
            }
            for (let g = 0; g < o; g++) {
                const _ = u.createElement("tableRow");
                u.insert(_, e, n);
                for (let v = 0; v < m.length; v++) {
                    const E = m[v], V = u.createPositionAt(_, "end");
                    E > 0 && fi(u, V, E > 1 ? {colspan: E} : void 0), v += Math.abs(E) - 1
                }
            }
        })
    }

    insertColumns(e, t = {}) {
        const i = this.editor.model, n = t.at || 0, o = t.columns || 1;
        i.change(r => {
            const a = e.getAttribute("headingColumns");
            n < a && r.setAttribute("headingColumns", a + o, e);
            const l = this.getColumns(e);
            if (n === 0 || l === n) {
                for (const u of e.getChildren()) u.is("element", "tableRow") && Pi(o, r, r.createPositionAt(u, n ? "end" : 0));
                return
            }
            const c = new $(e, {column: n, includeAllSlots: !0});
            for (const u of c) {
                const {row: d, cell: h, cellAnchorColumn: f, cellAnchorRow: m, cellWidth: g, cellHeight: _} = u;
                if (f < n) {
                    r.setAttribute("colspan", g + o, h);
                    const v = m + _ - 1;
                    for (let E = d; E <= v; E++) c.skipRow(E)
                } else Pi(o, r, u.getPositionBefore())
            }
        })
    }

    removeRows(e, t) {
        const i = this.editor.model, n = t.rows || 1, o = this.getRows(e), r = t.at, a = r + n - 1;
        if (a > o - 1) throw new p("tableutils-removerows-row-index-out-of-range", this, {table: e, options: t});
        i.change(l => {
            const c = {first: r, last: a}, {cellsToMove: u, cellsToTrim: d} = I2(e, c);
            if (u.size) {
                const h = a + 1;
                S2(e, h, u, l)
            }
            for (let h = a; h >= r; h--) l.remove(e.getChild(h));
            for (const {rowspan: h, cell: f} of d) te("rowspan", h, f, l);
            x2(e, c, l), Fr(e, this) || Lr(e, this)
        })
    }

    removeColumns(e, t) {
        const i = this.editor.model, n = t.at, o = t.columns || 1, r = t.at + o - 1;
        i.change(a => {
            A2(e, {first: n, last: r}, a);
            const l = T2(e);
            for (let c = r; c >= n; c--) {
                for (const {
                    cell: u,
                    column: d,
                    cellWidth: h
                } of [...new $(e)]) d <= c && h > 1 && d + h > c ? te("colspan", h - 1, u, a) : d === c && a.remove(u);
                if (l[c]) {
                    const u = c === 0 ? l[1] : l[c - 1], d = parseFloat(l[c].getAttribute("columnWidth")),
                        h = parseFloat(u.getAttribute("columnWidth"));
                    a.remove(l[c]), a.setAttribute("columnWidth", d + h + "%", u)
                }
            }
            Lr(e, this) || Fr(e, this)
        })
    }

    splitCellVertically(e, t = 2) {
        const i = this.editor.model, o = e.parent.parent, r = parseInt(e.getAttribute("rowspan") || "1"),
            a = parseInt(e.getAttribute("colspan") || "1");
        i.change(l => {
            if (a > 1) {
                const {newCellsSpan: c, updatedSpan: u} = hd(a, t);
                te("colspan", u, e, l);
                const d = {};
                c > 1 && (d.colspan = c), r > 1 && (d.rowspan = r);
                const h = a > t ? t - 1 : a - 1;
                Pi(h, l, l.createPositionAfter(e), d)
            }
            if (a < t) {
                const c = t - a, u = [...new $(o)], {column: d} = u.find(({cell: g}) => g === e),
                    h = u.filter(({cell: g, cellWidth: _, column: v}) => {
                        const E = g !== e && v === d, V = v < d && v + _ > d;
                        return E || V
                    });
                for (const {cell: g, cellWidth: _} of h) l.setAttribute("colspan", _ + c, g);
                const f = {};
                r > 1 && (f.rowspan = r), Pi(c, l, l.createPositionAfter(e), f);
                const m = o.getAttribute("headingColumns") || 0;
                m > d && te("headingColumns", m + c, o, l)
            }
        })
    }

    splitCellHorizontally(e, t = 2) {
        const i = this.editor.model, n = e.parent, o = n.parent, r = o.getChildIndex(n),
            a = parseInt(e.getAttribute("rowspan") || "1"), l = parseInt(e.getAttribute("colspan") || "1");
        i.change(c => {
            if (a > 1) {
                const u = [...new $(o, {startRow: r, endRow: r + a - 1, includeAllSlots: !0})], {
                    newCellsSpan: d,
                    updatedSpan: h
                } = hd(a, t);
                te("rowspan", h, e, c);
                const {column: f} = u.find(({cell: _}) => _ === e), m = {};
                d > 1 && (m.rowspan = d), l > 1 && (m.colspan = l);
                let g = 0;
                for (const _ of u) {
                    const {column: v, row: E} = _, V = E >= r + h, N = v === f;
                    g >= d && N && (g = 0), V && N && (g || Pi(1, c, _.getPositionBefore(), m), g++)
                }
            }
            if (a < t) {
                const u = t - a, d = [...new $(o, {startRow: 0, endRow: r})];
                for (const {cell: m, cellHeight: g, row: _} of d) if (m !== e && _ + g > r) {
                    const v = g + u;
                    c.setAttribute("rowspan", v, m)
                }
                const h = {};
                l > 1 && (h.colspan = l), ir(c, o, r + 1, u, 1, h);
                const f = o.getAttribute("headingRows") || 0;
                f > r && te("headingRows", f + u, o, c)
            }
        })
    }

    getColumns(e) {
        return [...e.getChild(0).getChildren()].filter(i => i.is("element", "tableCell")).reduce((i, n) => {
            const o = parseInt(n.getAttribute("colspan") || "1");
            return i + o
        }, 0)
    }

    getRows(e) {
        return Array.from(e.getChildren()).reduce((t, i) => i.is("element", "tableRow") ? t + 1 : t, 0)
    }

    createTableWalker(e, t = {}) {
        return new $(e, t)
    }

    getSelectedTableCells(e) {
        const t = [];
        for (const i of this.sortRanges(e.getRanges())) {
            const n = i.getContainedElement();
            n && n.is("element", "tableCell") && t.push(n)
        }
        return t
    }

    getTableCellsContainingSelection(e) {
        const t = [];
        for (const i of e.getRanges()) {
            const n = i.start.findAncestor("tableCell");
            n && t.push(n)
        }
        return t
    }

    getSelectionAffectedTableCells(e) {
        const t = this.getSelectedTableCells(e);
        return t.length ? t : this.getTableCellsContainingSelection(e)
    }

    getRowIndexes(e) {
        const t = e.map(i => i.parent.index);
        return this._getFirstLastIndexesObject(t)
    }

    getColumnIndexes(e) {
        const t = e[0].findAncestor("table"), n = [...new $(t)].filter(o => e.includes(o.cell)).map(o => o.column);
        return this._getFirstLastIndexesObject(n)
    }

    isSelectionRectangular(e) {
        if (e.length < 2 || !this._areCellInTheSameTableSection(e)) return !1;
        const t = new Set, i = new Set;
        let n = 0;
        for (const r of e) {
            const {row: a, column: l} = this.getCellLocation(r), c = parseInt(r.getAttribute("rowspan")) || 1,
                u = parseInt(r.getAttribute("colspan")) || 1;
            t.add(a), i.add(l), c > 1 && t.add(a + c - 1), u > 1 && i.add(l + u - 1), n += c * u
        }
        return R2(t, i) == n
    }

    sortRanges(e) {
        return Array.from(e).sort(P2)
    }

    _getFirstLastIndexesObject(e) {
        const t = e.sort((o, r) => o - r), i = t[0], n = t[t.length - 1];
        return {first: i, last: n}
    }

    _areCellInTheSameTableSection(e) {
        const t = e[0].findAncestor("table"), i = this.getRowIndexes(e),
            n = parseInt(t.getAttribute("headingRows")) || 0;
        if (!this._areIndexesInSameSection(i, n)) return !1;
        const o = this.getColumnIndexes(e), r = parseInt(t.getAttribute("headingColumns")) || 0;
        return this._areIndexesInSameSection(o, r)
    }

    _areIndexesInSameSection({first: e, last: t}, i) {
        const n = e < i, o = t < i;
        return n === o
    }
}

function ir(s, e, t, i, n, o = {}) {
    for (let r = 0; r < i; r++) {
        const a = s.createElement("tableRow");
        s.insert(a, e, t), Pi(n, s, s.createPositionAt(a, "end"), o)
    }
}

function Pi(s, e, t, i = {}) {
    for (let n = 0; n < s; n++) fi(e, t, i)
}

function hd(s, e) {
    if (s < e) return {newCellsSpan: 1, updatedSpan: 1};
    const t = Math.floor(s / e), i = s - t * e + t;
    return {newCellsSpan: t, updatedSpan: i}
}

function A2(s, e, t) {
    const i = s.getAttribute("headingColumns") || 0;
    if (i && e.first < i) {
        const n = Math.min(i - 1, e.last) - e.first + 1;
        t.setAttribute("headingColumns", i - n, s)
    }
}

function x2(s, {first: e, last: t}, i) {
    const n = s.getAttribute("headingRows") || 0;
    if (e < n) {
        const o = t < n ? n - (t - e + 1) : e;
        te("headingRows", o, s, i, 0)
    }
}

function I2(s, {first: e, last: t}) {
    const i = new Map, n = [];
    for (const {row: o, column: r, cellHeight: a, cell: l} of new $(s, {endRow: t})) {
        const c = o + a - 1;
        if (o >= e && o <= t && c > t) {
            const h = t - o + 1, f = a - h;
            i.set(r, {cell: l, rowspan: f})
        }
        if (o < e && c >= e) {
            let h;
            c >= t ? h = t - e + 1 : h = c - e + 1, n.push({cell: l, rowspan: a - h})
        }
    }
    return {cellsToMove: i, cellsToTrim: n}
}

function S2(s, e, t, i) {
    const o = [...new $(s, {includeAllSlots: !0, row: e})], r = s.getChild(e);
    let a;
    for (const {column: l, cell: c, isAnchor: u} of o) if (t.has(l)) {
        const {cell: d, rowspan: h} = t.get(l), f = a ? i.createPositionAfter(a) : i.createPositionAt(r, 0);
        i.move(i.createRangeOn(d), f), te("rowspan", h, d, i), a = d
    } else u && (a = c)
}

function P2(s, e) {
    const t = s.start, i = e.start;
    return t.isBefore(i) ? -1 : 1
}

function R2(s, e) {
    const t = Array.from(s.values()), i = Array.from(e.values()), n = Math.max(...t), o = Math.min(...t),
        r = Math.max(...i), a = Math.min(...i);
    return (n - o + 1) * (r - a + 1)
}

class V2 extends O {
    refresh() {
        const e = this.editor.plugins.get(fe), t = e.getSelectedTableCells(this.editor.model.document.selection);
        this.isEnabled = e.isSelectionRectangular(t)
    }

    execute() {
        const e = this.editor.model, t = this.editor.plugins.get(fe);
        e.change(i => {
            const n = t.getSelectedTableCells(e.document.selection), o = n.shift(), {
                mergeWidth: r,
                mergeHeight: a
            } = M2(o, n, t);
            te("colspan", r, o, i), te("rowspan", a, o, i);
            for (const c of n) O2(c, o, i);
            const l = o.findAncestor("table");
            Ba(l, t), i.setSelection(o, "in")
        })
    }
}

function O2(s, e, t) {
    fd(s) || (fd(e) && t.remove(t.createRangeIn(e)), t.move(t.createRangeIn(s), t.createPositionAt(e, "end"))), t.remove(s)
}

function fd(s) {
    const e = s.getChild(0);
    return s.childCount == 1 && e.is("element", "paragraph") && e.isEmpty
}

function M2(s, e, t) {
    let i = 0, n = 0;
    for (const c of e) {
        const {row: u, column: d} = t.getCellLocation(c);
        i = md(c, d, i, "colspan"), n = md(c, u, n, "rowspan")
    }
    const {row: o, column: r} = t.getCellLocation(s), a = i - r, l = n - o;
    return {mergeWidth: a, mergeHeight: l}
}

function md(s, e, t, i) {
    const n = parseInt(s.getAttribute(i) || "1");
    return Math.max(t, e + n)
}

class B2 extends O {
    constructor(e) {
        super(e), this.affectsData = !1
    }

    refresh() {
        const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
        this.isEnabled = t.length > 0
    }

    execute() {
        const e = this.editor.model, t = this.editor.plugins.get("TableUtils"),
            i = t.getSelectionAffectedTableCells(e.document.selection), n = t.getRowIndexes(i),
            o = i[0].findAncestor("table"), r = [];
        for (let a = n.first; a <= n.last; a++) for (const l of o.getChild(a).getChildren()) r.push(e.createRangeOn(l));
        e.change(a => {
            a.setSelection(r)
        })
    }
}

class F2 extends O {
    constructor(e) {
        super(e), this.affectsData = !1
    }

    refresh() {
        const t = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
        this.isEnabled = t.length > 0
    }

    execute() {
        const e = this.editor.plugins.get("TableUtils"), t = this.editor.model,
            i = e.getSelectionAffectedTableCells(t.document.selection), n = i[0], o = i.pop(),
            r = n.findAncestor("table"), a = e.getCellLocation(n), l = e.getCellLocation(o),
            c = Math.min(a.column, l.column), u = Math.max(a.column, l.column), d = [];
        for (const h of new $(r, {startColumn: c, endColumn: u})) d.push(t.createRangeOn(h.cell));
        t.change(h => {
            h.setSelection(d)
        })
    }
}

function L2(s) {
    s.document.registerPostFixer(e => D2(e, s))
}

function D2(s, e) {
    const t = e.document.differ.getChanges();
    let i = !1;
    const n = new Set;
    for (const o of t) {
        let r = null;
        o.type == "insert" && o.name == "table" && (r = o.position.nodeAfter), (o.type == "insert" || o.type == "remove") && (o.name == "tableRow" || o.name == "tableCell") && (r = o.position.findAncestor("table")), $2(o) && (r = o.range.start.findAncestor("table")), r && !n.has(r) && (i = N2(r, s) || i, i = z2(r, s) || i, n.add(r))
    }
    return i
}

function N2(s, e) {
    let t = !1;
    const i = H2(s);
    if (i.length) {
        t = !0;
        for (const n of i) te("rowspan", n.rowspan, n.cell, e, 1)
    }
    return t
}

function z2(s, e) {
    let t = !1;
    const i = U2(s), n = [];
    for (const [l, c] of i.entries()) !c && s.getChild(l).is("element", "tableRow") && n.push(l);
    if (n.length) {
        t = !0;
        for (const l of n.reverse()) e.remove(s.getChild(l)), i.splice(l, 1)
    }
    const o = i.filter((l, c) => s.getChild(c).is("element", "tableRow")), r = o[0];
    if (!o.every(l => l === r)) {
        const l = o.reduce((c, u) => u > c ? u : c, 0);
        for (const [c, u] of o.entries()) {
            const d = l - u;
            if (d) {
                for (let h = 0; h < d; h++) fi(e, e.createPositionAt(s.getChild(c), "end"));
                t = !0
            }
        }
    }
    return t
}

function H2(s) {
    const e = parseInt(s.getAttribute("headingRows") || "0"),
        t = Array.from(s.getChildren()).reduce((n, o) => o.is("element", "tableRow") ? n + 1 : n, 0), i = [];
    for (const {row: n, cell: o, cellHeight: r} of new $(s)) {
        if (r < 2) continue;
        const l = n < e ? e : t;
        if (n + r > l) {
            const c = l - n;
            i.push({cell: o, rowspan: c})
        }
    }
    return i
}

function U2(s) {
    const e = new Array(s.childCount).fill(0);
    for (const {rowIndex: t} of new $(s, {includeAllSlots: !0})) e[t]++;
    return e
}

function $2(s) {
    if (s.type !== "attribute") return !1;
    const e = s.attributeKey;
    return e === "headingRows" || e === "colspan" || e === "rowspan"
}

/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function W2(s) {
    s.document.registerPostFixer(e => q2(e, s))
}

function q2(s, e) {
    const t = e.document.differ.getChanges();
    let i = !1;
    for (const n of t) n.type == "insert" && n.name == "table" && (i = j2(n.position.nodeAfter, s) || i), n.type == "insert" && n.name == "tableRow" && (i = yg(n.position.nodeAfter, s) || i), n.type == "insert" && n.name == "tableCell" && (i = Dr(n.position.nodeAfter, s) || i), (n.type == "remove" || n.type == "insert") && G2(n) && (i = Dr(n.position.parent, s) || i);
    return i
}

function j2(s, e) {
    let t = !1;
    for (const i of s.getChildren()) i.is("element", "tableRow") && (t = yg(i, e) || t);
    return t
}

function yg(s, e) {
    let t = !1;
    for (const i of s.getChildren()) t = Dr(i, e) || t;
    return t
}

function Dr(s, e) {
    if (s.childCount == 0) return e.insertElement("paragraph", s), !0;
    const t = Array.from(s.getChildren()).filter(i => i.is("$text"));
    for (const i of t) e.wrap(e.createRangeOn(i), "paragraph");
    return !!t.length
}

function G2(s) {
    return s.position.parent.is("element", "tableCell") ? s.type == "insert" && s.name == "$text" || s.type == "remove" : !1
}

function K2(s, e) {
    const t = s.document.differ;
    for (const i of t.getChanges()) {
        let n, o = !1;
        if (i.type == "attribute") {
            const c = i.range.start.nodeAfter;
            if (!c || !c.is("element", "table") || i.attributeKey != "headingRows" && i.attributeKey != "headingColumns") continue;
            n = c, o = i.attributeKey == "headingRows"
        } else (i.name == "tableRow" || i.name == "tableCell") && (n = i.position.findAncestor("table"), o = i.name == "tableRow");
        if (!n) continue;
        const r = n.getAttribute("headingRows") || 0, a = n.getAttribute("headingColumns") || 0, l = new $(n);
        for (const c of l) {
            const d = c.row < r || c.column < a ? "th" : "td", h = e.mapper.toViewElement(c.cell);
            h && h.is("element") && h.name != d && e.reconvertItem(o ? c.cell.parent : c.cell)
        }
    }
}

function Z2(s, e) {
    const t = s.document.differ, i = new Set;
    for (const n of t.getChanges()) {
        const o = n.type == "attribute" ? n.range.start.parent : n.position.parent;
        o.is("element", "tableCell") && i.add(o)
    }
    for (const n of i.values()) {
        const o = Array.from(n.getChildren()).filter(r => J2(r, e.mapper));
        for (const r of o) e.reconvertItem(r)
    }
}

function J2(s, e) {
    if (!s.is("element", "paragraph")) return !1;
    const t = e.toViewElement(s);
    return t ? hg(s) !== t.is("element", "span") : !1
}

class Q2 extends w {
    _additionalSlots;

    static get pluginName() {
        return "TableEditing"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [fe]
    }

    constructor(e) {
        super(e), this._additionalSlots = []
    }

    init() {
        const e = this.editor, t = e.model, i = t.schema, n = e.conversion, o = e.plugins.get(fe);
        i.register("table", {
            inheritAllFrom: "$blockObject",
            allowAttributes: ["headingRows", "headingColumns"]
        }), i.register("tableRow", {
            allowIn: "table",
            isLimit: !0
        }), i.register("tableCell", {
            allowContentOf: "$container",
            allowIn: "tableRow",
            allowAttributes: ["colspan", "rowspan"],
            isLimit: !0,
            isSelectable: !0
        }), n.for("upcast").add(t2()), n.for("upcast").add(i2()), n.for("editingDowncast").elementToStructure({
            model: {
                name: "table",
                attributes: ["headingRows"]
            }, view: od(o, {asWidget: !0, additionalSlots: this._additionalSlots})
        }), n.for("dataDowncast").elementToStructure({
            model: {name: "table", attributes: ["headingRows"]},
            view: od(o, {additionalSlots: this._additionalSlots})
        }), n.for("upcast").elementToElement({
            model: "tableRow",
            view: "tr"
        }), n.for("upcast").add(n2()), n.for("downcast").elementToElement({
            model: "tableRow",
            view: l2()
        }), n.for("upcast").elementToElement({
            model: "tableCell",
            view: "td"
        }), n.for("upcast").elementToElement({
            model: "tableCell",
            view: "th"
        }), n.for("upcast").add(sd("td")), n.for("upcast").add(sd("th")), n.for("editingDowncast").elementToElement({
            model: "tableCell",
            view: rd({asWidget: !0})
        }), n.for("dataDowncast").elementToElement({
            model: "tableCell",
            view: rd()
        }), n.for("editingDowncast").elementToElement({
            model: "paragraph",
            view: ad({asWidget: !0}),
            converterPriority: "high"
        }), n.for("dataDowncast").elementToElement({
            model: "paragraph",
            view: ad(),
            converterPriority: "high"
        }), n.for("downcast").attributeToAttribute({
            model: "colspan",
            view: "colspan"
        }), n.for("upcast").attributeToAttribute({
            model: {key: "colspan", value: gd("colspan")},
            view: "colspan"
        }), n.for("downcast").attributeToAttribute({
            model: "rowspan",
            view: "rowspan"
        }), n.for("upcast").attributeToAttribute({
            model: {key: "rowspan", value: gd("rowspan")},
            view: "rowspan"
        }), e.config.define("table.defaultHeadings.rows", 0), e.config.define("table.defaultHeadings.columns", 0), e.commands.add("insertTable", new d2(e)), e.commands.add("insertTableRowAbove", new ld(e, {order: "above"})), e.commands.add("insertTableRowBelow", new ld(e, {order: "below"})), e.commands.add("insertTableColumnLeft", new cd(e, {order: "left"})), e.commands.add("insertTableColumnRight", new cd(e, {order: "right"})), e.commands.add("removeTableRow", new w2(e)), e.commands.add("removeTableColumn", new _2(e)), e.commands.add("splitTableCellVertically", new ud(e, {direction: "vertically"})), e.commands.add("splitTableCellHorizontally", new ud(e, {direction: "horizontally"})), e.commands.add("mergeTableCells", new V2(e)), e.commands.add("mergeTableCellRight", new ps(e, {direction: "right"})), e.commands.add("mergeTableCellLeft", new ps(e, {direction: "left"})), e.commands.add("mergeTableCellDown", new ps(e, {direction: "down"})), e.commands.add("mergeTableCellUp", new ps(e, {direction: "up"})), e.commands.add("setTableColumnHeader", new C2(e)), e.commands.add("setTableRowHeader", new k2(e)), e.commands.add("selectTableRow", new B2(e)), e.commands.add("selectTableColumn", new F2(e)), L2(t), W2(t), this.listenTo(t.document, "change:data", () => {
            K2(t, e.editing), Z2(t, e.editing)
        })
    }

    registerAdditionalSlot(e) {
        this._additionalSlots.push(e)
    }
}

function gd(s) {
    return e => {
        const t = parseInt(e.getAttribute(s));
        return Number.isNaN(t) || t <= 0 ? null : t
    }
}

class pd extends T {
    items;
    keystrokes;
    focusTracker;

    constructor(e) {
        super(e);
        const t = this.bindTemplate;
        this.items = this._createGridCollection(), this.keystrokes = new ue, this.focusTracker = new se, this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (i, n) => `${n} × ${i}`), this.setTemplate({
            tag: "div",
            attributes: {class: ["ck"]},
            children: [{
                tag: "div",
                attributes: {class: ["ck-insert-table-dropdown__grid"]},
                on: {"mouseover@.ck-insert-table-dropdown-grid-box": t.to("boxover")},
                children: this.items
            }, {
                tag: "div",
                attributes: {class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": !0},
                children: [{text: t.to("label")}]
            }],
            on: {
                mousedown: t.to(i => {
                    i.preventDefault()
                }), click: t.to(() => {
                    this.fire("execute")
                })
            }
        }), this.on("boxover", (i, n) => {
            const {row: o, column: r} = n.target.dataset;
            this.items.get((parseInt(o, 10) - 1) * 10 + (parseInt(r, 10) - 1)).focus()
        }), this.focusTracker.on("change:focusedElement", (i, n, o) => {
            if (!o) return;
            const {row: r, column: a} = o.dataset;
            this.set({rows: parseInt(r), columns: parseInt(a)})
        }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes())
    }

    render() {
        super.render(), Of({
            keystrokeHandler: this.keystrokes,
            focusTracker: this.focusTracker,
            gridItems: this.items,
            numberOfColumns: 10,
            uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
        });
        for (const e of this.items) this.focusTracker.add(e.element);
        this.keystrokes.listenTo(this.element)
    }

    reset() {
        this.set({rows: 1, columns: 1})
    }

    focus() {
        this.items.get(0).focus()
    }

    focusLast() {
        this.items.get(0).focus()
    }

    _highlightGridBoxes() {
        const e = this.rows, t = this.columns;
        this.items.map((i, n) => {
            const o = Math.floor(n / 10), r = n % 10, a = o < e && r < t;
            i.set("isOn", a)
        })
    }

    _createGridButton(e, t, i, n) {
        const o = new I(e);
        return o.set({
            label: n,
            class: "ck-insert-table-dropdown-grid-box"
        }), o.extendTemplate({attributes: {"data-row": t, "data-column": i}}), o
    }

    _createGridCollection() {
        const e = [];
        for (let t = 0; t < 100; t++) {
            const i = Math.floor(t / 10), n = t % 10, o = `${i + 1} × ${n + 1}`;
            e.push(this._createGridButton(this.locale, i + 1, n + 1, o))
        }
        return this.createCollection(e)
    }
}

class Y2 extends w {
    static get pluginName() {
        return "TableUI"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        const e = this.editor, t = this.editor.t, n = e.locale.contentLanguageDirection === "ltr";
        e.ui.componentFactory.add("insertTable", o => {
            const r = e.commands.get("insertTable"), a = Ae(o);
            a.bind("isEnabled").to(r), a.buttonView.set({icon: oc, label: t("Insert table"), tooltip: !0});
            let l;
            return a.on("change:isOpen", () => {
                l || (l = new pd(o), a.panelView.children.add(l), l.delegate("execute").to(a), a.on("execute", () => {
                    e.execute("insertTable", {rows: l.rows, columns: l.columns}), e.editing.view.focus()
                }))
            }), a
        }), e.ui.componentFactory.add("menuBar:insertTable", o => {
            const r = e.commands.get("insertTable"), a = new Ne(o), l = new pd(o);
            return l.delegate("execute").to(a), a.on("change:isOpen", (c, u, d) => {
                d || l.reset()
            }), l.on("execute", () => {
                e.execute("insertTable", {rows: l.rows, columns: l.columns}), e.editing.view.focus()
            }), a.buttonView.set({
                label: t("Table"),
                icon: oc
            }), a.panelView.children.add(l), a.bind("isEnabled").to(r), a
        }), e.ui.componentFactory.add("tableColumn", o => {
            const r = [{
                type: "switchbutton",
                model: {commandName: "setTableColumnHeader", label: t("Header column"), bindIsOn: !0}
            }, {type: "separator"}, {
                type: "button",
                model: {
                    commandName: n ? "insertTableColumnLeft" : "insertTableColumnRight",
                    label: t("Insert column left")
                }
            }, {
                type: "button",
                model: {
                    commandName: n ? "insertTableColumnRight" : "insertTableColumnLeft",
                    label: t("Insert column right")
                }
            }, {type: "button", model: {commandName: "removeTableColumn", label: t("Delete column")}}, {
                type: "button",
                model: {commandName: "selectTableColumn", label: t("Select column")}
            }];
            return this._prepareDropdown(t("Column"), P1, r, o)
        }), e.ui.componentFactory.add("tableRow", o => {
            const r = [{
                type: "switchbutton",
                model: {commandName: "setTableRowHeader", label: t("Header row"), bindIsOn: !0}
            }, {type: "separator"}, {
                type: "button",
                model: {commandName: "insertTableRowAbove", label: t("Insert row above")}
            }, {
                type: "button",
                model: {commandName: "insertTableRowBelow", label: t("Insert row below")}
            }, {type: "button", model: {commandName: "removeTableRow", label: t("Delete row")}}, {
                type: "button",
                model: {commandName: "selectTableRow", label: t("Select row")}
            }];
            return this._prepareDropdown(t("Row"), V1, r, o)
        }), e.ui.componentFactory.add("mergeTableCells", o => {
            const r = [{
                type: "button",
                model: {commandName: "mergeTableCellUp", label: t("Merge cell up")}
            }, {
                type: "button",
                model: {commandName: n ? "mergeTableCellRight" : "mergeTableCellLeft", label: t("Merge cell right")}
            }, {
                type: "button",
                model: {commandName: "mergeTableCellDown", label: t("Merge cell down")}
            }, {
                type: "button",
                model: {commandName: n ? "mergeTableCellLeft" : "mergeTableCellRight", label: t("Merge cell left")}
            }, {type: "separator"}, {
                type: "button",
                model: {commandName: "splitTableCellVertically", label: t("Split cell vertically")}
            }, {
                type: "button",
                model: {commandName: "splitTableCellHorizontally", label: t("Split cell horizontally")}
            }];
            return this._prepareMergeSplitButtonDropdown(t("Merge cells"), R1, r, o)
        })
    }

    _prepareDropdown(e, t, i, n) {
        const o = this.editor, r = Ae(n), a = this._fillDropdownWithListOptions(r, i);
        return r.buttonView.set({
            label: e,
            icon: t,
            tooltip: !0
        }), r.bind("isEnabled").toMany(a, "isEnabled", (...l) => l.some(c => c)), this.listenTo(r, "execute", l => {
            o.execute(l.source.commandName), l.source instanceof Wi || o.editing.view.focus()
        }), r
    }

    _prepareMergeSplitButtonDropdown(e, t, i, n) {
        const o = this.editor, r = Ae(n, Wn), a = "mergeTableCells", l = o.commands.get(a),
            c = this._fillDropdownWithListOptions(r, i);
        return r.buttonView.set({
            label: e,
            icon: t,
            tooltip: !0,
            isEnabled: !0
        }), r.bind("isEnabled").toMany([l, ...c], "isEnabled", (...u) => u.some(d => d)), this.listenTo(r.buttonView, "execute", () => {
            o.execute(a), o.editing.view.focus()
        }), this.listenTo(r, "execute", u => {
            o.execute(u.source.commandName), o.editing.view.focus()
        }), r
    }

    _fillDropdownWithListOptions(e, t) {
        const i = this.editor, n = [], o = new ce;
        for (const r of t) X2(r, i, n, o);
        return jn(e, o), n
    }
}

function X2(s, e, t, i) {
    if (s.type === "button" || s.type === "switchbutton") {
        const n = s.model = new qi(s.model), {commandName: o, bindIsOn: r} = s.model, a = e.commands.get(o);
        t.push(a), n.set({commandName: o}), n.bind("isEnabled").to(a), r && n.bind("isOn").to(a, "value"), n.set({withText: !0})
    }
    i.add(s)
}

class Dt extends w {
    static get pluginName() {
        return "TableSelection"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [fe, fe]
    }

    init() {
        const e = this.editor, t = e.model, i = e.editing.view;
        this.listenTo(t, "deleteContent", (n, o) => this._handleDeleteContent(n, o), {priority: "high"}), this.listenTo(i.document, "insertText", (n, o) => this._handleInsertTextEvent(n, o), {priority: "high"}), this._defineSelectionConverter(), this._enablePluginDisabling()
    }

    getSelectedTableCells() {
        const e = this.editor.plugins.get(fe), t = this.editor.model.document.selection, i = e.getSelectedTableCells(t);
        return i.length == 0 ? null : i
    }

    getSelectionAsFragment() {
        const e = this.editor.plugins.get(fe), t = this.getSelectedTableCells();
        return t ? this.editor.model.change(i => {
            const n = i.createDocumentFragment(), {first: o, last: r} = e.getColumnIndexes(t), {
                first: a,
                last: l
            } = e.getRowIndexes(t), c = t[0].findAncestor("table");
            let u = l, d = r;
            if (e.isSelectionRectangular(t)) {
                const m = {firstColumn: o, lastColumn: r, firstRow: a, lastRow: l};
                u = _g(c, m), d = vg(c, m)
            }
            const f = fg(c, {startRow: a, startColumn: o, endRow: u, endColumn: d}, i);
            return i.insert(f, n, 0), n
        }) : null
    }

    setCellSelection(e, t) {
        const i = this._getCellsToSelect(e, t);
        this.editor.model.change(n => {
            n.setSelection(i.cells.map(o => n.createRangeOn(o)), {backward: i.backward})
        })
    }

    getFocusCell() {
        const i = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
        return i && i.is("element", "tableCell") ? i : null
    }

    getAnchorCell() {
        const e = this.editor.model.document.selection, i = re(e.getRanges()).getContainedElement();
        return i && i.is("element", "tableCell") ? i : null
    }

    _defineSelectionConverter() {
        const e = this.editor, t = new Set;
        e.conversion.for("editingDowncast").add(n => n.on("selection", (o, r, a) => {
            const l = a.writer;
            i(l);
            const c = this.getSelectedTableCells();
            if (!c) return;
            for (const d of c) {
                const h = a.mapper.toViewElement(d);
                l.addClass("ck-editor__editable_selected", h), t.add(h)
            }
            const u = a.mapper.toViewElement(c[c.length - 1]);
            l.setSelection(u, 0)
        }, {priority: "lowest"}));

        function i(n) {
            for (const o of t) n.removeClass("ck-editor__editable_selected", o);
            t.clear()
        }
    }

    _enablePluginDisabling() {
        const e = this.editor;
        this.on("change:isEnabled", () => {
            if (!this.isEnabled) {
                const t = this.getSelectedTableCells();
                if (!t) return;
                e.model.change(i => {
                    const n = i.createPositionAt(t[0], 0), o = e.model.schema.getNearestSelectionRange(n);
                    i.setSelection(o)
                })
            }
        })
    }

    _handleDeleteContent(e, t) {
        const i = this.editor.plugins.get(fe), n = t[0], o = t[1], r = this.editor.model,
            a = !o || o.direction == "backward", l = i.getSelectedTableCells(n);
        l.length && (e.stop(), r.change(c => {
            const u = l[a ? l.length - 1 : 0];
            r.change(h => {
                for (const f of l) r.deleteContent(h.createSelection(f, "in"))
            });
            const d = r.schema.getNearestSelectionRange(c.createPositionAt(u, 0));
            n.is("documentSelection") ? c.setSelection(d) : n.setTo(d)
        }))
    }

    _handleInsertTextEvent(e, t) {
        const i = this.editor, n = this.getSelectedTableCells();
        if (!n) return;
        const o = i.editing.view, r = i.editing.mapper, a = n.map(l => o.createRangeOn(r.toViewElement(l)));
        t.selection = o.createSelection(a), t.preventDefault()
    }

    _getCellsToSelect(e, t) {
        const i = this.editor.plugins.get("TableUtils"), n = i.getCellLocation(e), o = i.getCellLocation(t),
            r = Math.min(n.row, o.row), a = Math.max(n.row, o.row), l = Math.min(n.column, o.column),
            c = parseInt(t.getAttribute("colspan") || "1") - 1, u = Math.max(n.column, o.column + c),
            d = new Array(a - r + 1).fill(null).map(() => []),
            h = {startRow: r, endRow: a, startColumn: l, endColumn: u};
        for (const {row: g, cell: _} of new $(e.findAncestor("table"), h)) d[g - r].push(_);
        const f = o.row < n.row, m = o.column < n.column;
        return f && d.reverse(), m && d.forEach(g => g.reverse()), {cells: d.flat(), backward: f || m}
    }
}

class e5 extends w {
    static get pluginName() {
        return "TableClipboard"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [En, $e, Dt, fe]
    }

    init() {
        const t = this.editor.editing.view.document;
        this.listenTo(t, "copy", (i, n) => this._onCopyCut(i, n)), this.listenTo(t, "cut", (i, n) => this._onCopyCut(i, n)), this._listenToContentInsertion(), this.decorate("_replaceTableSlotCell")
    }

    _listenToContentInsertion() {
        const {editor: e} = this, t = e.plugins.get($e), i = e.plugins.get(Dt);
        let n = !1;
        t.on("contentInsertion", (o, r) => {
            n = r.method === "paste"
        }), this.listenTo(e.model, "insertContent", (o, [r, a]) => {
            (n || i.getSelectedTableCells() !== null) && this._onInsertContent(o, r, a)
        }, {priority: "high"}), t.on("contentInsertion", () => {
            n = !1
        }, {priority: "lowest"})
    }

    _onCopyCut(e, t) {
        const i = this.editor.editing.view, n = this.editor.plugins.get(Dt), o = this.editor.plugins.get(En);
        n.getSelectedTableCells() && (e.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection) || (t.preventDefault(), e.stop(), this.editor.model.enqueueChange({isUndoable: e.name === "cut"}, () => {
            const r = o._copySelectedFragmentWithMarkers(e.name, this.editor.model.document.selection, () => n.getSelectionAsFragment());
            i.document.fire("clipboardOutput", {
                dataTransfer: t.dataTransfer,
                content: this.editor.data.toView(r),
                method: e.name
            })
        })))
    }

    _onInsertContent(e, t, i) {
        if (i && !i.is("documentSelection")) return;
        const n = this.editor.model, o = this.editor.plugins.get(fe), r = this.editor.plugins.get(En),
            a = this.getTableIfOnlyTableInContent(t, n);
        if (!a) return;
        const l = o.getSelectionAffectedTableCells(n.document.selection);
        if (!l.length) {
            Ba(a, o);
            return
        }
        e.stop(), t.is("documentFragment") ? r._pasteMarkersIntoTransformedElement(t.markers, c => this._replaceSelectedCells(a, l, c)) : this.editor.model.change(c => {
            this._replaceSelectedCells(a, l, c)
        })
    }

    _replaceSelectedCells(e, t, i) {
        const n = this.editor.plugins.get(fe), o = {width: n.getColumns(e), height: n.getRows(e)}, r = t5(t, o, i, n),
            a = r.lastRow - r.firstRow + 1, l = r.lastColumn - r.firstColumn + 1,
            c = {startRow: 0, startColumn: 0, endRow: Math.min(a, o.height) - 1, endColumn: Math.min(l, o.width) - 1};
        e = fg(e, c, i);
        const u = t[0].findAncestor("table"), d = this._replaceSelectedCellsWithPasted(e, o, u, r, i);
        if (this.editor.plugins.get("TableSelection").isEnabled) {
            const h = n.sortRanges(d.map(f => i.createRangeOn(f)));
            i.setSelection(h)
        } else i.setSelection(d[0], 0);
        return u
    }

    _replaceSelectedCellsWithPasted(e, t, i, n, o) {
        const {width: r, height: a} = t, l = n5(e, r, a), c = [...new $(i, {
            startRow: n.firstRow,
            endRow: n.lastRow,
            startColumn: n.firstColumn,
            endColumn: n.lastColumn,
            includeAllSlots: !0
        })], u = [];
        let d;
        for (const _ of c) {
            const {row: v, column: E} = _;
            E === n.firstColumn && (d = _.getPositionBefore());
            const V = v - n.firstRow, N = E - n.firstColumn, Z = l[V % a][N % r], A = Z ? o.cloneElement(Z) : null,
                F = this._replaceTableSlotCell(_, A, d, o);
            F && (bg(F, v, E, n.lastRow, n.lastColumn, o), u.push(F), d = o.createPositionAfter(F))
        }
        const h = parseInt(i.getAttribute("headingRows") || "0"), f = parseInt(i.getAttribute("headingColumns") || "0"),
            m = n.firstRow < h && h <= n.lastRow, g = n.firstColumn < f && f <= n.lastColumn;
        if (m) {
            const _ = {first: n.firstColumn, last: n.lastColumn}, v = Nr(i, h, _, o, n.firstRow);
            u.push(...v)
        }
        if (g) {
            const _ = {first: n.firstRow, last: n.lastRow}, v = zr(i, f, _, o);
            u.push(...v)
        }
        return u
    }

    _replaceTableSlotCell(e, t, i, n) {
        const {cell: o, isAnchor: r} = e;
        return r && n.remove(o), t ? (n.insert(t, i), t) : null
    }

    getTableIfOnlyTableInContent(e, t) {
        if (!e.is("documentFragment") && !e.is("element")) return null;
        if (e.is("element", "table")) return e;
        if (e.childCount == 1 && e.getChild(0).is("element", "table")) return e.getChild(0);
        const i = t.createRangeIn(e);
        for (const n of i.getItems()) if (n.is("element", "table")) {
            const o = t.createRange(i.start, t.createPositionBefore(n));
            if (t.hasContent(o, {ignoreWhitespaces: !0})) return null;
            const r = t.createRange(t.createPositionAfter(n), i.end);
            return t.hasContent(r, {ignoreWhitespaces: !0}) ? null : n
        }
        return null
    }
}

function t5(s, e, t, i) {
    const n = s[0].findAncestor("table"), o = i.getColumnIndexes(s), r = i.getRowIndexes(s),
        a = {firstColumn: o.first, lastColumn: o.last, firstRow: r.first, lastRow: r.last}, l = s.length === 1;
    return l && (a.lastRow += e.height - 1, a.lastColumn += e.width - 1, i5(n, a.lastRow + 1, a.lastColumn + 1, i)), l || !i.isSelectionRectangular(s) ? s5(n, a, t) : (a.lastRow = _g(n, a), a.lastColumn = vg(n, a)), a
}

function i5(s, e, t, i) {
    const n = i.getColumns(s), o = i.getRows(s);
    t > n && i.insertColumns(s, {at: n, columns: t - n}), e > o && i.insertRows(s, {at: o, rows: e - o})
}

function n5(s, e, t) {
    const i = new Array(t).fill(null).map(() => new Array(e).fill(null));
    for (const {column: n, row: o, cell: r} of new $(s)) i[o][n] = r;
    return i
}

function s5(s, e, t) {
    const {firstRow: i, lastRow: n, firstColumn: o, lastColumn: r} = e, a = {first: i, last: n},
        l = {first: o, last: r};
    zr(s, o, a, t), zr(s, r + 1, a, t), Nr(s, i, l, t), Nr(s, n + 1, l, t, i)
}

function Nr(s, e, t, i, n = 0) {
    return e < 1 ? void 0 : mg(s, e, n).filter(({
                                                    column: a,
                                                    cellWidth: l
                                                }) => kg(a, l, t)).map(({cell: a}) => gg(a, e, i))
}

function zr(s, e, t, i) {
    return e < 1 ? void 0 : pg(s, e).filter(({row: r, cellHeight: a}) => kg(r, a, t)).map(({
                                                                                               cell: r,
                                                                                               column: a
                                                                                           }) => wg(r, a, e, i))
}

function kg(s, e, t) {
    const i = s + e - 1, {first: n, last: o} = t, r = s >= n && s <= o, a = s < n && i >= n;
    return r || a
}

class o5 extends w {
    static get pluginName() {
        return "TableKeyboard"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Dt, fe]
    }

    init() {
        const e = this.editor, i = e.editing.view.document, n = e.t;
        this.listenTo(i, "arrowKey", (...o) => this._onArrowKey(...o), {context: "table"}), this.listenTo(i, "tab", (...o) => this._handleTabOnSelectedTable(...o), {context: "figure"}), this.listenTo(i, "tab", (...o) => this._handleTab(...o), {context: ["th", "td"]}), e.accessibility.addKeystrokeInfoGroup({
            id: "table",
            label: n("Keystrokes that can be used in a table cell"),
            keystrokes: [{
                label: n("Move the selection to the next cell"),
                keystroke: "Tab"
            }, {
                label: n("Move the selection to the previous cell"),
                keystroke: "Shift+Tab"
            }, {
                label: n("Insert a new table row (when in the last cell of a table)"),
                keystroke: "Tab"
            }, {
                label: n("Navigate through the table"),
                keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
            }]
        })
    }

    _handleTabOnSelectedTable(e, t) {
        const i = this.editor, o = i.model.document.selection.getSelectedElement();
        !o || !o.is("element", "table") || (t.preventDefault(), t.stopPropagation(), e.stop(), i.model.change(r => {
            r.setSelection(r.createRangeIn(o.getChild(0).getChild(0)))
        }))
    }

    _handleTab(e, t) {
        const i = this.editor, n = this.editor.plugins.get(fe), o = this.editor.plugins.get("TableSelection"),
            r = i.model.document.selection, a = !t.shiftKey;
        let l = n.getTableCellsContainingSelection(r)[0];
        if (l || (l = o.getFocusCell()), !l) return;
        t.preventDefault(), t.stopPropagation(), e.stop();
        const c = l.parent, u = c.parent, d = u.getChildIndex(c), h = c.getChildIndex(l), f = h === 0;
        if (!a && f && d === 0) {
            i.model.change(v => {
                v.setSelection(v.createRangeOn(u))
            });
            return
        }
        const m = h === c.childCount - 1, g = d === n.getRows(u) - 1;
        if (a && g && m && (i.execute("insertTableRowBelow"), d === n.getRows(u) - 1)) {
            i.model.change(v => {
                v.setSelection(v.createRangeOn(u))
            });
            return
        }
        let _;
        if (a && m) _ = u.getChild(d + 1).getChild(0); else if (!a && f) {
            const v = u.getChild(d - 1);
            _ = v.getChild(v.childCount - 1)
        } else _ = c.getChild(h + (a ? 1 : -1));
        i.model.change(v => {
            v.setSelection(v.createRangeIn(_))
        })
    }

    _onArrowKey(e, t) {
        const i = this.editor, n = t.keyCode, o = Yr(n, i.locale.contentLanguageDirection);
        this._handleArrowKeys(o, t.shiftKey) && (t.preventDefault(), t.stopPropagation(), e.stop())
    }

    _handleArrowKeys(e, t) {
        const i = this.editor.plugins.get(fe), n = this.editor.plugins.get("TableSelection"), o = this.editor.model,
            r = o.document.selection, a = ["right", "down"].includes(e), l = i.getSelectedTableCells(r);
        if (l.length) {
            let u;
            return t ? u = n.getFocusCell() : u = a ? l[l.length - 1] : l[0], this._navigateFromCellInDirection(u, e, t), !0
        }
        const c = r.focus.findAncestor("tableCell");/* istanbul ignore if: paranoid check -- @preserve */
        if (!c) return !1;
        if (!r.isCollapsed) if (t) {
            if (r.isBackward == a && !r.containsEntireContent(c)) return !1
        } else {
            const u = r.getSelectedElement();
            if (!u || !o.schema.isObject(u)) return !1
        }
        return this._isSelectionAtCellEdge(r, c, a) ? (this._navigateFromCellInDirection(c, e, t), !0) : !1
    }

    _isSelectionAtCellEdge(e, t, i) {
        const n = this.editor.model, o = this.editor.model.schema, r = i ? e.getLastPosition() : e.getFirstPosition();
        if (!o.getLimitElement(r).is("element", "tableCell")) return n.createPositionAt(t, i ? "end" : 0).isTouching(r);
        const a = n.createSelection(r);
        return n.modifySelection(a, {direction: i ? "forward" : "backward"}), r.isEqual(a.focus)
    }

    _navigateFromCellInDirection(e, t, i = !1) {
        const n = this.editor.model, o = e.findAncestor("table"), r = [...new $(o, {includeAllSlots: !0})], {
            row: a,
            column: l
        } = r[r.length - 1], c = r.find(({cell: E}) => E == e);
        let {row: u, column: d} = c;
        switch (t) {
            case"left":
                d--;
                break;
            case"up":
                u--;
                break;
            case"right":
                d += c.cellWidth;
                break;
            case"down":
                u += c.cellHeight;
                break
        }
        const h = u < 0 || u > a, f = d < 0 && u <= 0, m = d > l && u >= a;
        if (h || f || m) {
            n.change(E => {
                E.setSelection(E.createRangeOn(o))
            });
            return
        }
        d < 0 ? (d = i ? 0 : l, u--) : d > l && (d = i ? l : 0, u++);
        const g = r.find(E => E.row == u && E.column == d).cell, _ = ["right", "down"].includes(t),
            v = this.editor.plugins.get("TableSelection");
        if (i && v.isEnabled) {
            const E = v.getAnchorCell() || e;
            v.setCellSelection(E, g)
        } else {
            const E = n.createPositionAt(g, _ ? 0 : "end");
            n.change(V => {
                V.setSelection(E)
            })
        }
    }
}

class r5 extends Pt {
    domEventType = ["mousemove", "mouseleave"];

    onDomEvent(e) {
        this.fire(e.type, e)
    }
}

class a5 extends w {
    static get pluginName() {
        return "TableMouse"
    }

    static get isOfficialPlugin() {
        return !0
    }

    static get requires() {
        return [Dt, fe]
    }

    init() {
        this.editor.editing.view.addObserver(r5), this._enableShiftClickSelection(), this._enableMouseDragSelection()
    }

    _enableShiftClickSelection() {
        const e = this.editor, t = e.plugins.get(fe);
        let i = !1;
        const n = e.plugins.get(Dt);
        this.listenTo(e.editing.view.document, "mousedown", (o, r) => {
            const a = e.model.document.selection;
            if (!this.isEnabled || !n.isEnabled || !r.domEvent.shiftKey) return;
            const l = n.getAnchorCell() || t.getTableCellsContainingSelection(a)[0];
            if (!l) return;
            const c = this._getModelTableCellFromDomEvent(r);
            c && wd(l, c) && (i = !0, n.setCellSelection(l, c), r.preventDefault())
        }), this.listenTo(e.editing.view.document, "mouseup", () => {
            i = !1
        }), this.listenTo(e.editing.view.document, "selectionChange", o => {
            i && o.stop()
        }, {priority: "highest"})
    }

    _enableMouseDragSelection() {
        const e = this.editor;
        let t, i, n = !1, o = !1;
        const r = e.plugins.get(Dt);
        this.listenTo(e.editing.view.document, "mousedown", (a, l) => {
            !this.isEnabled || !r.isEnabled || l.domEvent.shiftKey || l.domEvent.ctrlKey || l.domEvent.altKey || (t = this._getModelTableCellFromDomEvent(l))
        }), this.listenTo(e.editing.view.document, "mousemove", (a, l) => {
            if (!l.domEvent.buttons || !t) return;
            const c = this._getModelTableCellFromDomEvent(l);
            c && wd(t, c) && (i = c, !n && i != t && (n = !0)), n && (o = !0, r.setCellSelection(t, i), l.preventDefault())
        }), this.listenTo(e.editing.view.document, "mouseup", () => {
            n = !1, o = !1, t = null, i = null
        }), this.listenTo(e.editing.view.document, "selectionChange", a => {
            o && a.stop()
        }, {priority: "highest"})
    }

    _getModelTableCellFromDomEvent(e) {
        const t = e.target, i = this.editor.editing.view.createPositionAt(t, 0);
        return this.editor.editing.mapper.toModelPosition(i).parent.findAncestor("tableCell", {includeSelf: !0})
    }
}

function wd(s, e) {
    return s.parent.parent == e.parent.parent
}

class l5 extends w {
    static get requires() {
        return [Q2, Y2, Dt, a5, o5, e5, di]
    }

    static get pluginName() {
        return "Table"
    }

    static get isOfficialPlugin() {
        return !0
    }
}

function c5(s) {
    const e = s.getSelectedElement();
    return e && Cg(e) ? e : null
}

function u5(s) {
    const e = s.getFirstPosition();
    if (!e) return null;
    let t = e.parent;
    for (; t;) {
        if (t.is("element") && Cg(t)) return t;
        t = t.parent
    }
    return null
}

function Cg(s) {
    return !!s.getCustomProperty("table") && ie(s)
}

class d5 extends w {
    static get requires() {
        return [$s]
    }

    static get pluginName() {
        return "TableToolbar"
    }

    static get isOfficialPlugin() {
        return !0
    }

    afterInit() {
        const e = this.editor, t = e.t, i = e.plugins.get($s), n = e.config.get("table.contentToolbar"),
            o = e.config.get("table.tableToolbar");
        n && i.register("tableContent", {
            ariaLabel: t("Table toolbar"),
            items: n,
            getRelatedElement: u5
        }), o && i.register("table", {ariaLabel: t("Table toolbar"), items: o, getRelatedElement: c5})
    }
}/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */
/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */function Eg(s) {
    if (s.is("$text") || s.is("$textProxy")) return s.data;
    const e = s;
    let t = "", i = null;
    for (const n of e.getChildren()) {
        const o = Eg(n);
        i && i.is("element") && (t += `
`), t += o, i = n
    }
    return t
}

class h5 extends w {
    _config;
    _outputView;
    _wordsMatchRegExp;

    constructor(e) {
        super(e), this.set("characters", 0), this.set("words", 0), Object.defineProperties(this, {
            characters: {
                get() {
                    return this.characters = this._getCharacters(this._getText())
                }
            }, words: {
                get() {
                    return this.words = this._getWords(this._getText())
                }
            }
        }), this.set("_wordsLabel", void 0), this.set("_charactersLabel", void 0), this._config = e.config.get("wordCount") || {}, this._outputView = void 0, this._wordsMatchRegExp = x.features.isRegExpUnicodePropertySupported ? new RegExp("([\\p{L}\\p{N}]+\\S?)+", "gu") : /([a-zA-Z0-9À-ž]+\S?)+/gu
    }

    static get pluginName() {
        return "WordCount"
    }

    static get isOfficialPlugin() {
        return !0
    }

    init() {
        this.editor.model.document.on("change:data", Ni(this._refreshStats.bind(this), 250)), typeof this._config.onUpdate == "function" && this.on("update", (t, i) => {
            this._config.onUpdate(i)
        }), At(this._config.container) && this._config.container.appendChild(this.wordCountContainer)
    }

    destroy() {
        this._outputView && (this._outputView.element.remove(), this._outputView.destroy()), super.destroy()
    }

    get wordCountContainer() {
        const e = this.editor, t = e.t, i = e.config.get("wordCount.displayWords"),
            n = e.config.get("wordCount.displayCharacters"), o = Te.bind(this, this), r = [];
        return this._outputView || (this._outputView = new T, (i || i === void 0) && (this.bind("_wordsLabel").to(this, "words", a => t("Words: %0", a)), r.push({
            tag: "div",
            children: [{text: [o.to("_wordsLabel")]}],
            attributes: {class: "ck-word-count__words"}
        })), (n || n === void 0) && (this.bind("_charactersLabel").to(this, "characters", a => t("Characters: %0", a)), r.push({
            tag: "div",
            children: [{text: [o.to("_charactersLabel")]}],
            attributes: {class: "ck-word-count__characters"}
        })), this._outputView.setTemplate({
            tag: "div",
            attributes: {class: ["ck", "ck-word-count"]},
            children: r
        }), this._outputView.render()), this._outputView.element
    }

    _getText() {
        let e = "";
        for (const t of this.editor.model.document.getRoots()) e !== "" && (e += `
`), e += Eg(t);
        return e
    }

    _getCharacters(e) {
        return e.replace(/\n/g, "").length
    }

    _getWords(e) {
        return (e.match(this._wordsMatchRegExp) || []).length
    }

    _refreshStats() {
        const e = this._getText(), t = this.words = this._getWords(e), i = this.characters = this._getCharacters(e);
        this.fire("update", {words: t, characters: i})
    }
}

const f5 = {
    toolbar: {items: ["fontFamily", "fontSize", "|", "imageUpload", "mediaEmbed", "link", "|", "bold", "underline", "italic", "strikethrough", "|", "fontColor", "fontBackgroundColor", "removeFormat", "|", "alignment", "numberedList", "bulletedList", "indent", "outdent", "|", "blockQuote", "horizontalLine", "undo", "redo", "sourceEditing"]},
    plugins: [Yk, vC, YA, Xm, yC, $C, EC, XE, hT, zT, FT, kT, VT, WA, GT, XT, rA, lx, mx, ux, Mx, zm, qx, iI, Pa, nI, Nm, aI, xC, HI, KI, kS, BS, nP, uo, GP, QP, Uv, YP, PC, l5, d5, hC, OC, h5],
    extraPlugins: [p5],
    fontFamily: {supportAllValues: !0},
    fontSize: {options: [10, 12, 14, "default", 18, 20, 22], supportAllValues: !0},
    htmlSupport: {
        allow: [{name: "div", attributes: {id: !0}, classes: !0}, {
            name: "video",
            attributes: !0,
            classes: !0,
            styles: !0
        }]
    },
    image: {
        upload: {types: ["jpeg", "png", "gif", "bmp", "webp", "tiff", "svg+xml"]},
        resizeUnit: "px",
        resizeOptions: [{name: "resizeImage:original", value: null, icon: "original"}, {
            name: "resizeImage:400",
            value: "400",
            icon: "medium"
        }, {name: "resizeImage:800", value: "800", icon: "large"}],
        toolbar: ["resizeImage:400", "resizeImage:800", "resizeImage:original", "|", "imageStyle:inline", "imageStyle:block", "imageStyle:side"]
    },
    language: "ko",
    licenseKey: "GPL",
    link: {addTargetToExternalLinks: !0},
    mention: {feeds: [{marker: "@", feed: []}]}
}, m5 = 2 * 1024 * 1024;

class g5 {
    constructor(e) {
        this.loader = e
    }

    upload() {
        return this.loader.file.then(e => {
            if (e.size > m5) return Promise.reject("첨부파일은 최대 2MB까지 등록 가능합니다");
            const t = new FormData;
            return t.append("upload", e), fetch("/articles/images", {
                method: "POST",
                body: t,
                credentials: "include"
            }).then(i => i.json()).then(i => (console.log("서버 응답:", i), i.uploaded ? {default: i.url} : Promise.reject(i.error || "업로드 실패"))).catch(i => {
                console.error("에러 발생:", i);
                const n = i instanceof Error ? i.message : i;
                return alert(n), Promise.reject(n)
            })
        })
    }

    abort() {
    }
}

function p5(s) {
    s.plugins.get("FileRepository").createUploadAdapter = e => new g5(e)
}

window.createCKEditor = function (s, e = {}) {
    const t = {...f5, ...e};
    return zE.create(document.querySelector(s), t).then(i => {
        const n = i.plugins.get("WordCount");
        if (!n) return console.error("WordCount plugin not found!"), i;

        function o() {
            setTimeout(() => {
                const r = i.getData();
                if (r) {
                    const a = document.createElement("div");
                    a.innerHTML = r;
                    const c = (a.textContent || a.innerText || "").length, u = document.getElementById("count");
                    u && (u.textContent = c)
                }
            }, 100)
        }

        return i.model.document.on("ready", () => {
            o()
        }), setTimeout(() => {
            o()
        }, 200), n.on("update", (r, a) => {
            const l = document.getElementById("count");
            if (l && a) {
                const u = a.characters || 0;
                if (u > 1e4) {
                    alert("본문은 10000자를 초과할 수 없습니다.");
                    let d = i.getData();
                    const h = document.createElement("div");
                    h.innerHTML = d;
                    let f = h.textContent || h.innerText || "";
                    const m = 9997, g = f.substring(0, m);
                    i.setData(`<p>${g}</p>`), l.textContent = m
                } else l.textContent = u
            } else console.error("Count element or stats not found")
        }), i
    })
};
